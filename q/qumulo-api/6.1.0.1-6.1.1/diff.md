# Comparing `tmp/qumulo_api-6.1.0.1-py3-none-any.whl.zip` & `tmp/qumulo_api-6.1.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,109 +1,109 @@
-Zip file size: 253298 bytes, number of entries: 107
--rw-r--r--  2.0 unx       24 b- defN 23-Jun-16 00:34 qumulo/__init__.py
--rw-r--r--  2.0 unx    10792 b- defN 23-Jun-16 00:34 qumulo/rest_client.py
--rw-r--r--  2.0 unx     5463 b- defN 23-Jun-16 00:34 qumulo/retry.py
--rw-r--r--  2.0 unx     1178 b- defN 23-Jun-16 00:34 qumulo/commands/__init__.py
--rw-r--r--  2.0 unx     7430 b- defN 23-Jun-16 00:34 qumulo/commands/access_tokens.py
--rw-r--r--  2.0 unx    15993 b- defN 23-Jun-16 00:34 qumulo/commands/ad.py
--rw-r--r--  2.0 unx     5048 b- defN 23-Jun-16 00:34 qumulo/commands/analytics.py
--rw-r--r--  2.0 unx     6531 b- defN 23-Jun-16 00:34 qumulo/commands/audit.py
--rw-r--r--  2.0 unx    35605 b- defN 23-Jun-16 00:34 qumulo/commands/auth.py
--rw-r--r--  2.0 unx     1045 b- defN 23-Jun-16 00:34 qumulo/commands/checksumming.py
--rw-r--r--  2.0 unx    18179 b- defN 23-Jun-16 00:34 qumulo/commands/cluster.py
--rw-r--r--  2.0 unx     4605 b- defN 23-Jun-16 00:34 qumulo/commands/dns.py
--rw-r--r--  2.0 unx     1506 b- defN 23-Jun-16 00:34 qumulo/commands/encryption.py
--rw-r--r--  2.0 unx     2843 b- defN 23-Jun-16 00:34 qumulo/commands/file_permissions_help.py
--rw-r--r--  2.0 unx   129986 b- defN 23-Jun-16 00:34 qumulo/commands/fs.py
--rw-r--r--  2.0 unx     3933 b- defN 23-Jun-16 00:34 qumulo/commands/ftp.py
--rw-r--r--  2.0 unx     3603 b- defN 23-Jun-16 00:34 qumulo/commands/kerberos.py
--rw-r--r--  2.0 unx    21410 b- defN 23-Jun-16 00:34 qumulo/commands/key_store.py
--rw-r--r--  2.0 unx    12310 b- defN 23-Jun-16 00:34 qumulo/commands/ldap.py
--rw-r--r--  2.0 unx     6846 b- defN 23-Jun-16 00:34 qumulo/commands/login.py
--rw-r--r--  2.0 unx     1070 b- defN 23-Jun-16 00:34 qumulo/commands/metrics.py
--rw-r--r--  2.0 unx    15745 b- defN 23-Jun-16 00:34 qumulo/commands/multitenancy.py
--rw-r--r--  2.0 unx     9981 b- defN 23-Jun-16 00:34 qumulo/commands/multitenancy_nfs.py
--rw-r--r--  2.0 unx     8845 b- defN 23-Jun-16 00:34 qumulo/commands/multitenancy_smb.py
--rw-r--r--  2.0 unx    20655 b- defN 23-Jun-16 00:34 qumulo/commands/network.py
--rw-r--r--  2.0 unx    34897 b- defN 23-Jun-16 00:34 qumulo/commands/nfs.py
--rw-r--r--  2.0 unx     1015 b- defN 23-Jun-16 00:34 qumulo/commands/node_state.py
--rw-r--r--  2.0 unx    10630 b- defN 23-Jun-16 00:34 qumulo/commands/object_replication.py
--rw-r--r--  2.0 unx     6173 b- defN 23-Jun-16 00:34 qumulo/commands/quota.py
--rw-r--r--  2.0 unx     2531 b- defN 23-Jun-16 00:34 qumulo/commands/raw.py
--rw-r--r--  2.0 unx    32784 b- defN 23-Jun-16 00:34 qumulo/commands/replication.py
--rw-r--r--  2.0 unx    14355 b- defN 23-Jun-16 00:34 qumulo/commands/roles.py
--rw-r--r--  2.0 unx    15644 b- defN 23-Jun-16 00:34 qumulo/commands/s3.py
--rw-r--r--  2.0 unx     5323 b- defN 23-Jun-16 00:34 qumulo/commands/saml.py
--rw-r--r--  2.0 unx     3259 b- defN 23-Jun-16 00:34 qumulo/commands/shutdown.py
--rw-r--r--  2.0 unx    50961 b- defN 23-Jun-16 00:34 qumulo/commands/smb.py
--rw-r--r--  2.0 unx    45290 b- defN 23-Jun-16 00:34 qumulo/commands/snapshot.py
--rw-r--r--  2.0 unx     7403 b- defN 23-Jun-16 00:34 qumulo/commands/support.py
--rw-r--r--  2.0 unx     2935 b- defN 23-Jun-16 00:34 qumulo/commands/time_config.py
--rw-r--r--  2.0 unx     4604 b- defN 23-Jun-16 00:34 qumulo/commands/tree_delete.py
--rw-r--r--  2.0 unx     1403 b- defN 23-Jun-16 00:34 qumulo/commands/unconfigured_node_operations.py
--rw-r--r--  2.0 unx    21797 b- defN 23-Jun-16 00:34 qumulo/commands/upgrade.py
--rw-r--r--  2.0 unx      976 b- defN 23-Jun-16 00:34 qumulo/commands/version.py
--rw-r--r--  2.0 unx     7374 b- defN 23-Jun-16 00:34 qumulo/commands/web_ui.py
--rw-r--r--  2.0 unx      669 b- defN 23-Jun-16 00:34 qumulo/lib/__init__.py
--rw-r--r--  2.0 unx    12849 b- defN 23-Jun-16 00:34 qumulo/lib/acl_util.py
--rw-r--r--  2.0 unx     4047 b- defN 23-Jun-16 00:34 qumulo/lib/auth.py
--rw-r--r--  2.0 unx     1833 b- defN 23-Jun-16 00:34 qumulo/lib/duration.py
--rw-r--r--  2.0 unx    11107 b- defN 23-Jun-16 00:34 qumulo/lib/identity_util.py
--rw-r--r--  2.0 unx     3551 b- defN 23-Jun-16 00:34 qumulo/lib/keys.py
--rw-r--r--  2.0 unx     2230 b- defN 23-Jun-16 00:34 qumulo/lib/obj.py
--rw-r--r--  2.0 unx     8873 b- defN 23-Jun-16 00:34 qumulo/lib/opts.py
--rw-r--r--  2.0 unx     6016 b- defN 23-Jun-16 00:34 qumulo/lib/qq.py
--rw-r--r--  2.0 unx    24972 b- defN 23-Jun-16 00:34 qumulo/lib/request.py
--rw-r--r--  2.0 unx     1058 b- defN 23-Jun-16 00:34 qumulo/lib/rest_util.py
--rw-r--r--  2.0 unx      926 b- defN 23-Jun-16 00:34 qumulo/lib/rfc3339.py
--rw-r--r--  2.0 unx     2009 b- defN 23-Jun-16 00:34 qumulo/lib/tenant.py
--rw-r--r--  2.0 unx     3350 b- defN 23-Jun-16 00:34 qumulo/lib/uri.py
--rw-r--r--  2.0 unx    14792 b- defN 23-Jun-16 00:34 qumulo/lib/util.py
--rw-r--r--  2.0 unx     1167 b- defN 23-Jun-16 00:34 qumulo/rest/__init__.py
--rw-r--r--  2.0 unx     4501 b- defN 23-Jun-16 00:34 qumulo/rest/access_tokens.py
--rw-r--r--  2.0 unx     7654 b- defN 23-Jun-16 00:34 qumulo/rest/ad.py
--rw-r--r--  2.0 unx     2204 b- defN 23-Jun-16 00:34 qumulo/rest/analytics.py
--rw-r--r--  2.0 unx     5909 b- defN 23-Jun-16 00:34 qumulo/rest/audit.py
--rw-r--r--  2.0 unx     8419 b- defN 23-Jun-16 00:34 qumulo/rest/auth.py
--rw-r--r--  2.0 unx      914 b- defN 23-Jun-16 00:34 qumulo/rest/checksumming.py
--rw-r--r--  2.0 unx     8793 b- defN 23-Jun-16 00:34 qumulo/rest/cluster.py
--rw-r--r--  2.0 unx     3056 b- defN 23-Jun-16 00:34 qumulo/rest/dns.py
--rw-r--r--  2.0 unx     1148 b- defN 23-Jun-16 00:34 qumulo/rest/encryption.py
--rw-r--r--  2.0 unx    49457 b- defN 23-Jun-16 00:34 qumulo/rest/fs.py
--rw-r--r--  2.0 unx     4531 b- defN 23-Jun-16 00:34 qumulo/rest/ftp.py
--rw-r--r--  2.0 unx     4410 b- defN 23-Jun-16 00:34 qumulo/rest/groups.py
--rw-r--r--  2.0 unx     2897 b- defN 23-Jun-16 00:34 qumulo/rest/kerberos.py
--rw-r--r--  2.0 unx     4490 b- defN 23-Jun-16 00:34 qumulo/rest/ldap.py
--rw-r--r--  2.0 unx     1251 b- defN 23-Jun-16 00:34 qumulo/rest/metrics.py
--rw-r--r--  2.0 unx     4909 b- defN 23-Jun-16 00:34 qumulo/rest/multitenancy.py
--rw-r--r--  2.0 unx     5260 b- defN 23-Jun-16 00:34 qumulo/rest/multitenancy_nfs.py
--rw-r--r--  2.0 unx     3616 b- defN 23-Jun-16 00:34 qumulo/rest/multitenancy_smb.py
--rw-r--r--  2.0 unx     8417 b- defN 23-Jun-16 00:34 qumulo/rest/network.py
--rw-r--r--  2.0 unx     8467 b- defN 23-Jun-16 00:34 qumulo/rest/nfs.py
--rw-r--r--  2.0 unx      910 b- defN 23-Jun-16 00:34 qumulo/rest/node_state.py
--rw-r--r--  2.0 unx     4468 b- defN 23-Jun-16 00:34 qumulo/rest/object_replication.py
--rw-r--r--  2.0 unx     3426 b- defN 23-Jun-16 00:34 qumulo/rest/quota.py
--rw-r--r--  2.0 unx    10612 b- defN 23-Jun-16 00:34 qumulo/rest/replication.py
--rw-r--r--  2.0 unx     6628 b- defN 23-Jun-16 00:34 qumulo/rest/roles.py
--rw-r--r--  2.0 unx     9857 b- defN 23-Jun-16 00:34 qumulo/rest/s3.py
--rw-r--r--  2.0 unx     2687 b- defN 23-Jun-16 00:34 qumulo/rest/saml.py
--rw-r--r--  2.0 unx     1944 b- defN 23-Jun-16 00:34 qumulo/rest/shutdown.py
--rw-r--r--  2.0 unx    11128 b- defN 23-Jun-16 00:34 qumulo/rest/smb.py
--rw-r--r--  2.0 unx    12813 b- defN 23-Jun-16 00:34 qumulo/rest/snapshot.py
--rw-r--r--  2.0 unx     3265 b- defN 23-Jun-16 00:34 qumulo/rest/support.py
--rw-r--r--  2.0 unx     1972 b- defN 23-Jun-16 00:34 qumulo/rest/time_config.py
--rw-r--r--  2.0 unx     2706 b- defN 23-Jun-16 00:34 qumulo/rest/tree_delete.py
--rw-r--r--  2.0 unx     1780 b- defN 23-Jun-16 00:34 qumulo/rest/unconfigured_node_operations.py
--rw-r--r--  2.0 unx     1960 b- defN 23-Jun-16 00:34 qumulo/rest/upgrade.py
--rw-r--r--  2.0 unx     2968 b- defN 23-Jun-16 00:34 qumulo/rest/upgrade_v2.py
--rw-r--r--  2.0 unx     1234 b- defN 23-Jun-16 00:34 qumulo/rest/upgrade_v3.py
--rw-r--r--  2.0 unx     4689 b- defN 23-Jun-16 00:34 qumulo/rest/users.py
--rw-r--r--  2.0 unx     1593 b- defN 23-Jun-16 00:34 qumulo/rest/version.py
--rw-r--r--  2.0 unx     3679 b- defN 23-Jun-16 00:34 qumulo/rest/web_ui.py
--rw-r--r--  2.0 unx    11358 b- defN 23-Jun-16 00:34 qumulo_api-6.1.0.1.dist-info/LICENSE
--rw-r--r--  2.0 unx     3778 b- defN 23-Jun-16 00:34 qumulo_api-6.1.0.1.dist-info/METADATA
--r--r--r--  2.0 unx      290 b- defN 23-Jun-16 00:34 qumulo_api-6.1.0.1.dist-info/NOTICE
--rw-r--r--  2.0 unx       92 b- defN 23-Jun-16 00:34 qumulo_api-6.1.0.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       68 b- defN 23-Jun-16 00:34 qumulo_api-6.1.0.1.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        7 b- defN 23-Jun-16 00:34 qumulo_api-6.1.0.1.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     8742 b- defN 23-Jun-16 00:34 qumulo_api-6.1.0.1.dist-info/RECORD
-107 files, 974386 bytes uncompressed, 239774 bytes compressed:  75.4%
+Zip file size: 254717 bytes, number of entries: 107
+-rw-r--r--  2.0 unx       22 b- defN 23-May-16 05:43 qumulo/__init__.py
+-rw-r--r--  2.0 unx    11049 b- defN 23-May-16 05:43 qumulo/rest_client.py
+-rw-r--r--  2.0 unx     5463 b- defN 23-May-16 05:43 qumulo/retry.py
+-rw-r--r--  2.0 unx     1178 b- defN 23-May-16 05:43 qumulo/commands/__init__.py
+-rw-r--r--  2.0 unx     7430 b- defN 23-May-16 05:43 qumulo/commands/access_tokens.py
+-rw-r--r--  2.0 unx    16853 b- defN 23-May-16 05:43 qumulo/commands/ad.py
+-rw-r--r--  2.0 unx     5048 b- defN 23-May-16 05:43 qumulo/commands/analytics.py
+-rw-r--r--  2.0 unx     6531 b- defN 23-May-16 05:43 qumulo/commands/audit.py
+-rw-r--r--  2.0 unx    35605 b- defN 23-May-16 05:43 qumulo/commands/auth.py
+-rw-r--r--  2.0 unx     1045 b- defN 23-May-16 05:43 qumulo/commands/checksumming.py
+-rw-r--r--  2.0 unx    18172 b- defN 23-May-16 05:43 qumulo/commands/cluster.py
+-rw-r--r--  2.0 unx     4605 b- defN 23-May-16 05:43 qumulo/commands/dns.py
+-rw-r--r--  2.0 unx     1506 b- defN 23-May-16 05:43 qumulo/commands/encryption.py
+-rw-r--r--  2.0 unx     2843 b- defN 23-May-16 05:43 qumulo/commands/file_permissions_help.py
+-rw-r--r--  2.0 unx   129900 b- defN 23-May-16 05:43 qumulo/commands/fs.py
+-rw-r--r--  2.0 unx     3933 b- defN 23-May-16 05:43 qumulo/commands/ftp.py
+-rw-r--r--  2.0 unx     3596 b- defN 23-May-16 05:43 qumulo/commands/kerberos.py
+-rw-r--r--  2.0 unx    18150 b- defN 23-May-16 05:43 qumulo/commands/key_store.py
+-rw-r--r--  2.0 unx    12310 b- defN 23-May-16 05:43 qumulo/commands/ldap.py
+-rw-r--r--  2.0 unx     6846 b- defN 23-May-16 05:43 qumulo/commands/login.py
+-rw-r--r--  2.0 unx     1070 b- defN 23-May-16 05:43 qumulo/commands/metrics.py
+-rw-r--r--  2.0 unx    16823 b- defN 23-May-16 05:43 qumulo/commands/multitenancy.py
+-rw-r--r--  2.0 unx     9981 b- defN 23-May-16 05:43 qumulo/commands/multitenancy_nfs.py
+-rw-r--r--  2.0 unx     8845 b- defN 23-May-16 05:43 qumulo/commands/multitenancy_smb.py
+-rw-r--r--  2.0 unx    20655 b- defN 23-May-16 05:43 qumulo/commands/network.py
+-rw-r--r--  2.0 unx    34897 b- defN 23-May-16 05:43 qumulo/commands/nfs.py
+-rw-r--r--  2.0 unx     1015 b- defN 23-May-16 05:43 qumulo/commands/node_state.py
+-rw-r--r--  2.0 unx    10630 b- defN 23-May-16 05:43 qumulo/commands/object_replication.py
+-rw-r--r--  2.0 unx     6173 b- defN 23-May-16 05:43 qumulo/commands/quota.py
+-rw-r--r--  2.0 unx     2531 b- defN 23-May-16 05:43 qumulo/commands/raw.py
+-rw-r--r--  2.0 unx    35414 b- defN 23-May-16 05:43 qumulo/commands/replication.py
+-rw-r--r--  2.0 unx    14355 b- defN 23-May-16 05:43 qumulo/commands/roles.py
+-rw-r--r--  2.0 unx    15644 b- defN 23-May-16 05:43 qumulo/commands/s3.py
+-rw-r--r--  2.0 unx     5323 b- defN 23-May-16 05:43 qumulo/commands/saml.py
+-rw-r--r--  2.0 unx     3259 b- defN 23-May-16 05:43 qumulo/commands/shutdown.py
+-rw-r--r--  2.0 unx    52180 b- defN 23-May-16 05:43 qumulo/commands/smb.py
+-rw-r--r--  2.0 unx    44057 b- defN 23-May-16 05:43 qumulo/commands/snapshot.py
+-rw-r--r--  2.0 unx     7403 b- defN 23-May-16 05:43 qumulo/commands/support.py
+-rw-r--r--  2.0 unx     2935 b- defN 23-May-16 05:43 qumulo/commands/time_config.py
+-rw-r--r--  2.0 unx     4604 b- defN 23-May-16 05:43 qumulo/commands/tree_delete.py
+-rw-r--r--  2.0 unx     1403 b- defN 23-May-16 05:43 qumulo/commands/unconfigured_node_operations.py
+-rw-r--r--  2.0 unx    22129 b- defN 23-May-16 05:43 qumulo/commands/upgrade.py
+-rw-r--r--  2.0 unx      976 b- defN 23-May-16 05:43 qumulo/commands/version.py
+-rw-r--r--  2.0 unx     7374 b- defN 23-May-16 05:43 qumulo/commands/web_ui.py
+-rw-r--r--  2.0 unx      669 b- defN 23-May-16 05:43 qumulo/lib/__init__.py
+-rw-r--r--  2.0 unx    12849 b- defN 23-May-16 05:43 qumulo/lib/acl_util.py
+-rw-r--r--  2.0 unx     4047 b- defN 23-May-16 05:43 qumulo/lib/auth.py
+-rw-r--r--  2.0 unx     1833 b- defN 23-May-16 05:43 qumulo/lib/duration.py
+-rw-r--r--  2.0 unx    11107 b- defN 23-May-16 05:43 qumulo/lib/identity_util.py
+-rw-r--r--  2.0 unx     3551 b- defN 23-May-16 05:43 qumulo/lib/keys.py
+-rw-r--r--  2.0 unx     2230 b- defN 23-May-16 05:43 qumulo/lib/obj.py
+-rw-r--r--  2.0 unx     8901 b- defN 23-May-16 05:43 qumulo/lib/opts.py
+-rw-r--r--  2.0 unx     6063 b- defN 23-May-16 05:43 qumulo/lib/qq.py
+-rw-r--r--  2.0 unx    25203 b- defN 23-May-16 05:43 qumulo/lib/request.py
+-rw-r--r--  2.0 unx     1058 b- defN 23-May-16 05:43 qumulo/lib/rest_util.py
+-rw-r--r--  2.0 unx      926 b- defN 23-May-16 05:43 qumulo/lib/rfc3339.py
+-rw-r--r--  2.0 unx     2009 b- defN 23-May-16 05:43 qumulo/lib/tenant.py
+-rw-r--r--  2.0 unx     3350 b- defN 23-May-16 05:43 qumulo/lib/uri.py
+-rw-r--r--  2.0 unx    14792 b- defN 23-May-16 05:43 qumulo/lib/util.py
+-rw-r--r--  2.0 unx     1167 b- defN 23-May-16 05:43 qumulo/rest/__init__.py
+-rw-r--r--  2.0 unx     4501 b- defN 23-May-16 05:43 qumulo/rest/access_tokens.py
+-rw-r--r--  2.0 unx     7046 b- defN 23-May-16 05:43 qumulo/rest/ad.py
+-rw-r--r--  2.0 unx     2204 b- defN 23-May-16 05:43 qumulo/rest/analytics.py
+-rw-r--r--  2.0 unx     5909 b- defN 23-May-16 05:43 qumulo/rest/audit.py
+-rw-r--r--  2.0 unx     8419 b- defN 23-May-16 05:43 qumulo/rest/auth.py
+-rw-r--r--  2.0 unx      914 b- defN 23-May-16 05:43 qumulo/rest/checksumming.py
+-rw-r--r--  2.0 unx     8793 b- defN 23-May-16 05:43 qumulo/rest/cluster.py
+-rw-r--r--  2.0 unx     3056 b- defN 23-May-16 05:43 qumulo/rest/dns.py
+-rw-r--r--  2.0 unx     1148 b- defN 23-May-16 05:43 qumulo/rest/encryption.py
+-rw-r--r--  2.0 unx    49583 b- defN 23-May-16 05:43 qumulo/rest/fs.py
+-rw-r--r--  2.0 unx     4531 b- defN 23-May-16 05:43 qumulo/rest/ftp.py
+-rw-r--r--  2.0 unx     4410 b- defN 23-May-16 05:43 qumulo/rest/groups.py
+-rw-r--r--  2.0 unx     2897 b- defN 23-May-16 05:43 qumulo/rest/kerberos.py
+-rw-r--r--  2.0 unx     4490 b- defN 23-May-16 05:43 qumulo/rest/ldap.py
+-rw-r--r--  2.0 unx     1251 b- defN 23-May-16 05:43 qumulo/rest/metrics.py
+-rw-r--r--  2.0 unx     4909 b- defN 23-May-16 05:43 qumulo/rest/multitenancy.py
+-rw-r--r--  2.0 unx     5260 b- defN 23-May-16 05:43 qumulo/rest/multitenancy_nfs.py
+-rw-r--r--  2.0 unx     3616 b- defN 23-May-16 05:43 qumulo/rest/multitenancy_smb.py
+-rw-r--r--  2.0 unx     8417 b- defN 23-May-16 05:43 qumulo/rest/network.py
+-rw-r--r--  2.0 unx     8467 b- defN 23-May-16 05:43 qumulo/rest/nfs.py
+-rw-r--r--  2.0 unx      910 b- defN 23-May-16 05:43 qumulo/rest/node_state.py
+-rw-r--r--  2.0 unx     4468 b- defN 23-May-16 05:43 qumulo/rest/object_replication.py
+-rw-r--r--  2.0 unx     3426 b- defN 23-May-16 05:43 qumulo/rest/quota.py
+-rw-r--r--  2.0 unx    11002 b- defN 23-May-16 05:43 qumulo/rest/replication.py
+-rw-r--r--  2.0 unx     6628 b- defN 23-May-16 05:43 qumulo/rest/roles.py
+-rw-r--r--  2.0 unx     9857 b- defN 23-May-16 05:43 qumulo/rest/s3.py
+-rw-r--r--  2.0 unx     2687 b- defN 23-May-16 05:43 qumulo/rest/saml.py
+-rw-r--r--  2.0 unx     1944 b- defN 23-May-16 05:43 qumulo/rest/shutdown.py
+-rw-r--r--  2.0 unx    11128 b- defN 23-May-16 05:43 qumulo/rest/smb.py
+-rw-r--r--  2.0 unx    12759 b- defN 23-May-16 05:43 qumulo/rest/snapshot.py
+-rw-r--r--  2.0 unx     3265 b- defN 23-May-16 05:43 qumulo/rest/support.py
+-rw-r--r--  2.0 unx     1972 b- defN 23-May-16 05:43 qumulo/rest/time_config.py
+-rw-r--r--  2.0 unx     2706 b- defN 23-May-16 05:43 qumulo/rest/tree_delete.py
+-rw-r--r--  2.0 unx     1780 b- defN 23-May-16 05:43 qumulo/rest/unconfigured_node_operations.py
+-rw-r--r--  2.0 unx     1960 b- defN 23-May-16 05:43 qumulo/rest/upgrade.py
+-rw-r--r--  2.0 unx     2968 b- defN 23-May-16 05:43 qumulo/rest/upgrade_v2.py
+-rw-r--r--  2.0 unx     1234 b- defN 23-May-16 05:43 qumulo/rest/upgrade_v3.py
+-rw-r--r--  2.0 unx     4689 b- defN 23-May-16 05:43 qumulo/rest/users.py
+-rw-r--r--  2.0 unx     1593 b- defN 23-May-16 05:43 qumulo/rest/version.py
+-rw-r--r--  2.0 unx     3679 b- defN 23-May-16 05:43 qumulo/rest/web_ui.py
+-rw-r--r--  2.0 unx    11358 b- defN 23-May-16 05:43 qumulo_api-6.1.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3776 b- defN 23-May-16 05:43 qumulo_api-6.1.1.dist-info/METADATA
+-r--r--r--  2.0 unx      290 b- defN 23-May-16 05:43 qumulo_api-6.1.1.dist-info/NOTICE
+-rw-r--r--  2.0 unx       92 b- defN 23-May-16 05:43 qumulo_api-6.1.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       68 b- defN 23-May-16 05:43 qumulo_api-6.1.1.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        7 b- defN 23-May-16 05:43 qumulo_api-6.1.1.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     8728 b- defN 23-May-16 05:43 qumulo_api-6.1.1.dist-info/RECORD
+107 files, 976311 bytes uncompressed, 241221 bytes compressed:  75.3%
```

## zipnote {}

```diff
@@ -294,29 +294,29 @@
 
 Filename: qumulo/rest/version.py
 Comment: 
 
 Filename: qumulo/rest/web_ui.py
 Comment: 
 
-Filename: qumulo_api-6.1.0.1.dist-info/LICENSE
+Filename: qumulo_api-6.1.1.dist-info/LICENSE
 Comment: 
 
-Filename: qumulo_api-6.1.0.1.dist-info/METADATA
+Filename: qumulo_api-6.1.1.dist-info/METADATA
 Comment: 
 
-Filename: qumulo_api-6.1.0.1.dist-info/NOTICE
+Filename: qumulo_api-6.1.1.dist-info/NOTICE
 Comment: 
 
-Filename: qumulo_api-6.1.0.1.dist-info/WHEEL
+Filename: qumulo_api-6.1.1.dist-info/WHEEL
 Comment: 
 
-Filename: qumulo_api-6.1.0.1.dist-info/entry_points.txt
+Filename: qumulo_api-6.1.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: qumulo_api-6.1.0.1.dist-info/top_level.txt
+Filename: qumulo_api-6.1.1.dist-info/top_level.txt
 Comment: 
 
-Filename: qumulo_api-6.1.0.1.dist-info/RECORD
+Filename: qumulo_api-6.1.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## qumulo/__init__.py

```diff
@@ -1 +1 @@
-__version__ = "6.1.0.1"
+__version__ = "6.1.1"
```

## qumulo/rest_client.py

```diff
@@ -94,15 +94,14 @@
          over the qumulo.rest namespace to add properties for each module.
     """
 
     Error = request.RequestError
 
     # rest module attributes
     access_tokens: qumulo.rest.access_tokens.AccessTokens
-    ad: Any
     analytics: Any
     audit: Any
     auth: Any
     checksumming: Any
     cluster: Any
     dns: dns.Dns
     encryption: Any
@@ -158,14 +157,15 @@
             User-Agent header will be included.
         """
         self.conninfo = request.Connection(
             address, port, credentials, timeout=timeout, user_agent=user_agent
         )
 
         self.access_tokens = qumulo.rest.access_tokens.AccessTokens(self.conninfo)
+        self._ad = qumulo.rest.ad.ActiveDirectory(self.conninfo)
         self.metrics = qumulo.rest.metrics.Metrics(self.conninfo)
         self.multitenancy = qumulo.rest.multitenancy.Multitenancy(self.conninfo)
         self.s3 = qumulo.rest.s3.S3(self.conninfo)
         self.saml = qumulo.rest.saml.Saml(self.conninfo)
         self.web_ui = web_ui.WebUi(self.conninfo)
 
     def clone(self) -> 'RestClient':
@@ -185,14 +185,19 @@
     def credentials(self) -> Optional[Credentials]:
         return self.conninfo.credentials
 
     @credentials.setter
     def credentials(self, credentials: Credentials) -> None:
         self.conninfo.credentials = credentials
 
+    # XXX graeme: defining ad as a property allows mock spec to recognize that the RestClient has ad
+    @property
+    def ad(self) -> qumulo.rest.ad.ActiveDirectory:
+        return self._ad
+
     def handle_request_error(self, _error: Exception) -> bool:
         return False
 
     def login(self, username: str, password: str) -> Credentials:
         response_data = self.auth.login(username, password)
         self.conninfo.credentials = Credentials.from_login_response(response_data)
         return self.conninfo.credentials
@@ -298,9 +303,11 @@
 
         if isinstance(module, types.ModuleType):
             existing_property = getattr(cls, name, None)
             setattr(cls, name, _wrap_rest_module(module, existing_property))
 
 
 # These modules have been moved to the new pattern of directly adding attributes to the RestClient.
-DIRECT_MODULES = frozenset(['access_tokens', 'metrics', 'multitenancy', 's3', 'saml', 'web_ui'])
+DIRECT_MODULES = frozenset(
+    ['access_tokens', 'ad', 'metrics', 'multitenancy', 's3', 'saml', 'web_ui']
+)
 _wrap_all_rest_modules(qumulo.rest, RestClient, exclude_modules=DIRECT_MODULES)
```

## qumulo/commands/ad.py

```diff
@@ -18,33 +18,34 @@
 
 import qumulo.lib.auth
 import qumulo.lib.opts
 import qumulo.lib.util
 import qumulo.rest.ad as ad
 
 from qumulo.lib.opts import str_decode
+from qumulo.lib.request import pretty_json
 from qumulo.rest_client import RestClient
 
 
 class ListAdCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_list'
     SYNOPSIS = 'Get Active Directory configuration and connection status'
 
     @staticmethod
     def main(rest_client: RestClient, _args: argparse.Namespace) -> None:
-        print(ad.list_ad(rest_client.conninfo, rest_client.credentials))
+        print(pretty_json(rest_client.ad.list_ad()))
 
 
 class PollAdCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_poll'
     SYNOPSIS = 'Get details on a join or leave operation'
 
     @staticmethod
     def main(rest_client: RestClient, _args: argparse.Namespace) -> None:
-        print(ad.poll_ad(rest_client.conninfo, rest_client.credentials))
+        print(pretty_json(rest_client.ad.poll_ad()))
 
 
 def add_ad_options(parser: argparse.ArgumentParser, creds_required: bool) -> None:
     parser.add_argument(
         '-d',
         '--domain',
         type=str_decode,
@@ -89,14 +90,26 @@
             '--ou',
             type=str_decode,
             default='',
             required=False,
             help='Organizational Unit to join to',
         )
         parser.add_argument(
+            '--disable-search-trusted-domains',
+            action='store_false',
+            required=False,
+            default=None,
+            dest='search_trusted_domains',
+            help=(
+                'Disallows the cluster from using trusted domains for user information. Disabling'
+                ' may prevent the cluster from finding all relevant user and group membership data'
+                ' for authenticated users.'
+            ),
+        )
+        parser.add_argument(
             '--use-ad-posix-attributes',
             action='store_true',
             required=False,
             help='Use AD POSIX attributes.',
         )
         parser.add_argument(
             '--base-dn',
@@ -108,80 +121,102 @@
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
         if args.password is None:
             password = qumulo.lib.opts.read_password(prompt='Password: ')
         else:
             password = args.password
 
         print(
-            ad.join_ad(
-                rest_client.conninfo,
-                rest_client.credentials,
+            rest_client.ad.join_ad(
                 args.domain,
                 args.username,
                 password,
                 args.ou,
                 domain_netbios=args.domain_netbios,
+                search_trusted_domains=args.search_trusted_domains,
                 enable_ldap=args.use_ad_posix_attributes,
                 base_dn=args.base_dn,
             )
         )
 
 
 class ReconfigureAdCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_reconfigure'
     SYNOPSIS = 'Reconfigure Active Directory POSIX Attributes'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
+        search_action = parser.add_mutually_exclusive_group(required=False)
+        search_action.add_argument(
+            '--enable-search-trusted-domains',
+            action='store_true',
+            required=False,
+            default=None,
+            dest='search_trusted_domains',
+            help='Allows the cluster to search trusted domains for user information.',
+        )
+        search_action.add_argument(
+            '--disable-search-trusted-domains',
+            action='store_false',
+            required=False,
+            default=None,
+            dest='search_trusted_domains',
+            help=(
+                'Disallows the cluster from using trusted domains for user information. Disabling'
+                ' may prevent the cluster from finding all relevant user and group membership data'
+                ' for authenticated users.'
+            ),
+        )
+
         posix_action = parser.add_mutually_exclusive_group(required=False)
         posix_action.add_argument(
             '--enable-ad-posix-attributes',
             action='store_true',
             required=False,
             help='Use AD POSIX attributes.',
         )
         posix_action.add_argument(
             '--disable-ad-posix-attributes',
             action='store_true',
             required=False,
             help='Do not use AD POSIX attributes.',
         )
+
         parser.add_argument(
             '--base-dn',
             type=str_decode,
             required=False,
             help='When using AD POSIX extensions, query using this base DN',
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
         if (
-            not args.enable_ad_posix_attributes
+            args.search_trusted_domains is None
+            and not args.enable_ad_posix_attributes
             and not args.disable_ad_posix_attributes
             and args.base_dn is None
         ):
             raise ValueError('No changes specified')
 
-        ad_status = ad.list_ad(rest_client.conninfo, rest_client.credentials).data
+        ad_status = rest_client.ad.list_ad()
 
         if args.enable_ad_posix_attributes:
             use_ad_posix_attributes = True
         elif args.disable_ad_posix_attributes:
             use_ad_posix_attributes = False
         else:
             use_ad_posix_attributes = ad_status['use_ad_posix_attributes']
 
         base_dn = ad_status['base_dn'] if args.base_dn is None else args.base_dn
 
         print(
-            ad.reconfigure_ad(
-                rest_client.conninfo,
-                rest_client.credentials,
+            rest_client.ad.reconfigure_ad(
                 enable_ldap=use_ad_posix_attributes,
                 base_dn=base_dn,
+                search_trusted_domains=args.search_trusted_domains,
             )
         )
 
 
 class LeaveAdCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_leave'
     SYNOPSIS = 'Leave an Active Directory Domain'
@@ -199,37 +234,33 @@
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
         if args.username is not None and args.password is None:
             password = qumulo.lib.opts.read_password(prompt='Password: ')
         else:
             password = args.password
 
-        print(
-            ad.leave_ad(
-                rest_client.conninfo, rest_client.credentials, args.domain, args.username, password
-            )
-        )
+        print(rest_client.ad.leave_ad(args.domain, args.username, password))
 
 
 class CancelAdCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_cancel'
     SYNOPSIS = 'Cancel current AD join/leave operation and clear errors'
 
     @staticmethod
     def main(rest_client: RestClient, _args: argparse.Namespace) -> None:
-        print(ad.cancel_ad(rest_client.conninfo, rest_client.credentials))
+        print(rest_client.ad.cancel_ad())
 
 
 class GetAdvancedAdSettingsCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_get_advanced_settings'
     SYNOPSIS = 'Get advanced Active Directory settings'
 
     @staticmethod
     def main(rest_client: RestClient, _args: argparse.Namespace) -> None:
-        print(ad.get_advanced_settings(rest_client.conninfo, rest_client.credentials))
+        print(pretty_json(rest_client.ad.get_advanced_settings().data))
 
 
 class SetAdvancedAdSettingsCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_set_advanced_settings'
     SYNOPSIS = 'Modify advanced Active Directory settings'
     CHOICES = ('off', 'prefer', 'require')
 
@@ -267,17 +298,15 @@
         # At least one of the arguments must be specified.
         if all(v is None for k, v in settings.items()):
             raise ValueError('Must set at least one of --signing, --sealing, or --crypto.')
 
         # Get the original settings if any arguments are unspecified; we'll use an etag
         # to avoid race conditions.
         if any(v is None for k, v in settings.items()):
-            old_settings, etag = ad.get_advanced_settings(
-                rest_client.conninfo, rest_client.credentials
-            )
+            old_settings, etag = rest_client.ad.get_advanced_settings()
             settings['if_match'] = etag
 
             # Choose between the existing value for a parameter or the user-provided
             # value based on whether the user actually provided a value.
             def choose_value(name: str, value_choices: Sequence[str]) -> str:
                 choice = getattr(args, name)
                 if choice is None:
@@ -290,120 +319,120 @@
                 choice_index = SetAdvancedAdSettingsCommand.CHOICES.index(choice)
                 return value_choices[choice_index]
 
             settings['signing'] = choose_value('signing', ad.VALID_SIGNING_CHOICES)
             settings['sealing'] = choose_value('sealing', ad.VALID_SEALING_CHOICES)
             settings['crypto'] = choose_value('crypto', ad.VALID_ENCRYPTION_CHOICES)
 
-        print(ad.set_advanced_settings(rest_client.conninfo, rest_client.credentials, **settings))
+        print(pretty_json(rest_client.ad.set_advanced_settings(**settings)))
 
 
 class UidToSidsGetCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_uid_to_sids'
     SYNOPSIS = 'Get SIDs from UID'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         parser.add_argument(
             '-u', '--uid', help='Get the SIDs that correspond to this UID', required=True
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        print(ad.uid_to_sid_get(rest_client.conninfo, rest_client.credentials, args.uid))
+        print(pretty_json(rest_client.ad.uid_to_sid_get(args.uid)))
 
 
 class UsernameToSidsGetCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_username_to_sids'
     SYNOPSIS = 'Get SIDs from an AD username'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         parser.add_argument(
             '-u', '--username', help='Get the SIDs that correspond to this username', required=True
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        print(ad.username_to_sid_get(rest_client.conninfo, rest_client.credentials, args.username))
+        print(pretty_json(rest_client.ad.username_to_sid_get(args.username)))
 
 
 class NameToAccountCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_name_to_accounts'
     SYNOPSIS = 'Get all account info for a sAMAccountName'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         parser.add_argument(
             '-n', '--name', help='Get account info for this sAMAccountName', required=True
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        print(ad.name_to_ad_accounts(rest_client.conninfo, rest_client.credentials, args.name))
+        print(pretty_json(rest_client.ad.name_to_ad_accounts(args.name)))
 
 
 class SidToUidGetCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_sid_to_uid'
     SYNOPSIS = 'Get UID from SID'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         parser.add_argument(
             '-s', '--sid', help='Get the UID that corresponds to this SID', required=True
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        print(ad.sid_to_uid_get(rest_client.conninfo, rest_client.credentials, args.sid))
+        print(pretty_json(rest_client.ad.sid_to_uid_get(args.sid)))
 
 
 class SidToUsernameGetCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_sid_to_username'
     SYNOPSIS = 'Get AD username from SID'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         parser.add_argument(
             '-s', '--sid', help='Get the AD username that corresponds to this SID', required=True
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        print(ad.sid_to_username_get(rest_client.conninfo, rest_client.credentials, args.sid))
+        print(pretty_json(rest_client.ad.sid_to_username_get(args.sid)))
 
 
 class SidToGidGetCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_sid_to_gid'
     SYNOPSIS = 'Get GID from SID'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         parser.add_argument(
             '-s', '--sid', help='Get the GID that corresponds to this SID', required=True
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        print(ad.sid_to_gid_get(rest_client.conninfo, rest_client.credentials, args.sid))
+        print(pretty_json(rest_client.ad.sid_to_gid_get(args.sid)))
 
 
 class SidToAccountCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_sid_to_account'
     SYNOPSIS = 'Get all account info for a SID'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         parser.add_argument(
             '-s', '--sid', help='Get the GID that corresponds to this SID', required=True
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        print(ad.sid_to_ad_account(rest_client.conninfo, rest_client.credentials, args.sid))
+        print(pretty_json(rest_client.ad.sid_to_ad_account(args.sid)))
 
 
 class DNToAccountCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_distinguished_name_to_account'
     SYNOPSIS = 'Get all account info for a distinguished name'
 
     @staticmethod
@@ -413,34 +442,30 @@
             '--distinguished-name',
             help='Get the account with this DN (e.g. CN=user,DC=example,DC=com',
             required=True,
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        print(
-            ad.distinguished_name_to_ad_account(
-                rest_client.conninfo, rest_client.credentials, args.distinguished_name
-            )
-        )
+        print(pretty_json(rest_client.ad.distinguished_name_to_ad_account(args.distinguished_name)))
 
 
 class GidToSidGetCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_gid_to_sids'
     SYNOPSIS = 'Get SIDs from GID'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         parser.add_argument(
             '-g', '--gid', help='Get the SIDs that corresponds to this GID', required=True
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        print(ad.gid_to_sid_get(rest_client.conninfo, rest_client.credentials, args.gid))
+        print(pretty_json(rest_client.ad.gid_to_sid_get(args.gid)))
 
 
 class SidToExpandedGroupSidsGetCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_expand_groups'
     SYNOPSIS = (
         'Get the SIDs of all the groups that the given SID is a '
         'member of (including nested groups).'
@@ -453,12 +478,8 @@
             '--sid',
             help='Get the SIDS of all the groups this SID belongs (including all nested groups).',
             required=True,
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        print(
-            ad.sid_to_expanded_group_sids_get(
-                rest_client.conninfo, rest_client.credentials, args.sid
-            )
-        )
+        print(pretty_json(rest_client.ad.sid_to_expanded_group_sids_get(args.sid)))
```

## qumulo/commands/cluster.py

```diff
@@ -219,15 +219,15 @@
     SYNOPSIS = (
         'Delete SSL CA certificate. This certificate is used to '
         'authenticate connections to external LDAP servers.'
     )
 
     @staticmethod
     def main(rest_client: RestClient, _args: argparse.Namespace) -> None:
-        print(cluster.delete_ssl_ca_certificate(rest_client.conninfo, rest_client.credentials))
+        cluster.delete_ssl_ca_certificate(rest_client.conninfo, rest_client.credentials)
 
 
 class GetClusterSlotStatusCommand(qumulo.lib.opts.Subcommand):
     NAME = 'cluster_slots'
     SYNOPSIS = 'Get the cluster disk slots status'
 
     @staticmethod
```

## qumulo/commands/fs.py

```diff
@@ -38,15 +38,14 @@
 
 from tqdm import tqdm
 from typing_extensions import Protocol
 
 import qumulo.lib.opts
 import qumulo.lib.request as request
 import qumulo.lib.util as util
-import qumulo.rest.ad as ad
 import qumulo.rest.auth as auth
 import qumulo.rest.fs as fs
 
 from qumulo.commands.auth import format_expanded_id
 from qumulo.lib.acl_util import AceTranslator, AclEditor
 from qumulo.lib.auth import Credentials
 from qumulo.lib.identity_util import AD_DOMAIN, Identity
@@ -3048,30 +3047,27 @@
                 verbose_right=f'({verbose})',
             )
 
     aligner.write(outfile)
 
 
 def _expand_for_explain(
-    conninfo: request.Connection,
-    credentials: Optional[Credentials],
-    args: argparse.Namespace,
-    outfile: IO[str],
+    rest_client: RestClient, args: argparse.Namespace, outfile: IO[str]
 ) -> Tuple[List[Identity], List[Identity]]:
     res, _etag = auth.expand_identity(
-        conninfo,
-        credentials,
+        rest_client.conninfo,
+        rest_client.credentials,
         Identity(args.users[0]),
         list(map(Identity, args.users[1:])),
         list(map(Identity, args.groups)),
     )
     if res['type'] == auth.ID_TYPE_GROUP:
         raise ValueError('User ID is actually a group: {}'.format(Identity(res['id'])))
     if res['id']['domain'] == AD_DOMAIN:
-        ad_conf, _etag = ad.poll_ad(conninfo, credentials)
+        ad_conf = rest_client.ad.poll_ad()
         if not ad_conf['use_ad_posix_attributes']:
             outfile.write(
                 "Warning: Asked to explain an AD user's rights, but "
                 "AD Posix Attributes are not enabled.  The user's "
                 'group membership cannot be found automatically, and '
                 'must be specified manually.\n'
             )
@@ -3156,17 +3152,15 @@
         )
 
     @staticmethod
     def main(
         rest_client: RestClient, args: argparse.Namespace, outfile: IO[str] = sys.stdout
     ) -> None:
         if args.expand:
-            users, groups = _expand_for_explain(
-                rest_client.conninfo, rest_client.credentials, args, outfile
-            )
+            users, groups = _expand_for_explain(rest_client, args, outfile)
         elif not args.groups:
             sys.stderr.write('At least one group must be given with --no-expand\n')
             sys.exit(2)
         else:
             users = list(map(Identity, args.users))
             groups = list(map(Identity, args.groups))
 
@@ -3560,29 +3554,28 @@
 
         Available modes:
 
         DISABLED_ERROR
             Recursive change-notify requests return errors immediately.
 
         DISABLED_IGNORE
-            Recursive change notify requests will be accepted, but notifications will
-            only be sent for the top level directory being watched. In other words, it
-            will behave as if the recursive flag was not provided. This setting can be
-            used to improve compatibility with applications that request recursion but
-            don't actually depend on it. For some applications, however, this can cause
-            hangs or other unexpected behavior when recursion is needed in order to
-            function properly.
+            The system accepts recursive change-notify requests but sends notifications only for the
+            top directory that it watches. In other words, the system behaves as if the user doesn't
+            specify the recursive flag. You can use this setting to improve compatibility with
+            applications that request recursive behavior but don't actually depend on it. Important:
+            For scenarios that require recursive behavior, this setting can cause an application to
+            become unresponsive or exhibit other unexpected behavior.
 
         ENABLED
-            Real recursive change notify support. Notifications for all descendants of
-            the watched directory are pushed to the watcher. It can be quite expensive
-            in term of performance. For example, consider that a watch on the root of
-            the file system will receive a notification for every single change on the
-            entire cluster. ENABLED is the default mode unless configured otherwise
-            using this command.
+            The ENABLED option is the default mode, unless you set a different one. This option
+            provides full support for recursive change-notify requests. The system pushes
+            notifications for all descendants of the watched directory to the watcher. Important:
+            This configuration can affect system performance significantly. For example, watching
+            the root of the file system creates a notification for every change on the entire
+            cluster.
         """
     )
 
     @staticmethod
     def options(parser: ArgumentParser) -> None:
         parser.add_argument(
             '--recursive-mode',
```

## qumulo/commands/kerberos.py

```diff
@@ -63,15 +63,15 @@
 
 class KerberosDeleteKeytab(Subcommand):
     NAME = 'kerberos_delete_keytab'
     SYNOPSIS = 'Delete the Kerberos keytab'
 
     @staticmethod
     def main(rest_client: RestClient, _args: argparse.Namespace) -> None:
-        print(kerberos.delete_keytab(rest_client.conninfo, rest_client.credentials))
+        kerberos.delete_keytab(rest_client.conninfo, rest_client.credentials)
 
 
 #           _   _   _
 #  ___  ___| |_| |_(_)_ __   __ _ ___
 # / __|/ _ \ __| __| | '_ \ / _` / __|
 # \__ \  __/ |_| |_| | | | | (_| \__ \
 # |___/\___|\__|\__|_|_| |_|\__, |___/
```

## qumulo/commands/key_store.py

```diff
@@ -7,24 +7,24 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 
 import argparse
-import itertools
 import sys
 import textwrap
 
 from typing import Dict, List, Sequence
 
 import qumulo.lib.auth
 import qumulo.lib.opts
 import qumulo.rest.fs as fs
 
+from qumulo.lib.request import pretty_json
 from qumulo.lib.util import tabulate
 from qumulo.rest_client import RestClient
 
 
 def print_pretty_output(entries: List[Dict[str, str]]) -> None:
     print(
         tabulate(
@@ -150,44 +150,30 @@
 
 class GetKeyCommand(qumulo.lib.opts.Subcommand):
     NAME = 'fs_security_get_key'
     SYNOPSIS = 'Get information for a key in the file system key store.'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
-        key_ref_group = parser.add_mutually_exclusive_group(required=True)
-        key_ref_group.add_argument(
-            '-i',
-            '--id',
-            type=int,
-            help="""
-                The identifier of the key for which to show information. Important: You must
-                specify either the name or the identifier of the key.
-                """,
-        )
-        key_ref_group.add_argument(
-            '-n',
-            '--name',
-            type=str,
-            help="""
-                The name of the key for which to show information. Important: You must specify
-                either the name or the identifier of the key.
-                """,
+        parser.add_argument(
+            '-k',
+            '--key',
+            required=True,
+            help='The identifier or name of the key for which to show information.',
         )
         parser.add_argument(
             '--json',
             default=False,
             action='store_true',
             help='Print the output in JSON format. By default, the output is in a table.',
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        key_ref = args.name or str(args.id)
-        response = fs.security_get_key(rest_client.conninfo, rest_client.credentials, key_ref)
+        response = fs.security_get_key(rest_client.conninfo, rest_client.credentials, args.key)
         if args.json:
             print(response)
         else:
             print_pretty_output([response.data])
 
 
 class GetKeyUsageCommand(qumulo.lib.opts.Subcommand):
@@ -195,84 +181,55 @@
     SYNOPSIS = (
         'Show information about snapshot and snapshot policy usage for a key from the file system'
         ' key store.'
     )
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
-        key_ref_group = parser.add_mutually_exclusive_group(required=True)
-        key_ref_group.add_argument(
-            '-i',
-            '--id',
-            type=int,
-            help="""
-                The identifier of the key for which to show usage information.
-                Important: You must specify either the name or the identifier of the key.
-                """,
-        )
-        key_ref_group.add_argument(
-            '-n',
-            '--name',
-            type=str,
-            help="""
-                The name of the key for which to show usage information.
-                Important: You must specify either the name or the identifier of the key.
-                """,
+        parser.add_argument(
+            '-k',
+            '--key',
+            required=True,
+            help='The key identifier or name for which to show usage information.',
         )
         parser.add_argument(
             '--json',
             default=False,
             action='store_true',
             help='Print the output in JSON format. By default, the output is in a table.',
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        key_ref = args.name or str(args.id)
-        response = fs.security_get_key_usage(rest_client.conninfo, rest_client.credentials, key_ref)
+        key_ref = args.key
+
+        iterator = fs.security_get_key_usage(rest_client.conninfo, rest_client.credentials, key_ref)
+
         if args.json:
-            print(response)
+            usages = [u for r in iterator for u in r.data['usages']]
+            print(pretty_json(usages))
         else:
-            data = list(
-                itertools.zip_longest(
-                    response.data['snapshots'], response.data['snapshot_policies'], fillvalue=''
-                )
-            )
-            print(tabulate(data, ['snapshots', 'snapshot_policies']))
+            usages = [(u['type'], u['id']) for r in iterator for u in r.data['usages']]
+            usages.sort()
+            print(tabulate(usages, ['usage_type', 'usage_id']))
 
 
 class ModifyKeyCommand(qumulo.lib.opts.Subcommand):
     NAME = 'fs_security_modify_key'
     SYNOPSIS = textwrap.dedent(
         """\
         Modify the name or comment of a key in the file system key store.
         Enable or disable a key.
         """
     )
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
-        key_ref_group = parser.add_mutually_exclusive_group(required=True)
-        key_ref_group.add_argument(
-            '-i',
-            '--id',
-            type=int,
-            help="""
-                The identifier of the key to modify. Important: You must specify either the name or
-                the identifier of the key.
-                """,
-        )
-        key_ref_group.add_argument(
-            '-n',
-            '--name',
-            type=str,
-            help="""
-                The name of the key to modify. Important: You must specify either the name or the
-                identifier of the key.
-                """,
+        parser.add_argument(
+            '-k', '--key', required=True, help='The identifier or name of the key to modify.'
         )
 
         parser.add_argument('--new-name', type=str, help='The new name for the specified key.')
         parser.add_argument('--comment', type=str, help='The comment for the specified key.')
 
         disabled_group = parser.add_mutually_exclusive_group(required=False)
         disabled_group.set_defaults(disabled=None)
@@ -303,19 +260,18 @@
             default=False,
             action='store_true',
             help='Print the output in JSON format. By default, the output is in a table.',
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        key_ref = args.name or str(args.id)
         response = fs.security_modify_key(
             rest_client.conninfo,
             rest_client.credentials,
-            key_ref=key_ref,
+            key_ref=args.key,
             name=args.new_name,
             comment=args.comment,
             disabled=args.disabled,
         )
         if args.json:
             print(response)
         else:
@@ -359,40 +315,26 @@
         1. Use the qq fs_security_get_key_replace_challenge command to get the security challenge.
         2. Use the qq fs_security_replace_key command to replace the key. For more information, run the qq fs_security_replace_key -h command.
         """
     )
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
-        key_ref_group = parser.add_mutually_exclusive_group(required=True)
-        key_ref_group.add_argument(
-            '-i',
-            '--id',
-            type=int,
-            help="""
-                The identifier of the key for which to get a security challenge.
-                Important: You must specify either the name or the identifier of the key.
-                """,
-        )
-        key_ref_group.add_argument(
-            '-n',
-            '--name',
-            type=str,
-            help="""
-                The name of the key for which to get a security challenge.
-                Important: You must specify either the name or the identifier of the key.
-                """,
+        parser.add_argument(
+            '-k',
+            '--key',
+            required=True,
+            help='The identifier or name of the key for which to get a security challenge.',
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        key_ref = args.name or str(args.id)
         print(
             fs.security_get_key_replace_challenge(
-                rest_client.conninfo, rest_client.credentials, key_ref
+                rest_client.conninfo, rest_client.credentials, args.key
             )
         )
 
 
 class ReplaceKeyCommand(qumulo.lib.opts.Subcommand):
     NAME = 'fs_security_replace_key'
     SYNOPSIS = (
@@ -406,41 +348,28 @@
         Examples:
             - To replace a key by using the verification signature, perform the following steps:
             1. Run the qq fs_security_get_key_replace_challenge command and specify the identifier or name of the key to replace.
             The command outputs a challenge.
             2. Use the existing private key and replacement private key to sign the challenge.
             3. Generate two verification signatures.
             4. Run the qq fs_security_replace_key command and specify the two verification signatures, the replacement public key, and the identifier or name of the key to replace. For example:
-                qq fs_security_replace_key --id <key id> --replacement-public-key <Base64-encoded replacement public key contents> replacement-key-verification-signature <key replacement challenge signed by using the replacement private key and encoded in Base64 format> --old-key-verification-signature <key replacement challenge signed by using the old private key and encoded in Base64 format>
+                qq fs_security_replace_key --key <key id> --replacement-public-key <Base64-encoded replacement public key contents> replacement-key-verification-signature <key replacement challenge signed by using the replacement private key and encoded in Base64 format> --old-key-verification-signature <key replacement challenge signed by using the old private key and encoded in Base64 format>
 
             - To replace a key by using the private key files:
-            qq fs_security_replace_key --id <key id> --old-private-key-file <the path to the old private key> --replacement-private-key-file <the path to the replacement private key>
+            qq fs_security_replace_key --key <key id> --old-private-key-file <the path to the old private key> --replacement-private-key-file <the path to the replacement private key>
         """
     )
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
-        key_ref_group = parser.add_mutually_exclusive_group(required=True)
-        key_ref_group.add_argument(
-            '-i',
-            '--id',
-            type=int,
-            help="""
-                The identifier of the key to replace in the key store. Important: You must
-                specify either the name or the identifier of the key.
-                """,
-        )
-        key_ref_group.add_argument(
-            '-n',
-            '--name',
-            type=str,
-            help="""
-                The name of the key to replace in the key store. Important: You must specify
-                either the name or the identifier of the key.
-                """,
+        parser.add_argument(
+            '-k',
+            '--key',
+            required=True,
+            help='The identifier or name of the key to replace in the key store.',
         )
 
         parser.add_argument(
             '--old-private-key-file',
             type=argparse.FileType('r'),
             help='The ECDSA private key file that corresponds to the existing public key.',
         )
@@ -475,16 +404,14 @@
             default=False,
             action='store_true',
             help='Print the output in JSON format. By default, the output is in a table.',
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        key_ref = args.name or str(args.id)
-
         if not mutually_exclusive(
             (args.replacement_private_key_file,),
             (args.replacement_public_key, args.replacement_key_verification_signature),
         ):
             sys.stderr.write(
                 'Either the --replacement-private-key-file argument or both the ['
                 ' --replacement-public-key and --replacement-key-verification-signature ] arguments'
@@ -499,15 +426,15 @@
                 'Either the --old-private-key-file arguments or the'
                 ' --old-key-verification-signature arguments should be passed to this command.'
             )
             sys.exit(2)
 
         if args.old_private_key_file or args.replacement_private_key_file:
             challenge = fs.security_get_key_replace_challenge(
-                rest_client.conninfo, rest_client.credentials, key_ref
+                rest_client.conninfo, rest_client.credentials, args.key
             ).data['challenge']
         # These messages are necessary for differentiating the keys if they're password protected.
         if args.old_private_key_file:
             key = args.old_private_key_file.read()
             print('Signing challenge with old key.', file=sys.stderr)
             _, args.old_key_verification_signature = fs.get_verified_public_key(key, challenge)
 
@@ -518,15 +445,15 @@
                 args.replacement_public_key,
                 args.replacement_key_verification_signature,
             ) = fs.get_verified_public_key(key, challenge)
 
         response = fs.security_replace_key(
             rest_client.conninfo,
             rest_client.credentials,
-            key_ref,
+            args.key,
             replacement_key=args.replacement_public_key,
             old_key_verification_signature=args.old_key_verification_signature,
             replacement_key_verification_signature=args.replacement_key_verification_signature,
         )
         if args.json:
             print(response)
         else:
@@ -535,31 +462,17 @@
 
 class DeleteKeyCommand(qumulo.lib.opts.Subcommand):
     NAME = 'fs_security_delete_key'
     SYNOPSIS = 'Delete a key from the file system key store.'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
-        key_ref_group = parser.add_mutually_exclusive_group(required=True)
-        key_ref_group.add_argument(
-            '-i',
-            '--id',
-            type=int,
-            help="""
-                The identifier of the key to delete from the key store. Important: You must
-                specify either the name or the identifier of the key.
-                """,
-        )
-        key_ref_group.add_argument(
-            '-n',
-            '--name',
-            type=str,
-            help="""
-                The name of the key to delete from the key store. Important: You must specify
-                either the name or the identifier of the key.
-                """,
+        parser.add_argument(
+            '-k',
+            '--key',
+            required=True,
+            help='The identifier or name of the key to delete from the key store.',
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        key_ref = args.name or str(args.id)
-        fs.security_delete_key(rest_client.conninfo, rest_client.credentials, key_ref)
+        fs.security_delete_key(rest_client.conninfo, rest_client.credentials, args.key)
```

## qumulo/commands/multitenancy.py

```diff
@@ -12,14 +12,15 @@
 
 import argparse
 import textwrap
 
 import qumulo.lib.opts
 
 from qumulo.lib.request import pretty_json
+from qumulo.lib.util import tabulate
 from qumulo.rest.multitenancy import TenantConfigCreate, TenantConfigPatch
 from qumulo.rest_client import RestClient
 
 
 class CreateTenantCommand(qumulo.lib.opts.Subcommand):
     NAME = 'multitenancy_create_tenant'
     SYNOPSIS = 'Create a tenant'
@@ -184,16 +185,43 @@
 
 
 class ListTenantsCommand(qumulo.lib.opts.Subcommand):
     NAME = 'multitenancy_list_tenants'
     SYNOPSIS = 'List all tenants'
 
     @staticmethod
-    def main(rest_client: RestClient, _args: argparse.Namespace) -> None:
-        print(pretty_json([config.to_dict() for config in rest_client.multitenancy.list_tenants()]))
+    def options(parser: argparse.ArgumentParser) -> None:
+        parser.add_argument('-j', '--json', action='store_true', help='Output in JSON format')
+
+    @staticmethod
+    def main(rest_client: RestClient, args: argparse.Namespace) -> None:
+        tenants = rest_client.multitenancy.list_tenants()
+
+        if args.json:
+            print(pretty_json([config.to_dict() for config in tenants]))
+            return
+
+        columns = ['ID', 'Name', 'Network IDs', 'AD Domain ID', 'Enabled Services']
+        rows = []
+        for config in tenants:
+            service_names = []
+            if config.nfs_enabled:
+                service_names.append('NFS')
+            if config.replication_enabled:
+                service_names.append('Repl')
+            if config.rest_api_enabled:
+                service_names.append('REST')
+            if config.smb_enabled:
+                service_names.append('SMB')
+            if config.ssh_enabled:
+                service_names.append('SSH')
+            if config.web_ui_enabled:
+                service_names.append('WebUI')
+            rows.append([config.id, config.name, config.networks, config.ad_domain, service_names])
+        print(tabulate(rows, columns))
 
 
 class DeleteTenantCommand(qumulo.lib.opts.Subcommand):
     NAME = 'multitenancy_delete_tenant'
     SYNOPSIS = 'Delete a tenant'
     DESCRIPTION = textwrap.dedent(
         f"""
```

## qumulo/commands/replication.py

```diff
@@ -871,7 +871,61 @@
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: Namespace) -> None:
         replication.release_queued_snapshot(
             rest_client.conninfo, rest_client.credentials, args.relationship_id, args.snapshot_id
         )
+
+
+class ReplicationSetTargetRelationshipLock(qumulo.lib.opts.Subcommand):
+    NAME = 'replication_set_target_relationship_lock'
+    SYNOPSIS = (
+        'The key that locks policy-created snapshots for a target replication relationship. If set '
+        'to null, the system does not lock the snapshots that the specified target replication '
+        'relationship creates. Only snapshots created by a policy will be locked. Unless you '
+        'configure an expiration on the snapshot policy on the target cluster, the system does not '
+        'lock snapshots. If you reverse the relationship (switch the source and the target), the '
+        'new target does not use this lock key. To enable snapshot locking, you must configure the '
+        'new target separately. However, if you revert the reversed relationship (return the '
+        'source and target to their original assignments), the system preserves the original '
+        'target replication relationship lock key. Unless you reverse the relationship, you cannot '
+        'disable or delete a lock key while a target replication relationship uses the key. If you '
+        'disable or delete a lock key while the relationship is reversed and you then revert the '
+        'reversal, the original source-target relationship has no lock key until you configure a '
+        'new one.'
+    )
+
+    @staticmethod
+    def options(parser: ArgumentParser) -> None:
+        parser.add_argument(
+            '--relationship-id',
+            required=True,
+            help='The unique identifier of the target replication relationship.',
+        )
+        key_group = parser.add_mutually_exclusive_group(required=True)
+        key_group.add_argument(
+            '-k',
+            '--lock-key',
+            help=(
+                'The identifier or name of the lock key to associate with the specified '
+                'target replication relationship.'
+            ),
+        )
+        key_group.add_argument(
+            '--clear-lock-key',
+            action='store_true',
+            help='Disassociate the lock key from this target relationship',
+        )
+
+    @staticmethod
+    def main(rest_client: RestClient, args: Namespace) -> None:
+        lock_key = args.lock_key
+
+        replication.set_target_relationship_lock(
+            rest_client.conninfo, rest_client.credentials, args.relationship_id, lock_key
+        )
+
+        if lock_key is not None:
+            print(f'The lock key for target relationship {args.relationship_id} is {lock_key}.')
+        else:
+            print(f'The lock key for target relationship {args.relationship_id} has been cleared.')
```

## qumulo/commands/smb.py

```diff
@@ -212,16 +212,16 @@
 class SMBListShareCommand(qumulo.lib.opts.Subcommand):
     NAME = 'smb_list_share'
     SYNOPSIS = 'List a share'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         share = parser.add_mutually_exclusive_group(required=True)
-        share.add_argument('--id', type=int, default=None, help='ID of share to list')
-        share.add_argument('--name', type=str_decode, default=None, help='Name of share to list')
+        share.add_argument('--id', type=int, default=None, help='ID of share to list.')
+        share.add_argument('--name', type=str_decode, default=None, help='Name of share to list.')
         parser.add_argument(
             '--tenant-id',
             type=int,
             default=None,
             help='ID of the tenant to get the share from. Only used if using the --name argument.',
         )
 
@@ -269,18 +269,18 @@
     # These are all exclusive with read-only or no-access, but not with
     # all-access or each other, which argparse can't express:
     parser.add_argument(
         '--grant-read-access',
         type=str_decode,
         nargs='+',
         metavar='TRUSTEE',
-        help=(
-            'Grant read access to these trustees.  e.g. Everyone, '
-            'uid:1000, gid:1001, sid:S-1-5-2-3-4, or auth_id:500'
-        ),
+        help="""
+            Grant read access to the specified trustees. For example: Everyone, uid:1000, gid:1001,
+            sid:S-1-5-2-3-4, auth_id:500
+            """,
     )
     parser.add_argument(
         '--grant-read-write-access',
         type=str_decode,
         nargs='+',
         metavar='TRUSTEE',
         help='Grant read-write access to these trustees.',
@@ -342,22 +342,24 @@
 
 
 def _add_network_permissions_args(parser: argparse.ArgumentParser) -> None:
     net_group = parser.add_argument_group(
         'Network Permissions',
         textwrap.dedent(
             """
-            Options for controlling share access by client address. By default, all hosts are
-            permitted whatever rights are granted by both share and file permissions.
+            Provides options for controlling share access by using the client address. By default,
+            all hosts have the same rights which share and file permissions grant.
 
-            You can add multiple entries per Deny or Allow option by providing a space-separated
-            list of IP addresses or subnet ranges in CIDR notation. You can also use the wildcard
-            "*" (including quotes to prevent shell expansion) to represent all addresses.
+            It is possible to add multiple entries for each Deny and Allow option. To add entries,
+            enter a space-separated list of IP addresses or subnet ranges in CIDR notation. To
+            represent all available addresses, use the wildcard "*" including the quotation marks
+            (to prevent shell expansion).
 
-            To remove all entries and return to the default state apply --full-control-hosts "*".
+            To remove all entries and return to the default state, use the --full-control-hosts flag
+            with the "*" wildcard.
 
             Examples of acceptable entries:
 
             Single IP address: 172.16.33.10
             IP address ranges: 10.120.150.50-60 (.50 to .60 inclusive)
             Space-separated list of IP addresses: 10.0.10.10 10.0.10.20
             Subnet ranges in CIDR notation: 10.120.0.0/16
@@ -368,16 +370,16 @@
     net_group.add_argument(
         '--full-control-hosts',
         type=str_decode,
         nargs='+',
         default=None,
         metavar='IP/RANGE',
         help="""
-            Host addresses or subnet ranges which should be permitted all access that is also
-            granted by share permissions and file permissions.
+            The host addresses or subnet ranges for which access to to this share are not limited by
+            network permissions. Access may still be limited by share and file permissions.
             """,
     )
     net_group.add_argument(
         '--read-only-hosts',
         type=str_decode,
         nargs='+',
         default=None,
@@ -387,27 +389,27 @@
     net_group.add_argument(
         '--deny-hosts',
         type=str_decode,
         nargs='+',
         default=None,
         metavar='IP/RANGE',
         help="""
-            Host addresses or subnet ranges which should be denied access to this share, regardless
-            of other permissions. Applying this option by itself will result in all hosts being
-            denied access, so please ensure that you also add the appropriate --full-control-hosts
-            or --read-only-hosts entries.
+            The host addresses or subnet ranges for which access to the specified share is denied,
+            regardless of other permissions. Important: Because using this flag alone results in all
+            hosts being denied, use the correct --full-control-hosts or --read-only-hosts flags as
+            necessary.
             """,
     )
     net_group.add_argument(
         '--deny-all-hosts',
         default=False,
         action='store_true',
         help="""
-            Deny all access to this share. It is an error to apply this option in concert with any
-            of the other options.
+            Deny all access to this share. Important: To avoid configuration issues, do not apply
+            this flag alongside any others.
             """,
     )
 
 
 def _net_permissions_from_args(
     args: argparse.Namespace, default: Optional[List[Dict[str, Any]]]
 ) -> Optional[List[Dict[str, Any]]]:
@@ -440,65 +442,70 @@
 class SMBAddShareCommand(qumulo.lib.opts.Subcommand):
     NAME = 'smb_add_share'
     SYNOPSIS = 'Add a new SMB share'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         parser.add_argument(
-            '--tenant-id', type=int, default=None, help='ID of the tenant to add the share to'
+            '--tenant-id',
+            type=int,
+            default=None,
+            help='The ID of the tenant to which to add the share.',
         )
         parser.add_argument(
-            '--name', type=str_decode, default=None, required=True, help='Name of share'
+            '--name', type=str_decode, default=None, required=True, help='Name of share.'
         )
         parser.add_argument(
-            '--fs-path', type=str_decode, default=None, required=True, help='File system path'
+            '--fs-path', type=str_decode, default=None, required=True, help='File system path.'
         )
         parser.add_argument(
-            '--description', type=str_decode, default='', help='Description of this share'
+            '--description', type=str_decode, default='', help='Description of this share.'
         )
         parser.add_argument(
             '--access-based-enumeration-enabled',
             type=bool_from_string,
             default=False,
             metavar='{true,false}',
-            help='Enable Access-based Enumeration on this share',
+            help='Enable Access-Based Enumeration for this share.',
         )
         parser.add_argument(
             '--create-fs-path',
             action='store_true',
-            help='Creates the specified file system path if it does not exist',
+            help='Creates the specified file system path if the path does not exist already.',
         )
         parser.add_argument(
             '--default-file-create-mode',
             type=str_decode,
             default=None,
             help="""
-                Change default POSIX file create mode bits (octal) on this SMB share. This option
-                has no effect if an inheritable ACE in present in the permissions ACL.
+                Change the default POSIX file create mode bits (octal) for the specified SMB share.
+                These mode bits are applied to new files as they are created. Note: If an
+                inheritable ACE is present in the permissions ACL, this flag has no effect.
                 """,
         )
         parser.add_argument(
             '--default-directory-create-mode',
             type=str_decode,
             default=None,
             help="""
-                Change default POSIX directory create mode bits (octal) on this SMB share. This
-                option has no effect if an inheritable ACE in present in the permissions ACL.
+                Change the default POSIX directory create mode bits (octal) for the specified SMB
+                share. These mode bits are applied to new directories as they are created. Note: If
+                an inheritable ACE is present in the permissions ACL, this flag has no effect.
                 """,
         )
 
         parser.add_argument(
             '--require-encryption',
             type=bool_from_string,
             default=False,
             metavar='{true,false}',
-            help=(
-                'Require all traffic for this share to be encrypted. If true, clients without '
-                'encryption capabilities will not be able to connect.'
-            ),
+            help="""
+                Require encryption for all traffic for the specified share. When set to true,
+                clients without encryption capability cannot connect to this share.
+                """,
         )
         parser.add_argument(
             '--json', action='store_true', default=False, help='Print the raw JSON response.'
         )
 
         _add_initial_acl_args(parser)
         _add_network_permissions_args(parser)
@@ -543,23 +550,24 @@
 class SMBDeleteShareCommand(qumulo.lib.opts.Subcommand):
     NAME = 'smb_delete_share'
     SYNOPSIS = 'Delete a share'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         share = parser.add_mutually_exclusive_group(required=True)
-        share.add_argument('--id', type=int, default=None, help='ID of share to delete')
-        share.add_argument('--name', type=str_decode, default=None, help='Name of share to delete')
+        share.add_argument('--id', type=int, default=None, help='ID of share to delete.')
+        share.add_argument('--name', type=str_decode, default=None, help='Name of share to delete.')
         parser.add_argument(
             '--tenant-id',
             type=int,
             default=None,
-            help=(
-                'ID of the tenant to delete the share from. Only used if using the --name argument.'
-            ),
+            help="""
+                The ID of the tenant from which to delete the share. Use this flag only if you also
+                use the --name flag.
+                """,
         )
 
     @staticmethod
     def main(
         rest_client: RestClient,
         args: argparse.Namespace,
         outfile: IO[str] = sys.stdout,
@@ -584,61 +592,68 @@
 class SMBModShareCommand(qumulo.lib.opts.Subcommand):
     NAME = 'smb_mod_share'
     SYNOPSIS = 'Modify a share'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         share = parser.add_mutually_exclusive_group(required=True)
-        share.add_argument('--id', type=int, default=None, help='ID of share to modify')
-        share.add_argument('--name', type=str_decode, default=None, help='Name of share to modify')
+        share.add_argument('--id', type=int, default=None, help='The ID of the share to modify.')
+        share.add_argument(
+            '--name', type=str_decode, default=None, help='The name of the share to modify.'
+        )
         parser.add_argument(
             '--tenant-id',
             type=int,
             default=None,
             help='ID of the tenant the share is in. Only used if using the --name argument.',
         )
 
-        parser.add_argument('--new-name', default=None, help='Change SMB share name')
+        parser.add_argument('--new-name', default=None, help='Change SMB share name.')
         parser.add_argument(
-            '--new-tenant-id', type=int, default=None, help='Change tenant that share is in'
+            '--new-tenant-id',
+            type=int,
+            default=None,
+            help='Change the tenant that the share is in.',
         )
         parser.add_argument(
-            '--fs-path', type=str_decode, default=None, help='Change file system path'
+            '--fs-path', type=str_decode, default=None, help='Change file system path.'
         )
         parser.add_argument(
-            '--description', type=str_decode, default=None, help='Change description of this share'
+            '--description', type=str_decode, default=None, help='Change share description.'
         )
         parser.add_argument(
             '--access-based-enumeration-enabled',
             type=bool_from_string,
             default=None,
             metavar='{true,false}',
-            help='Change if Access-based Enumeration is enabled on this share',
+            help='Enable Access-Based Enumeration for this share.',
         )
         parser.add_argument(
             '--create-fs-path',
             action='store_true',
-            help='Creates the specified file system path if it does not exist',
+            help='Creates the specified file system path if the path does not exist already.',
         )
         parser.add_argument(
             '--default-file-create-mode',
             type=str_decode,
             default=None,
             help="""
-                Set default POSIX file create mode bits (octal) on this SMB share. This option has
-                no effect if an inheritable ACE in present in the permissions ACL.
+                Change the default POSIX file create mode bits (octal) for the specified SMB share.
+                These mode bits are applied to new files as they are created. Note: If an
+                inheritable ACE is present in the permissions ACL, this flag has no effect.
                 """,
         )
         parser.add_argument(
             '--default-directory-create-mode',
             type=str_decode,
             default=None,
             help="""
-                Set default POSIX directory create mode bits (octal) on this SMB share. This option
-                has no effect if an inheritable ACE in present in the permissions ACL.
+                Change the default POSIX directory create mode bits (octal) for the specified SMB
+                share. These mode bits are applied to new directories as they are created. Note: If
+                an inheritable ACE is present in the permissions ACL, this flag has no effect.
                 """,
         )
         parser.add_argument(
             '--require-encryption',
             type=bool_from_string,
             default=False,
             metavar='{true,false}',
@@ -819,23 +834,26 @@
 class SMBModShareAclCommand(qumulo.lib.opts.Subcommand):
     NAME = 'smb_mod_share_permissions'
     SYNOPSIS = "Modify a share's permissions"
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         share = parser.add_mutually_exclusive_group(required=True)
-        share.add_argument('--id', type=int, default=None, help='ID of share to modify')
-        share.add_argument('--name', type=str_decode, default=None, help='Name of share to modify')
+        share.add_argument('--id', type=int, default=None, help='The ID of the share to modify.')
+        share.add_argument(
+            '--name', type=str_decode, default=None, help='The name of the share to modify.'
+        )
         parser.add_argument(
             '--tenant-id',
             type=int,
             default=None,
-            help=(
-                'ID of the tenant to delete the share from. Only used if using the --name argument.'
-            ),
+            help="""
+                The ID of the tenant from which to delete the share. Use this flag only if you also
+                use the --name flag.
+                """,
         )
 
         parser.add_argument(
             '--json', action='store_true', default=False, help='Print the raw JSON response.'
         )
 
         subparsers = parser.add_subparsers(dest='command')
@@ -846,84 +864,85 @@
         )
         add_entry.set_defaults(command=do_add_entry)
         add_entry.add_argument(
             '-t',
             '--trustee',
             type=str_decode,
             required=True,
-            help=(
-                'The trustee to add.  e.g. Everyone, uid:1000, gid:1001, '
-                'sid:S-1-5-2-3-4, or auth_id:500'
-            ),
+            help="""
+                The trustee to add to the share permissions. For example: Everyone, uid:1000,
+                gid:1001, sid:S-1-5-2-3-4, auth_id:500
+                """,
         )
         add_entry.add_argument(
             '-y',
             '--type',
             type=str_decode,
             required=True,
             choices=TYPE_CHOICES,
-            help='Whether the trustee should be allowed or denied the given rights',
+            help='Allow or deny the trustee the specified rights.',
         )
         add_entry.add_argument(
             '-r',
             '--rights',
             type=str_decode,
             nargs='+',
             required=True,
             metavar='RIGHT',
             choices=RIGHT_CHOICES,
-            help='The rights that should be allowed or denied.  Choices: '
+            help='The rights to allow or deny to the trustee. Available rights: '
             + ', '.join(RIGHT_CHOICES),
         )
         add_entry.add_argument(
             '-d',
             '--dry-run',
             action='store_true',
             default=False,
             help='Do nothing; display what the result of the change would be.',
         )
 
         remove_entry = subparsers.add_parser(
-            'remove_entry', help="Remove an entry from the share's permissions"
+            'remove_entry', help="Remove an entry from the share's permissions."
         )
         remove_entry.set_defaults(command=do_remove_entry)
         remove_entry.add_argument(
             '-p', '--position', type=int, help='The position of the entry to remove.'
         )
         remove_entry.add_argument(
             '-t',
             '--trustee',
             type=str_decode,
-            help=(
-                'Remove an entry with this trustee.  e.g. Everyone, '
-                'uid:1000, gid:1001, sid:S-1-5-2-3-4, or auth_id:500'
-            ),
+            help="""
+                Remove the entry that includes this trustee from the share's permissions. For
+                example: Everyone, uid:1000, gid:1001, sid:S-1-5-2-3-4, auth_id:500
+                """,
         )
         remove_entry.add_argument(
             '-y',
             '--type',
             type=str_decode,
             choices=TYPE_CHOICES,
-            help='Remove an entry of this type',
+            help='Remove an entry of the specified type.',
         )
         remove_entry.add_argument(
             '-r',
             '--rights',
             type=str_decode,
             nargs='+',
             metavar='RIGHT',
             choices=RIGHT_CHOICES,
-            help='Remove an entry with these rights.  Choices: ' + ', '.join(RIGHT_CHOICES),
+            help='Remove an entry with the specified rights. Available rights: '
+            + ', '.join(RIGHT_CHOICES),
         )
         remove_entry.add_argument(
             '-a',
             '--all-matching',
             action='store_true',
             default=False,
-            help='If multiple entries match the arguments, remove all of them',
+            help='If multiple entries match the specified arguments, remove all of the entries.',
         )
         remove_entry.add_argument(
             '-d',
             '--dry-run',
             action='store_true',
             default=False,
             help='Do nothing; display what the result of the change would be.',
@@ -935,29 +954,33 @@
         modify_entry.set_defaults(command=do_modify_entry)
         modify_entry.add_argument(
             '-p', '--position', type=int, help='The position of the entry to modify.'
         )
         modify_entry.add_argument(
             '--old-trustee',
             type=str_decode,
-            help=(
-                'Modify an entry with this trustee.  e.g. Everyone, '
-                'uid:1000, gid:1001, sid:S-1-5-2-3-4, or auth_id:500'
-            ),
+            help="""
+                Modify an entry with the specified trustee. For example: Everyone, uid:1000,
+                gid:1001, sid:S-1-5-2-3-4, auth_id:500
+                """,
         )
         modify_entry.add_argument(
-            '--old-type', type=str_decode, choices=TYPE_CHOICES, help='Modify an entry of this type'
+            '--old-type',
+            type=str_decode,
+            choices=TYPE_CHOICES,
+            help='Modify an entry of the specified type.',
         )
         modify_entry.add_argument(
             '--old-rights',
             type=str_decode,
             nargs='+',
             metavar='RIGHT',
             choices=RIGHT_CHOICES,
-            help='Modify an entry with these rights.  Choices: ' + ', '.join(RIGHT_CHOICES),
+            help='Modify an entry with the specified rights. Available rights: '
+            + ', '.join(RIGHT_CHOICES),
         )
         modify_entry.add_argument(
             '--new-trustee',
             type=str_decode,
             help=(
                 'Set the entry to have this trustee.  e.g. Everyone, '
                 'uid:1000, gid:1001, sid:S-1-5-2-3-4, or auth_id:500'
@@ -968,38 +991,38 @@
         )
         modify_entry.add_argument(
             '--new-rights',
             type=str_decode,
             nargs='+',
             metavar='RIGHT',
             choices=RIGHT_CHOICES,
-            help='Set the rights of the entry.  Choices: ' + ', '.join(RIGHT_CHOICES),
+            help='Set the rights for the specified entry. Available rights: '
+            + ', '.join(RIGHT_CHOICES),
         )
         modify_entry.add_argument(
             '-a',
             '--all-matching',
             action='store_true',
             default=False,
-            help='If multiple entries match the arguments, modify all of them',
+            help='If multiple entries match the specified arguments, modify all of the entries.',
         )
         modify_entry.add_argument(
             '-d',
             '--dry-run',
             action='store_true',
             default=False,
             help='Do nothing; display what the result of the change would be.',
         )
 
         replace = subparsers.add_parser(
             'replace',
-            help=(
-                'Replace any existing share permissions with new permissions. '
-                'If no new permissions are specified, all access will be '
-                'denied.'
-            ),
+            help="""
+                Replace any existing share permissions with specified permissions. If you don't
+                specify new permissions, all access is denied.
+                """,
         )
         replace.add_argument(
             '-d',
             '--dry-run',
             action='store_true',
             default=False,
             help='Do nothing; display what the result of the change would be.',
@@ -1075,81 +1098,77 @@
         '-d',
         '--supported-dialects',
         action=DialectAction,
         type=lambda s: s.upper(),
         choices=available_dialects + ['ALL', ''],
         metavar=('dialect_1', 'dialect_2'),
         nargs='+',
-        help=(
-            'Space separated set of SMB dialects to allow clients to negotiate. '
-            'Specify no dialects (-d "") to turn off SMB. '
-            f'Choose from the following: {pretty_available_dialects}, or use -d ALL to '
-            'allow all supported dialects.'
-        ),
+        help=f"""
+            Specify a space-separated list of SMB dialects that clients are permitted to negotiate.
+            To disable SMB, specify -d "". Available dialects: {pretty_available_dialects}.
+            Alternatively, use -d ALL to allow all supported dialects.
+            """,
     )
 
     parser.add_argument(
         '--hide-shares-from-unauthorized-hosts',
         type=bool_from_string,
         metavar='{true,false}',
         default=None,
-        help=(
-            'Share listing will omit shares that the requesting host is '
-            'not authorized to connect to.'
-        ),
+        help="""
+            Configure share listing to omit shares to which the requesting host isn't authorized to
+            connect.
+            """,
     )
     parser.add_argument(
         '--hide-shares-from-unauthorized-users',
         type=bool_from_string,
         metavar='{true,false}',
         default=None,
-        help=(
-            'Share listing will omit shares that the requesting user is '
-            'not authorized to connect to. Caution: clients that are not '
-            'configured for passwordless authentication typically list '
-            'shares using guest privileges; this option will typically '
-            'hide all shares from such clients.'
-        ),
+        help="""
+            Configure share listing to omit shares to which the requesting user isn't authorized to
+            connect. Important: Clients which don't have passwordless authentication typically list
+            shares by using guest privileges. This flag typically hides all shares from this client
+            type.
+            """,
     )
     parser.add_argument(
         '--snapshot-directory-mode',
         choices=['visible', 'hidden', 'disabled'],
         default=None,
-        help=(
-            'If "visible", a special .snapshot directory will appear in '
-            'directory listings at the root of shares, and be accessible '
-            'by name in any directory.  If "hidden", the .snapshot '
-            'directory will not appear in directory listings, but will '
-            'still be accessible by name.  If "disabled", .snapshot '
-            'directories will not be accessible, and snapshots will only '
-            'be available via e.g. the Restore Previous Versions dialog '
-            'on Windows.'
-        ),
+        help="""
+            When you set this flag to visible, the .snapshot directory appears at the root of shares
+            during directory listing operations. The .snapshot directory is also accessible by name
+            in any directory. When you set this flag to hidden, .snapshot directories do not appear
+            in directory listings but remains accessible by name. When you set this flag to
+            disabled, .snapshot directories are not accessible and snapshots are available only
+            through the Restore Previous Versions dialog box on Windows.
+            """,
     )
     parser.add_argument(
         '--bypass-traverse-checking',
         type=bool_from_string,
         metavar='{true,false}',
         default=None,
-        help=(
-            'Bypass traverse checking for all users and all directories. In '
-            'other words, a user trying to access /foo/bar who has permissions to '
-            'bar but no permissions to foo can still access bar. Users still need '
-            'permissions on foo to see the contents of that directory.'
-        ),
+        help="""
+            Enables bypass traverse checking for all users and directories. For example, a user who
+            tries to access directory /x/y and has permissions to the /x directory but not to the
+            /x/y directory can access the /x/y directory. A user still requires permissions to the
+            /x directory to view its contents.
+            """,
     )
     parser.add_argument(
         '--signing-required',
         type=bool_from_string,
         metavar='{true,false}',
         default=None,
-        help=(
-            'Require that messages must be signed if the user is not guest. '
-            'Applies to all SMB shares.'
-        ),
+        help="""
+            If the user is not a guest, require all messages to be signed. This flag applies to all
+            SMB shares.
+            """,
     )
 
 
 def extract_modify_settings_args(args: argparse.Namespace) -> Dict[str, Any]:
     settings_json = {}
 
     if args.encryption_mode is not None:
@@ -1202,30 +1221,30 @@
 
 class SMBListFileHandlesCommand(qumulo.lib.opts.Subcommand):
     NAME = 'smb_list_file_handles'
     SYNOPSIS = 'List SMB open file handles'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
-        parser.add_argument('--page-size', type=int, help='Max files to return per request')
+        parser.add_argument('--page-size', type=int, help='Max files to return per request.')
         parser.add_argument(
             '--file-number',
             type=int,
             default=None,
             required=False,
-            help=(
-                'Limits results to the specified file, as returned from a command '
-                'like fs_file_get_attr or fs_read_dir.'
-            ),
+            help="""
+                Limits results to the specified file, as returned from a command like
+                fs_file_get_attr or fs_read_dir.
+                """,
         )
         parser.add_argument(
             '-p',
             '--resolve-paths',
             action='store_true',
-            help='Returns the primary path of the opened file',
+            help='Returns the primary path of the opened file.',
         )
         parser.add_argument('--path', help='Path to file', type=str_decode)
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
         if args.page_size is not None and args.page_size < 1:
             raise ValueError('Page size must be greater than 0')
@@ -1246,32 +1265,31 @@
             resolve_paths=resolve_paths,
         ):
             print(f)
 
 
 class SMBCloseFileHandleCommand(qumulo.lib.opts.Subcommand):
     NAME = 'smb_close_file_handle'
-    SYNOPSIS = 'Force close a specified SMB file handle'
+    SYNOPSIS = 'Force-close the specified SMB file handle'
     DESCRIPTION = SYNOPSIS + textwrap.dedent(
         """\n
-        NOTE: This will prevent the client from sending any new requests for
-        this file handle, releasing all locks and forcing the client to reopen
-        the file. The client will not be given the opportunity to flush cached
-        writes. Proceed with caution!
-    """
+        Important: This command prevents the client from sending any new requests for this file
+        handle, releases all locks, and forces the client to reopen the file. The system will not
+        give the client an opportunity to flush cached writes.
+        """
     )
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         parser.add_argument(
             '--location',
             type=str,
             default=None,
             required=True,
-            help='The location of the file handle to close as returned from smb_list_file_handles',
+            help='The location of the file handle to close as returned from smb_list_file_handles.',
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
         if type(args.location) is not str:
             raise ValueError('location must be a string')
         message = (
@@ -1291,21 +1309,20 @@
     def options(parser: argparse.ArgumentParser) -> None:
         parser.add_argument('--page-size', type=int, help='Max sessions to return per request')
         parser.add_argument(
             '--identity',
             type=str,
             default=None,
             required=False,
-            help=(
-                "List only sessions matching this user's identity in the "
-                'form of: [1] A name or a SID optionally qualified with a '
-                'domain prefix (e.g "local:name", "S-1-1-0", "name", '
-                '"world:Everyone", "ldap_user:name", or "ad:name"), or [2] An '
-                'ID type (e.g. "uid:1001", "auth_id:513", "SID:S-1-1-0").'
-            ),
+            help="""
+                List only the sessions that match the specified user's identity in one of the
+                following forms: a name or a SID optionally qualified with a domain prefix (for
+                example, "local:name", "S-1-1-0", "name", "world:Everyone", "ldap_user:name",
+                "ad:name"), or an ID type (for example, "uid:1001", "auth_id:513", "SID:S-1-1-0").
+                """,
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
         if args.page_size is not None and args.page_size < 1:
             raise ValueError('Page size must be greater than 0')
         for f in smb.list_smb_sessions(
@@ -1318,53 +1335,51 @@
 
 
 class SMBCloseSessionsCommand(qumulo.lib.opts.Subcommand):
     NAME = 'smb_close_sessions'
     SYNOPSIS = 'Force close SMB sessions matching one or more of a set of filters.'
     DESCRIPTION = SYNOPSIS + textwrap.dedent(
         """\n
-        NOTE: This will prevent the client from sending any new requests for
-        this session, releasing all locks and forcing the client to
-        reauthenticate. The client will not be given the opportunity to flush
-        cached writes. Proceed with caution!
-    """
+        Important: This flag prevents the client from sending any new requests for this session,
+        releases all locks, and forces the client to reauthenticate. The system does not give the
+        client an opportunity to flush cached writes.
+        """
     )
     BATCH_SIZE = 100
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         parser.add_argument(
             '--identity',
             type=str,
             default=None,
             required=False,
-            help=(
-                "Close only sessions matching this user's identity in the "
-                'form of: [1] A name or a SID optionally qualified with a '
-                'domain prefix (e.g "local:name", "S-1-1-0", "name", '
-                '"world:Everyone", "ldap_user:name", or "ad:name"), or [2] An '
-                'ID type (e.g. "uid:1001", "auth_id:513", "SID:S-1-1-0").'
-            ),
+            help="""
+                Close only the sessions that match the specified user's identity in one of the
+                following forms: a name or a SID optionally qualified with a domain prefix (for
+                example, "local:name", "S-1-1-0", "name", "world:Everyone", "ldap_user:name",
+                "ad:name"), or an ID type (for example, "uid:1001", "auth_id:513", "SID:S-1-1-0").
+                """,
         )
         parser.add_argument(
             '--location',
             type=str,
             default=None,
             required=False,
-            help=(
-                'Close only the session with this location, as provided by '
-                'an enumeration from smb_list_sessions.'
-            ),
+            help="""
+                Use the list of sessions from the smb_list_sessions command to close only the
+                session with the specified location.
+                """,
         )
         parser.add_argument(
             '--ip',
             type=str,
             default=None,
             required=False,
-            help='Close only sessions originating from this ip.',
+            help='Close only the sessions that originate from the specified IP address.',
         )
 
     @staticmethod
     def main(
         rest_client: RestClient,
         args: argparse.Namespace,
         smb_mod: Any = smb,
```

## qumulo/commands/snapshot.py

```diff
@@ -6,15 +6,14 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 
-
 import re
 import textwrap
 
 from argparse import ArgumentDefaultsHelpFormatter, ArgumentParser, FileType, Namespace, SUPPRESS
 from datetime import datetime
 from enum import Enum
 from typing import Any, Dict, Mapping, Optional, Sequence, Tuple
@@ -388,15 +387,15 @@
             args.name,
             get_schedule_info(
                 get_schedule_hourly_or_less(args), args.time_to_live if args.time_to_live else ''
             ),
             args.snapshot_name_template,
             args.file_id,
             args.enabled,
-            lock_key_ref=lock_key_ref_from_args(args),
+            lock_key_ref=args.lock_key,
         )
     )
 
 
 def get_schedule_daily(args: Namespace) -> Mapping[str, object]:
     try:
         at_time_of_day = datetime.strptime(args.at, '%H:%M')
@@ -422,15 +421,15 @@
             args.name,
             get_schedule_info(
                 get_schedule_daily(args), args.time_to_live if args.time_to_live else ''
             ),
             args.snapshot_name_template,
             args.file_id,
             args.enabled,
-            lock_key_ref=lock_key_ref_from_args(args),
+            lock_key_ref=args.lock_key,
         )
     )
 
 
 def get_schedule_monthly(args: Namespace) -> Mapping[str, object]:
     try:
         at_time_of_day = datetime.strptime(args.at, '%H:%M')
@@ -456,15 +455,15 @@
             args.name,
             get_schedule_info(
                 get_schedule_monthly(args), args.time_to_live if args.time_to_live else ''
             ),
             args.snapshot_name_template,
             args.file_id,
             args.enabled,
-            lock_key_ref=lock_key_ref_from_args(args),
+            lock_key_ref=args.lock_key,
         )
     )
 
 
 def add_hourly_specific_args(hourly_parser: ArgumentParser) -> None:
     hourly_parser.add_argument(
         '-s',
@@ -608,30 +607,20 @@
             dest='enabled',
             action='store_false',
             default=SUPPRESS,
             help='Create but do not enable policy.',
         )
         parser.set_defaults(enabled=None)
 
-        key_ref_group = common_parser.add_mutually_exclusive_group(required=False)
-        key_ref_group.add_argument(
+        common_parser.add_argument(
             '-k',
-            '--lock-key-id',
-            type=int,
+            '--lock-key',
             help=(
-                'The identifier of the key in the file system key store that protects all snapshots'
-                ' created with this policy in the future.'
-            ),
-        )
-        key_ref_group.add_argument(
-            '--lock-key-name',
-            type=str,
-            help=(
-                'The name of the key in the file system key store that protects all snapshots'
-                ' created with this policy in the future.'
+                'The identifier or name of the key in the file system key store that protects all'
+                ' snapshots created with this policy in the future.'
             ),
         )
 
         common_parser.add_argument(
             '-f',
             '--force',
             action='store_true',
@@ -662,35 +651,31 @@
             formatter_class=ArgumentDefaultsHelpFormatter,
         )
         add_monthly_specific_args(monthly_parser)
         monthly_parser.set_defaults(command=create_monthly)
 
     @staticmethod
     def main(rest_client: RestClient, args: Namespace) -> None:
-        lock_key_ref = lock_key_ref_from_args(args)
-
         if args.path:
             attr = fs.get_file_attr(rest_client.conninfo, rest_client.credentials, path=args.path)
             args.file_id = attr.lookup('file_number')
 
         if (
-            not (lock_key_ref and lock_key_ref.ref is not None)
+            args.lock_key is None
             or args.force
             or locking_prompt_confirmed(
-                rest_client, lock_key_ref.ref, LockingObject.SNAPSHOT_POLICY, args.name
+                rest_client, args.lock_key, LockingObject.SNAPSHOT_POLICY, args.name
             )
         ):
             args.command(rest_client.conninfo, rest_client.credentials, args)
 
 
-def lock_key_ref_from_args(args: Namespace) -> Optional[snapshot.LockKeyRef]:
-    if args.lock_key_id is not None:
-        return snapshot.LockKeyRef(str(args.lock_key_id))
-    elif args.lock_key_name is not None:
-        return snapshot.LockKeyRef(args.lock_key_name)
+def lock_key_ref_from_modify_args(args: Namespace) -> Optional[snapshot.LockKeyRef]:
+    if args.lock_key is not None:
+        return snapshot.LockKeyRef(args.lock_key)
     elif 'clear_lock_key' in args and args.clear_lock_key:
         return snapshot.LockKeyRef(None)
     else:
         return None
 
 
 def modify_non_schedule_fields(
@@ -701,15 +686,15 @@
             conninfo,
             credentials,
             args.id,
             name=args.name,
             snapshot_name_template=args.snapshot_name_template,
             schedule_info=get_schedule_info(None, args.time_to_live),
             enabled=args.enabled,
-            lock_key_ref=lock_key_ref_from_args(args),
+            lock_key_ref=lock_key_ref_from_modify_args(args),
         )
     )
 
 
 def modify_hourly(
     conninfo: request.Connection, credentials: Optional[Credentials], args: Namespace
 ) -> None:
@@ -718,15 +703,15 @@
             conninfo,
             credentials,
             args.id,
             name=args.name,
             snapshot_name_template=args.snapshot_name_template,
             schedule_info=get_schedule_info(get_schedule_hourly_or_less(args), args.time_to_live),
             enabled=args.enabled,
-            lock_key_ref=lock_key_ref_from_args(args),
+            lock_key_ref=lock_key_ref_from_modify_args(args),
         )
     )
 
 
 def modify_daily(
     conninfo: request.Connection, credentials: Optional[Credentials], args: Namespace
 ) -> None:
@@ -735,15 +720,15 @@
             conninfo,
             credentials,
             args.id,
             name=args.name,
             snapshot_name_template=args.snapshot_name_template,
             schedule_info=get_schedule_info(get_schedule_daily(args), args.time_to_live),
             enabled=args.enabled,
-            lock_key_ref=lock_key_ref_from_args(args),
+            lock_key_ref=lock_key_ref_from_modify_args(args),
         )
     )
 
 
 def modify_monthly(
     conninfo: request.Connection, credentials: Optional[Credentials], args: Namespace
 ) -> None:
@@ -752,15 +737,15 @@
             conninfo,
             credentials,
             args.id,
             name=args.name,
             snapshot_name_template=args.snapshot_name_template,
             schedule_info=get_schedule_info(get_schedule_monthly(args), args.time_to_live),
             enabled=args.enabled,
-            lock_key_ref=lock_key_ref_from_args(args),
+            lock_key_ref=lock_key_ref_from_modify_args(args),
         )
     )
 
 
 class ModifyPolicyCommand(qumulo.lib.opts.Subcommand):
     NAME = 'snapshot_modify_policy'
 
@@ -814,33 +799,22 @@
             default=SUPPRESS,
             help='Disable the specified policy.',
         )
         parser.set_defaults(enabled=None)
 
         # Set and clear the lock key.
         lock_key_group = common_parser.add_mutually_exclusive_group(required=False)
-        lock_key_ref_group = lock_key_group.add_mutually_exclusive_group(required=False)
-        lock_key_ref_group.add_argument(
+        lock_key_group.add_argument(
             '-k',
-            '--lock-key-id',
-            type=int,
-            help=(
-                'The identifier of the key in the file system key store that protects all snapshots'
-                ' created with this policy in the future.'
-            ),
-        )
-        lock_key_ref_group.add_argument(
-            '--lock-key-name',
-            type=str,
+            '--lock-key',
             help=(
-                'The name of the key in the file system key store that protects all snapshots'
-                ' created with this policy in the future.'
+                'The identifier or name of the key in the file system key store that protects all'
+                ' snapshots created with this policy in the future.'
             ),
         )
-
         lock_key_group.add_argument(
             '--clear-lock-key',
             action='store_true',
             default=SUPPRESS,
             help=(
                 'Remove the key from the specified policy. All snapshots created with this policy'
                 ' in the future will no longer be protected.'
@@ -888,33 +862,38 @@
 
     @staticmethod
     def main(rest_client: RestClient, args: Namespace) -> None:
         def snapshot_policy_is_locked() -> bool:
             response = snapshot.get_policy(rest_client.conninfo, rest_client.credentials, args.id)
             return response.data['lock_key_ref'] is not None
 
-        lock_key_ref = lock_key_ref_from_args(args)
+        def locking_preflight_checks() -> bool:
+            lock_key_ref = lock_key_ref_from_modify_args(args)
+            changing_lock_key = lock_key_ref is not None and lock_key_ref.ref is not None
+            changing_expiry_on_locked_policy = args.time_to_live and snapshot_policy_is_locked()
+
+            if changing_lock_key:
+                # Hack to get around stupid pylint
+                assert lock_key_ref is not None and lock_key_ref.ref is not None
+                if not locking_prompt_confirmed(
+                    rest_client, lock_key_ref.ref, LockingObject.SNAPSHOT_POLICY, args.id
+                ):
+                    return False
 
-        # This giant boolean says: if we're forced, or we're not in a locking scenario, unless the
-        # user has specifically OK'd said locking scenario through locking_prompt_confirmed and
-        # modify_expiration_when_locked_prompt_confirmed.
-        if args.force or not (
-            lock_key_ref
-            and lock_key_ref.ref
-            and not locking_prompt_confirmed(
-                rest_client, lock_key_ref.ref, LockingObject.SNAPSHOT_POLICY, args.id
-            )
-            or (
-                args.time_to_live
-                and snapshot_policy_is_locked()
+            if (
+                changing_expiry_on_locked_policy
                 and not modify_expiration_when_locked_prompt_confirmed(
                     LockingObject.SNAPSHOT_POLICY, args.id
                 )
-            )
-        ):
+            ):
+                return False
+
+            return True
+
+        if args.force or locking_preflight_checks():
             args.command(rest_client.conninfo, rest_client.credentials, args)
 
 
 class ListAllPoliciesCommand(qumulo.lib.opts.Subcommand):
     NAME = 'snapshot_list_policies'
 
     SYNOPSIS = 'List all policies'
@@ -1173,45 +1152,34 @@
         parser.add_argument(
             '-f',
             '--force',
             action='store_true',
             help='Do not prompt for confirmation. The default setting is "false".',
         )
 
-        lock_key_ref_group = parser.add_mutually_exclusive_group(required=True)
-        lock_key_ref_group.add_argument(
+        parser.add_argument(
             '-k',
-            '--lock-key-id',
-            type=int,
-            help=(
-                'The identifier of the key in the file system key store that protects the snapshot.'
-                ' Important: You must specify either the name or the identifier of the key.'
-            ),
-        )
-        lock_key_ref_group.add_argument(
-            '-n',
-            '--lock-key-name',
-            type=str,
+            '--lock-key',
+            required=True,
             help=(
-                'The name of the key in the file system key store that protects the snapshot.'
-                ' Important: You must specify either the name or the identifier of the key.'
+                'The identifier or name of the key in the file system key store that protects the'
+                ' snapshot. Important: You must specify either the name or the identifier of the'
+                ' key.'
             ),
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: Namespace) -> None:
-        lock_key_ref = args.lock_key_name or str(args.lock_key_id)
         if args.force or locking_prompt_confirmed(
-            rest_client, lock_key_ref, LockingObject.SNAPSHOT, args.id
+            rest_client, args.lock_key, LockingObject.SNAPSHOT, args.id
         ):
-            print(
-                snapshot.lock_snapshot(
-                    rest_client.conninfo, rest_client.credentials, args.id, lock_key_ref
-                )
+            snapshot.lock_snapshot(
+                rest_client.conninfo, rest_client.credentials, args.id, args.lock_key
             )
+            print(f'Snapshot {args.id} is locked with lock key {args.lock_key}.')
 
 
 class GetUnlockChallengeSnapshotCommand(qumulo.lib.opts.Subcommand):
     NAME = 'snapshot_get_unlock_challenge'
     SYNOPSIS = 'Get a security challenge for unlocking a snapshot.'
     DESCRIPTION = textwrap.dedent(
         f"""
@@ -1289,12 +1257,13 @@
     @staticmethod
     def main(rest_client: RestClient, args: Namespace) -> None:
         if args.private_key_file:
             challenge = snapshot.get_unlock_challenge_snapshot(
                 rest_client.conninfo, rest_client.credentials, args.id
             ).data['challenge']
             _, args.signature = fs.get_verified_public_key(args.private_key_file.read(), challenge)
-        print(
-            snapshot.unlock_snapshot(
-                rest_client.conninfo, rest_client.credentials, args.id, args.signature
-            )
+
+        snapshot.unlock_snapshot(
+            rest_client.conninfo, rest_client.credentials, args.id, args.signature
         )
+
+        print(f'Snapshot {args.id} is unlocked.')
```

## qumulo/commands/upgrade.py

```diff
@@ -235,14 +235,23 @@
         if disconnect_error_allowed:
             print('Upgrade committed')
             print_reboot_message(status)
         else:
             raise
 
 
+class UpgradeBlockedCommand(Subcommand):
+    NAME = 'upgrade_blocked'
+    SYNOPSIS = 'Get information on whether and for what reason an upgrade is blocked'
+
+    @staticmethod
+    def main(rest_client: RestClient, _args: argparse.Namespace) -> None:
+        print(upgrade_v2.blocked(rest_client.conninfo, rest_client.credentials))
+
+
 class UpgradeVerifyImageCommand(Subcommand):
     NAME = 'upgrade_verify_image'
     SYNOPSIS = 'Verify an image path for upgrade'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         parser.add_argument(
```

## qumulo/lib/opts.py

```diff
@@ -14,14 +14,15 @@
 # XXX: Please add types to the functions in this file. Static type checking in
 # Python prevents bugs!
 # mypy: ignore-errors
 
 
 import argparse
 import getpass
+import operator
 import sys
 import textwrap
 
 from typing import cast, TextIO, Type
 
 from typing_extensions import Protocol
 
@@ -122,15 +123,15 @@
         # suggestions based on substring matches, use edit distance to give the
         # user helpful-ish suggestions
         if not choices:
             edit_distances = []
             for choice in remaining:
                 dist = util.edit_distance(choice, self._last_contains_check)
                 edit_distances.append((dist, choice))
-            edit_distances.sort(key=lambda x: x[0])
+            edit_distances.sort(key=operator.itemgetter(0))
             choices.extend(x[1] for x in edit_distances[: self._num_choices])
         return iter(choices)
 
     def keys(self):
         """
         N.B. argcomplete will call keys() on parser.choices to get options
         for auto-completion. This needs to be a pass-through to real_choices
@@ -174,15 +175,15 @@
     Help commands have their own subclass for which we need another subparser
     """
     help_subparser = subparsers.add_parser(cls.NAME, description=cls.SYNOPSIS, help=cls.SYNOPSIS)
     help_subparsers = help_subparser.add_subparsers()
     help_subparsers.choices = HelpfulSubparserChoicesWrapper(
         help_subparsers.choices, MAX_EDIT_DISTANCE_CHOICES
     )
-    for help_cls in sorted(HelpCommand.__subclasses__(), key=lambda help_cls: help_cls.NAME):
+    for help_cls in sorted(HelpCommand.__subclasses__(), key=operator.attrgetter('NAME')):
         parse_subcommand(help_cls, help_subparsers)
 
 
 def add_subcommands(parser):
     parser.formatter_class = SubcommandHelpFormatter
     subparsers = parser.add_subparsers(
         title='Qumulo Command Line Interface',
@@ -190,15 +191,15 @@
         help='Action',
         metavar='',
     )
     subparsers.choices = HelpfulSubparserChoicesWrapper(
         subparsers.choices, MAX_EDIT_DISTANCE_CHOICES
     )
 
-    for cls in sorted(Subcommand.__subclasses__(), key=lambda cls: cls.NAME):
+    for cls in sorted(Subcommand.__subclasses__(), key=operator.attrgetter('NAME')):
         if cls.NAME == 'help':
             parse_help_options(cls, subparsers)
         else:
             parse_subcommand(cls, subparsers)
 
 
 def parse_options(parser, argv):
```

## qumulo/lib/qq.py

```diff
@@ -103,40 +103,42 @@
     # the command takes. Public commands take a qumulo.rest_client.RestClient, while private
     # commands take a qinternal.api.client.rest_client.RestClient, which is a subclass of
     # qumulo.rest_client.RestClient.
     opts.run_subcommand(args.subcommand, rest_client, args)
 
 
 def qq_main(argv: Sequence[str], rest_client_factory: RestClientFactoryProtocol) -> int:
+    args: Optional[argparse.Namespace] = None
+
     try:
         parzer = argparse.ArgumentParser(description='Qumulo CLI', add_help=True)
         main_options(parzer)
-        argz = opts.parse_options(parzer, argv)
-        assert argz is not None
+        args = opts.parse_options(parzer, argv)
+        assert args is not None
 
         # If no subcommand is specified, the Namespace object is returned but it is
         # missing the subcommand attribute. See https://bugs.python.org/issue9253
-        if not hasattr(argz, 'subcommand'):
+        if not hasattr(args, 'subcommand'):
             parzer.print_usage()
             print('qq: error: too few arguments; try --help to find a list of usable subcommands.')
             return 1
-        main(argz, rest_client_factory)
+        main(args, rest_client_factory)
 
     except KeyboardInterrupt:
         print('\nCommand interrupted')
         return 1
 
     except qumulo.lib.request.RequestError as e:
         # When using QQ RequestError is common and expected. Only print out a
         # terse message about the error by calling pretty_str.
         print(e.pretty_str())
         return 1
 
     except ValueError as e:
-        if os.getenv('DEBUG_CLI') or (argz is not None and argz.debug):
+        if os.getenv('DEBUG_CLI') or (args is not None and args.debug):
             print('Command error: %s' % str(e))
             raise
 
         print('Command error: %s' % str(e))
         return 1
 
     except OSError as e:
```

## qumulo/lib/request.py

```diff
@@ -51,15 +51,19 @@
 Body = Union[Sequence[object], Mapping[str, object]]
 
 CONTENT_TYPE_JSON = 'application/json'
 CONTENT_TYPE_BINARY = 'application/octet-stream'
 CONTENT_TYPE_SSE_STREAM = 'text/event-source'
 
 DEFAULT_CHUNKED = False
-DEFAULT_CHUNK_SIZE_BYTES = 1024
+
+# Chosen as a sweet spot for performance. Minimizes chunk and SSL overhead without being wasteful
+# with memory. It's 10% faster than 64KiB and 20000% faster than 1KiB. Somewhere around 1MiB perf
+# starts to decrease again.
+DEFAULT_CHUNK_SIZE_BYTES = 1024 * 128
 
 NEED_LOGIN_MESSAGE = 'Need to log in first to establish credentials.'
 
 PRIV_PORT_BEG = 900
 PRIV_PORT_END = 1024
 
 LOCALHOSTS = frozenset(['localhost', 'ip6-localhost', '127.0.0.1', '::1'])
```

## qumulo/rest/ad.py

```diff
@@ -7,256 +7,188 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 
 
-from typing import Optional
+from typing import Any, Dict, List, Optional
 
 import qumulo.lib.request as request
 
-from qumulo.lib.auth import Credentials
 from qumulo.lib.uri import UriBuilder
 
-
-@request.request
-def list_ad(
-    conninfo: request.Connection, _credentials: Optional[Credentials]
-) -> request.RestResponse:
-    method = 'GET'
-    uri = '/v1/ad/status'
-
-    return conninfo.send_request(method, uri)
-
-
-@request.request
-def poll_ad(
-    conninfo: request.Connection, _credentials: Optional[Credentials]
-) -> request.RestResponse:
-    method = 'GET'
-    uri = '/v1/ad/monitor'
-
-    return conninfo.send_request(method, uri)
-
-
-@request.request
-def join_ad(
-    conninfo: request.Connection,
-    _credentials: Optional[Credentials],
-    domain: object,
-    username: object,
-    password: object,
-    ou: Optional[object] = None,
-    domain_netbios: Optional[object] = None,
-    enable_ldap: bool = False,
-    base_dn: Optional[object] = None,
-) -> request.RestResponse:
-    method = 'POST'
-    uri = '/v1/ad/join'
-
-    if ou is None:
-        ou = ''
-    if domain_netbios is None:
-        domain_netbios = ''
-    if base_dn is None:
-        base_dn = ''
-
-    config = {
-        'domain': str(domain),
-        'domain_netbios': str(domain_netbios),
-        'user': str(username),
-        'password': str(password),
-        'ou': str(ou),
-        'use_ad_posix_attributes': enable_ldap,
-        'base_dn': str(base_dn),
-    }
-
-    return conninfo.send_request(method, uri, body=config)
-
-
-@request.request
-def reconfigure_ad(
-    conninfo: request.Connection,
-    _credentials: Optional[Credentials],
-    enable_ldap: bool,
-    base_dn: str,
-) -> request.RestResponse:
-    method = 'POST'
-    uri = '/v1/ad/reconfigure'
-
-    config = {'use_ad_posix_attributes': enable_ldap, 'base_dn': base_dn}
-
-    return conninfo.send_request(method, uri, body=config)
-
-
-@request.request
-def leave_ad(
-    conninfo: request.Connection,
-    _credentials: Optional[Credentials],
-    domain: object,
-    username: object,
-    password: object,
-) -> request.RestResponse:
-    method = 'POST'
-    uri = '/v1/ad/leave'
-
-    # XXX scott: support none for these in the api, also, don't call domain
-    # assistant script in that case
-    if username is None:
-        username = ''
-    if password is None:
-        password = ''
-
-    config = {'domain': str(domain), 'user': str(username), 'password': str(password)}
-
-    return conninfo.send_request(method, uri, body=config)
-
-
-@request.request
-def cancel_ad(
-    conninfo: request.Connection, _credentials: Optional[Credentials]
-) -> request.RestResponse:
-    method = 'POST'
-    uri = '/v1/ad/cancel'
-
-    return conninfo.send_request(method, uri)
-
-
-@request.request
-def uid_to_sid_get(
-    conninfo: request.Connection, _credentials: Optional[Credentials], uid: object
-) -> request.RestResponse:
-    method = 'GET'
-    uri = '/v1/ad/uids/' + str(uid) + '/sids/'
-
-    return conninfo.send_request(method, uri)
-
-
-@request.request
-def username_to_sid_get(
-    conninfo: request.Connection, _credentials: Optional[Credentials], name: object
-) -> request.RestResponse:
-    return conninfo.send_request('GET', f'/v1/ad/usernames/{name}/sids/')
-
-
-@request.request
-def name_to_ad_accounts(
-    conninfo: request.Connection, _credentials: Optional[Credentials], name: object
-) -> request.RestResponse:
-    uri = UriBuilder(path='/v1/ad/usernames')
-    uri.add_path_component(str(name))
-    uri.add_path_component('objects')
-    uri.append_slash()
-    return conninfo.send_request('GET', str(uri))
-
-
-@request.request
-def sid_to_uid_get(
-    conninfo: request.Connection, _credentials: Optional[Credentials], sid: str
-) -> request.RestResponse:
-    method = 'GET'
-    uri = '/v1/ad/sids/' + sid + '/uid'
-
-    return conninfo.send_request(method, uri)
-
-
-@request.request
-def sid_to_username_get(
-    conninfo: request.Connection, _credentials: Optional[Credentials], sid: object
-) -> request.RestResponse:
-    return conninfo.send_request('GET', f'/v1/ad/sids/{sid}/username')
-
-
-@request.request
-def sid_to_gid_get(
-    conninfo: request.Connection, _credentials: Optional[Credentials], sid: str
-) -> request.RestResponse:
-    method = 'GET'
-    uri = '/v1/ad/sids/' + sid + '/gid'
-
-    return conninfo.send_request(method, uri)
-
-
-@request.request
-def sid_to_ad_account(
-    conninfo: request.Connection, _credentials: Optional[Credentials], sid: str
-) -> request.RestResponse:
-    return conninfo.send_request('GET', '/v1/ad/sids/' + sid + '/object')
-
-
-@request.request
-def gid_to_sid_get(
-    conninfo: request.Connection, _credentials: Optional[Credentials], gid: object
-) -> request.RestResponse:
-    method = 'GET'
-    uri = '/v1/ad/gids/' + str(gid) + '/sids/'
-
-    return conninfo.send_request(method, uri)
-
-
-@request.request
-def sid_to_expanded_group_sids_get(
-    conninfo: request.Connection, _credentials: Optional[Credentials], sid: str
-) -> request.RestResponse:
-    method = 'GET'
-    uri = '/v1/ad/sids/' + sid + '/expanded-groups/'
-
-    return conninfo.send_request(method, uri)
-
-
-@request.request
-def distinguished_name_to_ad_account(
-    conninfo: request.Connection, _credentials: Optional[Credentials], distinguished_name: object
-) -> request.RestResponse:
-    uri = UriBuilder(path='/v1/ad/distinguished-names/')
-    uri.add_path_component(str(distinguished_name))
-    uri.add_path_component('object')
-    return conninfo.send_request('GET', str(uri))
-
-
-@request.request
-def get_advanced_settings(
-    conninfo: request.Connection, _credentials: Optional[Credentials]
-) -> request.RestResponse:
-    method = 'GET'
-    uri = '/v1/ad/settings'
-    return conninfo.send_request(method, uri)
-
-
 # Values for the advanced AD setting controlling DCERPC signing.
 VALID_SIGNING_CHOICES = ('NO_SIGNING', 'WANT_SIGNING', 'REQUIRE_SIGNING')
 
 # Values for the advanced AD setting controlling DCERPC sealing.
 VALID_SEALING_CHOICES = ('NO_SEALING', 'WANT_SEALING', 'REQUIRE_SEALING')
 
 # Values for the advanced AD setting controlling DCERPC encryption.
 VALID_ENCRYPTION_CHOICES = ('NO_AES', 'WANT_AES', 'REQUIRE_AES')
 
+MonitorURI = Dict[str, str]
+AdLdapObject = Dict[str, Any]
+
 
-@request.request
-def set_advanced_settings(
-    conninfo: request.Connection,
-    _credentials: Optional[Credentials],
-    signing: object,
-    sealing: object,
-    crypto: object,
-    if_match: Optional[str] = None,
-) -> request.RestResponse:
-    """
-    This method controls advanced Active Directory settings.
-
-    @param signing  Configure DCERPC signing to be off, prefer signing, or require
-                    signing. Must be one of NO_SIGNING, WANT_SIGNING, or REQUIRE_SIGNING
-
-    @param sealing  Configure DCERPC sealing to be off, prefer sealing, or require
-                    sealing. Must be one of NO_SEALING, WANT_SEALING, or REQUIRE_SEALING
-
-    @param crypto   Configure DCERPC to not use encryption, prefer AES encryption,
-                    or require AES encryption. Must be one of NO_AES, WANT_AES, or
-                    REQUIRE_AES
-    """
-    method = 'PUT'
-    uri = '/v1/ad/settings'
-    body = {'signing': str(signing), 'sealing': str(sealing), 'crypto': str(crypto)}
+class ActiveDirectory:
+    def __init__(self, client: request.SendRequestObject):
+        self.client = client
+
+    def list_ad(self) -> Dict[str, Any]:
+        method = 'GET'
+        uri = '/v1/ad/status'
+
+        return self.client.send_request(method, uri).data
+
+    def poll_ad(self) -> Dict[str, Any]:
+        method = 'GET'
+        uri = '/v1/ad/monitor'
+
+        return self.client.send_request(method, uri).data
+
+    def join_ad(
+        self,
+        domain: object,
+        username: object,
+        password: object,
+        ou: Optional[object] = None,
+        domain_netbios: Optional[object] = None,
+        enable_ldap: Optional[bool] = False,
+        base_dn: Optional[object] = None,
+        search_trusted_domains: Optional[bool] = None,
+    ) -> MonitorURI:
+        method = 'POST'
+        uri = '/v1/ad/join'
+
+        if ou is None:
+            ou = ''
+        if domain_netbios is None:
+            domain_netbios = ''
+        if base_dn is None:
+            base_dn = ''
+
+        config = {
+            'domain': str(domain),
+            'domain_netbios': str(domain_netbios),
+            'user': str(username),
+            'password': str(password),
+            'ou': str(ou),
+            'use_ad_posix_attributes': enable_ldap,
+            'base_dn': str(base_dn),
+        }
+        if search_trusted_domains is not None:
+            config['search_trusted_domains'] = search_trusted_domains
+
+        return self.client.send_request(method, uri, body=config).data
+
+    def reconfigure_ad(
+        self, enable_ldap: bool, base_dn: str, search_trusted_domains: Optional[bool] = None
+    ) -> MonitorURI:
+        method = 'POST'
+        uri = '/v1/ad/reconfigure'
+
+        config = {'use_ad_posix_attributes': enable_ldap, 'base_dn': base_dn}
+        if search_trusted_domains is not None:
+            config['search_trusted_domains'] = search_trusted_domains
+
+        return self.client.send_request(method, uri, body=config).data
+
+    def leave_ad(self, domain: object, username: object, password: object) -> MonitorURI:
+        method = 'POST'
+        uri = '/v1/ad/leave'
+
+        # XXX scott: support none for these in the api, also, don't call domain
+        # assistant script in that case
+        if username is None:
+            username = ''
+        if password is None:
+            password = ''
+
+        config = {'domain': str(domain), 'user': str(username), 'password': str(password)}
+
+        return self.client.send_request(method, uri, body=config).data
+
+    def cancel_ad(self) -> MonitorURI:
+        method = 'POST'
+        uri = '/v1/ad/cancel'
+
+        return self.client.send_request(method, uri).data
+
+    def uid_to_sid_get(self, uid: object) -> List[str]:
+        method = 'GET'
+        uri = '/v1/ad/uids/' + str(uid) + '/sids/'
+
+        return self.client.send_request(method, uri).data
+
+    def username_to_sid_get(self, name: object) -> List[str]:
+        return self.client.send_request('GET', f'/v1/ad/usernames/{name}/sids/').data
+
+    def name_to_ad_accounts(self, name: object) -> List[AdLdapObject]:
+        uri = UriBuilder(path='/v1/ad/usernames')
+        uri.add_path_component(str(name))
+        uri.add_path_component('objects')
+        uri.append_slash()
+        return self.client.send_request('GET', str(uri)).data
+
+    def sid_to_uid_get(self, sid: str) -> Dict[str, int]:
+        method = 'GET'
+        uri = '/v1/ad/sids/' + sid + '/uid'
+
+        return self.client.send_request(method, uri).data
+
+    def sid_to_username_get(self, sid: object) -> str:
+        return self.client.send_request('GET', f'/v1/ad/sids/{sid}/username').data
+
+    def sid_to_gid_get(self, sid: str) -> Dict[str, int]:
+        method = 'GET'
+        uri = '/v1/ad/sids/' + sid + '/gid'
+
+        return self.client.send_request(method, uri).data
+
+    def sid_to_ad_account(self, sid: str) -> AdLdapObject:
+        return self.client.send_request('GET', '/v1/ad/sids/' + sid + '/object').data
+
+    def gid_to_sid_get(self, gid: object) -> List[str]:
+        method = 'GET'
+        uri = '/v1/ad/gids/' + str(gid) + '/sids/'
+
+        return self.client.send_request(method, uri).data
+
+    def sid_to_expanded_group_sids_get(self, sid: str) -> List[Dict[str, str]]:
+        method = 'GET'
+        uri = '/v1/ad/sids/' + sid + '/expanded-groups/'
+
+        return self.client.send_request(method, uri).data
+
+    def distinguished_name_to_ad_account(self, distinguished_name: object) -> AdLdapObject:
+        uri = UriBuilder(path='/v1/ad/distinguished-names/')
+        uri.add_path_component(str(distinguished_name))
+        uri.add_path_component('object')
+        return self.client.send_request('GET', str(uri)).data
+
+    def get_advanced_settings(self) -> request.RestResponse:
+        method = 'GET'
+        uri = '/v1/ad/settings'
+        return self.client.send_request(method, uri)
+
+    def set_advanced_settings(
+        self, signing: object, sealing: object, crypto: object, if_match: Optional[str] = None
+    ) -> Dict[str, str]:
+        """
+        This method controls advanced Active Directory settings.
+
+        @param signing  Configure DCERPC signing to be off, prefer signing, or require
+                        signing. Must be one of NO_SIGNING, WANT_SIGNING, or REQUIRE_SIGNING
+
+        @param sealing  Configure DCERPC sealing to be off, prefer sealing, or require
+                        sealing. Must be one of NO_SEALING, WANT_SEALING, or REQUIRE_SEALING
+
+        @param crypto   Configure DCERPC to not use encryption, prefer AES encryption,
+                        or require AES encryption. Must be one of NO_AES, WANT_AES, or
+                        REQUIRE_AES
+        """
+        method = 'PUT'
+        uri = '/v1/ad/settings'
+        body = {'signing': str(signing), 'sealing': str(sealing), 'crypto': str(crypto)}
 
-    return conninfo.send_request(method, uri, body=body, if_match=if_match)
+        return self.client.send_request(method, uri, body=body, if_match=if_match).data
```

## qumulo/rest/fs.py

```diff
@@ -661,15 +661,15 @@
     return conninfo.send_request(method, str(uri))
 
 
 @request.request
 def resolve_paths(
     conninfo: Connection,
     _credentials: Optional[Credentials],
-    ids: Dict[str, object],
+    ids: List[str],
     snapshot: Optional[int] = None,
 ) -> request.RestResponse:
     method = 'POST'
     uri = build_files_uri(['resolve'])
 
     if snapshot:
         uri.add_query_param('snapshot', snapshot)
@@ -1533,19 +1533,23 @@
     method = 'GET'
     uri = f'/v1/file-system/security/keys/{key_ref}'
     return conninfo.send_request(method, uri)
 
 
 @request.request
 def security_get_key_usage(
-    conninfo: request.Connection, _credentials: Optional[Credentials], key_ref: str
-) -> request.RestResponse:
-    method = 'GET'
-    uri = f'/v1/file-system/security/keys/{key_ref}/usage'
-    return conninfo.send_request(method, uri)
+    conninfo: request.Connection,
+    _credentials: Optional[Credentials],
+    key_ref: str,
+    page_size: Optional[int] = None,
+) -> request.PagingIterator:
+    def get(uri: UriBuilder) -> request.RestResponse:
+        return conninfo.send_request('GET', str(uri))
+
+    return request.PagingIterator(f'/v1/file-system/security/keys/{key_ref}/usages', get, page_size)
 
 
 @request.request
 def security_modify_key(
     conninfo: request.Connection,
     _credentials: Optional[Credentials],
     key_ref: str,
```

## qumulo/rest/replication.py

```diff
@@ -309,7 +309,20 @@
     _credentials: Optional[Credentials],
     relationship_id: str,
     snapshot_id: str,
 ) -> request.RestResponse:
     method = 'DELETE'
     uri = '/v2/replication/source-relationships/{}/queued-snapshots/{}'
     return conninfo.send_request(method, uri.format(relationship_id, snapshot_id))
+
+
+@request.request
+def set_target_relationship_lock(
+    conninfo: Connection,
+    _credentials: Optional[Credentials],
+    relationship_id: str,
+    lock_key: Optional[str],
+) -> request.RestResponse:
+    method = 'POST'
+    uri = f'/v2/replication/target-relationships/{relationship_id}/lock'
+    body = {'lock_key_ref': lock_key}
+    return conninfo.send_request(method, uri, body=body)
```

## qumulo/rest/snapshot.py

```diff
@@ -158,15 +158,15 @@
     conninfo: request.Connection,
     credentials: Optional[Credentials],
     policy_name: str,
     schedule_info: Mapping[str, object],
     snapshot_name_template: Optional[str] = None,
     directory_id: Optional[str] = None,
     enabled: Optional[bool] = None,
-    lock_key_ref: Optional[LockKeyRef] = None,
+    lock_key_ref: Optional[str] = None,
 ) -> request.RestResponse:
     method = 'POST'
     uri = '/v3/snapshots/policies/'
 
     if directory_id == None:
         directory_id = cast(
             str, qumulo.rest.fs.get_file_attr(conninfo, credentials, path='/').lookup('file_number')
@@ -174,15 +174,15 @@
 
     policy = {
         'policy_name': policy_name,
         'schedule': schedule_info,
         'source_file_id': directory_id,
         'enabled': enabled if enabled is not None else True,
         'snapshot_name_template': snapshot_name_template,
-        'lock_key_ref': f'{lock_key_ref.ref}' if lock_key_ref is not None else None,
+        'lock_key_ref': lock_key_ref,
     }
 
     return conninfo.send_request(method, uri, body=policy)
 
 
 @request.request
 def modify_policy(
```

## Comparing `qumulo_api-6.1.0.1.dist-info/LICENSE` & `qumulo_api-6.1.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `qumulo_api-6.1.0.1.dist-info/METADATA` & `qumulo_api-6.1.1.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: qumulo-api
-Version: 6.1.0.1
+Version: 6.1.1
 Summary: Qumulo Python SDK
 Home-page: http://www.qumulo.com/
 Author: Qumulo, Inc.
 Author-email: python@qumulo.com
 License: UNKNOWN
 Keywords: Qumulo QFSD
 Platform: UNKNOWN
```

## Comparing `qumulo_api-6.1.0.1.dist-info/RECORD` & `qumulo_api-6.1.1.dist-info/RECORD`

 * *Files 5% similar despite different names*

```diff
@@ -1,107 +1,107 @@
-qumulo/__init__.py,sha256=1xJiieKyOmpyFP-DedwKFeP9OkmZ6oDxc0rGMfOewS8,24
-qumulo/rest_client.py,sha256=ji0uDqp5RbFbLOng39GFR-3jSTyiOdA3GYVYK3LXaFk,10792
+qumulo/__init__.py,sha256=TogwtvfScmmY5i06w1pmsYL28pcWyPETM_YMFRujQQY,22
+qumulo/rest_client.py,sha256=aq90iwIFpgnfiqTJYIlSvVtZJc_EoVVAodEfyDQRm0Y,11049
 qumulo/retry.py,sha256=u1hJFtqzIg89ShrWFcbsG1voSNHzbjuQiayb91UdlBE,5463
 qumulo/commands/__init__.py,sha256=JgiD4KhBsFJDY3Q_8l4cVHMBCEMXg20C2aCjhYY7IO0,1178
 qumulo/commands/access_tokens.py,sha256=6yTTZIIFzUrGTJbZBKb6L1icFGu5QML8FXaKNFblUrg,7430
-qumulo/commands/ad.py,sha256=z3ssu2FiIrySPjF6S-PLLk-p9U_O1MyooimPBv8DQbc,15993
+qumulo/commands/ad.py,sha256=qyVkBBHX1arhHCP477tJfn3u002NAOVoCZgO0rmLdNI,16853
 qumulo/commands/analytics.py,sha256=oTV-iupk3n8VqnxXS2HzDxz2TwdWdVLSe50cs21RSCQ,5048
 qumulo/commands/audit.py,sha256=JI4TfZwqQqX88z6bgRi2ZHop0dHVFpmVJQ5bCCU2zJE,6531
 qumulo/commands/auth.py,sha256=vHKm-gNDPBEsU2M4X8fgt7wolrH7fmYLWu6LvY6jiQI,35605
 qumulo/commands/checksumming.py,sha256=3q3pltd1RS22a-PoJWyI6u_rL6H3j5xfY0Wgn2Snnc8,1045
-qumulo/commands/cluster.py,sha256=nZkOMsQ12_eu3tK-uRPPeCsFFLDU717DBFhnc0pXUIQ,18179
+qumulo/commands/cluster.py,sha256=0s9Pf2LZbAPOQp23g3UKEUdEX6vZiQFe845U9JnAm4U,18172
 qumulo/commands/dns.py,sha256=iwUEtLkGIIpmm0MLNavXiOtXB1Mmrmio9EwqNcMPXXs,4605
 qumulo/commands/encryption.py,sha256=gYO8SsBDDMPS-OP5pUyZdYfnNS91dJM9Yj9FM9ZY5FA,1506
 qumulo/commands/file_permissions_help.py,sha256=gWzBwYJEXURk2Dz3G-f9u3QDPX9WwK7lAfcOrfu_Gro,2843
-qumulo/commands/fs.py,sha256=NaPw8YusdQPyd8czTq0pOAQrByqGDU4hEGHRXXZR9AM,129986
+qumulo/commands/fs.py,sha256=RNmMRDYbPbHndrexQsLt4xgk-81KIFjI3sCE7rvR_Cg,129900
 qumulo/commands/ftp.py,sha256=1rObDBzV_kHIbbNDEH8ZncxHmHy7UfEfLIrX4pEpNf8,3933
-qumulo/commands/kerberos.py,sha256=wv2uuS63B_5pCQqiEWUerwkY8HqvfPwW8TQyBmgr1Mg,3603
-qumulo/commands/key_store.py,sha256=NGdUAzi2Pyi17EcOp1StjhET9W_87Qydt2f5PJOsRHs,21410
+qumulo/commands/kerberos.py,sha256=kpziy7Hew-eL8RDETmdNtMJ2bLOkYnEIXuOrUdTE1-E,3596
+qumulo/commands/key_store.py,sha256=sropAA4pDhbnNt64IVP5TUWYqbn_eOLLBrlNn59OkHw,18150
 qumulo/commands/ldap.py,sha256=M7TTecZJWHR8-qy2ZIwoCxhRa9t1DrcKTClUsYUcWw0,12310
 qumulo/commands/login.py,sha256=AeBwSfoRTDN6XL-FWO_UONPSYQuglVZH2pG7O7SyA1g,6846
 qumulo/commands/metrics.py,sha256=7gt0OGWfV_hE5ZH2B1i5xxOEIEt1-kIbUGJ9MtYPF9A,1070
-qumulo/commands/multitenancy.py,sha256=4t4vHFhni7Pk4-0zk4oOY7PUnjI8j9DJQYp8Gm6Voe0,15745
+qumulo/commands/multitenancy.py,sha256=l-JjCkEiDhZ8CCNvatB3dSNFzhels8NYuVHHl9gi5ug,16823
 qumulo/commands/multitenancy_nfs.py,sha256=S4ImwGWT064FNixBTcZDSn7XDLAhel1KgyAqsR78RP0,9981
 qumulo/commands/multitenancy_smb.py,sha256=PUxc-AAa9B_O6KVsnv5PQ8ZQZvwhcpZ4UYXFEdRVk_c,8845
 qumulo/commands/network.py,sha256=ge36fM9ikmnt9S9ayS1IB5OgRFLOc5bBxJA2Ine0VvQ,20655
 qumulo/commands/nfs.py,sha256=QL0BIiJPbxwj9BEpDsmeKfjEVNmMrf9McBu_0NaBEj4,34897
 qumulo/commands/node_state.py,sha256=GoBHhJHY4vYaBJcRDJ9ZLaoUmI7uU7S8s7c8I7xUZq8,1015
 qumulo/commands/object_replication.py,sha256=FhCUaFtt6hcEslHha05lySDR4f-jh4KIhpIqV-qEWWE,10630
 qumulo/commands/quota.py,sha256=0aDTFGXsTV_aQvoQW0dw22MUQdeQ4ntJZOaivfVvlxU,6173
 qumulo/commands/raw.py,sha256=cpIN4WkEIP9Q5-S8av2kwFw-wbhSUycD7iWXB2PHoQw,2531
-qumulo/commands/replication.py,sha256=Es_4-k_XSwaE4xGdWMmwX0Swqfl-O0qoxQhXJbwqVIw,32784
+qumulo/commands/replication.py,sha256=fCsipk4nyzMdjVnuJN0xRXz7POtfZpuw3yUWIzOWkOw,35414
 qumulo/commands/roles.py,sha256=2SJY_TtpyFpyDY3hhGddgVMQWf7JVx2uqfBjVF359Vg,14355
 qumulo/commands/s3.py,sha256=aSrLOy2wTn-CoTbEBlz9nTwJeo-h8gh2w0TksXVqIb0,15644
 qumulo/commands/saml.py,sha256=1KnKaVkucGdhBCfnUEnknChHqif0HSCGLX3rp3Hxezo,5323
 qumulo/commands/shutdown.py,sha256=p30oHkBayaN7mGwCkf_-wLaGmZVtKWprpXBPCRvM_3U,3259
-qumulo/commands/smb.py,sha256=EnBx07TkN2uQoAfpi61zVwc_FsDG8eLLG2EVBJNcQ9Q,50961
-qumulo/commands/snapshot.py,sha256=S1myH22RJYGiekxtuPlAe0vCXBkuHjjLopCPOosWXJU,45290
+qumulo/commands/smb.py,sha256=ggrmqlPS7HGgplJiM1Gewll4DYvtrpwq83SOwZ-ggY8,52180
+qumulo/commands/snapshot.py,sha256=97WNW-H294g50NFRkkIhJ6EAgNX5VEyakI2oc8Q70oM,44057
 qumulo/commands/support.py,sha256=vDruyK8_YmKgvbXMqfbsr9HNnPESM1dCcS61yG2y8aA,7403
 qumulo/commands/time_config.py,sha256=5yEHDjqMepuJUaTHU2bWU7hZNpb50N0ctm6ZuLY3Z8o,2935
 qumulo/commands/tree_delete.py,sha256=466KijoQM9hIyxofPkgFWS8UzNn679LIpc77SvaihC4,4604
 qumulo/commands/unconfigured_node_operations.py,sha256=oM2jVh3GJxkYmOz5DVVCg7CZp1YH_nersk-e3kG8dx4,1403
-qumulo/commands/upgrade.py,sha256=NXTD5w7kitAiTTs9QBFbT_Y-DclELsY6rxReb8DWc5c,21797
+qumulo/commands/upgrade.py,sha256=2RpTbc6twFvgK2sSsic30M9t4GZnkgVPxKn3AkiUWI4,22129
 qumulo/commands/version.py,sha256=QjLnP83uaikX7YAGOPenL8S6kOM-JB0DnZaf2zTecaA,976
 qumulo/commands/web_ui.py,sha256=bkewSUbORS2IGiz81F7pf-5Sjug81MPomkhhmHfDJ-4,7374
 qumulo/lib/__init__.py,sha256=DGCGrUjsJi4fACGMXMikmfM56h6uK_ZHUW2aO3hpaoI,669
 qumulo/lib/acl_util.py,sha256=w0ZiKm-n39BNKx3mvFmX9W3QmxYT1BpgawysQxkHR94,12849
 qumulo/lib/auth.py,sha256=SuKI7j51_3-vaRoh5HAa23Dl8Qf22xL0DW3O9-BmuOE,4047
 qumulo/lib/duration.py,sha256=-Wox4gXrCXepQcEjDDT4gReaws_baaThxIL6THAD9tc,1833
 qumulo/lib/identity_util.py,sha256=hvTgijZ3FGCaqX6GD-WpwcplFIAq_luHMah88IyEZlQ,11107
 qumulo/lib/keys.py,sha256=4Bjcm9cPiWkrRuSgLMe8XfuIScWrptRMvQcj5YbKKyo,3551
 qumulo/lib/obj.py,sha256=gJetz-BK9LxtqQADzpmiSUNUZwDu2SUIIf8Ig4vqDDI,2230
-qumulo/lib/opts.py,sha256=AJ9bQrwOYWUEcpDJ5EmEyGcnM49Sg7QdVnkqYLqx1bw,8873
-qumulo/lib/qq.py,sha256=rdFvl5QFkGE7MXO7fG6FUToSbM8UyVE0QRTQwWZ1Uu4,6016
-qumulo/lib/request.py,sha256=dHFpNnuc1VrQgFDckfpTkJcZ5T-IZNTgvX_Fe0L8Obo,24972
+qumulo/lib/opts.py,sha256=jY5ToIjIX-xRIgi_evvU9I_k006K_pmHVX_nqUQLbcs,8901
+qumulo/lib/qq.py,sha256=hNkV13WKDVeeSh4WZdhau7-KhpGe0SDN6up3Eg47NS4,6063
+qumulo/lib/request.py,sha256=4y5S-mXx5t7WwavpXH9FEKqYJp5DXRh5vVyB2XwbWSU,25203
 qumulo/lib/rest_util.py,sha256=e8jHj2tvJCSljQFtVPw9GJpTuDTT6ECYbFN0K4dcTQQ,1058
 qumulo/lib/rfc3339.py,sha256=nldESt-PcUWaaGJY3yRtD4geTn35h0EvYoNsie2yP0I,926
 qumulo/lib/tenant.py,sha256=uvlW3bAZNT0CRF9CUXdRdwlJf7p14ENJA5cY_wXqqpU,2009
 qumulo/lib/uri.py,sha256=9zWsU20p6phHupk8dTEsbVmUYSwSpx4Kb0B9OZ2VEWQ,3350
 qumulo/lib/util.py,sha256=Ed4zFb2Q7Bl_lisTCopwHh8swnwahd2ijzNcn8ziuZE,14792
 qumulo/rest/__init__.py,sha256=4T_T52X6NRTPg-Xmsf057SRhbz7RlWNDPSlVpKcg6_I,1167
 qumulo/rest/access_tokens.py,sha256=zDFQaTejK96LbpX37KufHt0q2SsOMs3OyU4SDjChdRY,4501
-qumulo/rest/ad.py,sha256=BO4Drhnnk-EXOLZ7UlCMzaKRAw5BWbuU5GruiFcRJMQ,7654
+qumulo/rest/ad.py,sha256=YdFGR_lWm-SFgoV7aygNRf8p-mZKrfiHHJaKci3fDyo,7046
 qumulo/rest/analytics.py,sha256=mh7-xa2HZIMNIn6v5jb7iFZEOquob40dzuiLUKc4Vfg,2204
 qumulo/rest/audit.py,sha256=WNfiXZIP7jGRIgsjfvfYBEeS1TLCdP-n2EY36Tup3v8,5909
 qumulo/rest/auth.py,sha256=5gGOwOmBvdsWNhOAgo9vz8SSGxDINvXvZMMgp8U3KL0,8419
 qumulo/rest/checksumming.py,sha256=kBlck-tQvDQNP-x8L24nxK1j90E_30hiVl6cCuAA0-o,914
 qumulo/rest/cluster.py,sha256=JroZ2QXo71acWsFNmpVj9F_J8n1dy_km7KB71bJEdgk,8793
 qumulo/rest/dns.py,sha256=SrRHt9ZlOezFK0fqpD9x0qcY_cMqaTM-YUWVn1lypUA,3056
 qumulo/rest/encryption.py,sha256=sDBrntJt2FozrOf4aq2gOntzzuxke-k70CZS8sis6h0,1148
-qumulo/rest/fs.py,sha256=-U9WEWvMQnbjX-9B-uD5LGmJs6BbnkPLy1kkn_sObMw,49457
+qumulo/rest/fs.py,sha256=-NO82G42cv4B3wlZRH5E6zO59bB-_vjSi01sLVVaYzo,49583
 qumulo/rest/ftp.py,sha256=1VxfZDzzvx50uw74m0sk8C-X_52x130bY2fW12IcBdk,4531
 qumulo/rest/groups.py,sha256=n4ZNfSzB7Q8AtQS5ZZqawS489i7X2l8uSUKetylhoaY,4410
 qumulo/rest/kerberos.py,sha256=cd1erooNDanAAq6FmVGeaemqmbloOfqKjy2mHQ9F7no,2897
 qumulo/rest/ldap.py,sha256=FWRVQhQ3mSXSFBWJDiZ9PSGWHfF-hosMcurrD0kROek,4490
 qumulo/rest/metrics.py,sha256=Tom5Y4KMa5d7qBE6dAJ6fqFs5R815No6U47fo_nqlFQ,1251
 qumulo/rest/multitenancy.py,sha256=k1liR_k7lPTg1nZGPUNg9aRusFjl_Dx5fLkshj69J6s,4909
 qumulo/rest/multitenancy_nfs.py,sha256=P--8o5jF8JuourLLMat5qAP_RQ79W_Gc2iLlGd1zZ40,5260
 qumulo/rest/multitenancy_smb.py,sha256=XBrwlBpof9UlVAqqesQ2jPw_d5WEdnbLBat6NqG2HKk,3616
 qumulo/rest/network.py,sha256=y2_thKk9kcqJDsAN0Z96VwBfGiKhNMiY7kiHXagJ0uQ,8417
 qumulo/rest/nfs.py,sha256=j3OHQXRD_aJrrP5xlrNV_Iz4YqzL1Q1o_v12U8lqXTI,8467
 qumulo/rest/node_state.py,sha256=MF-hADKq9ZcSWp_5pLzinmV9FmflWHRdbdDyEMTZvTA,910
 qumulo/rest/object_replication.py,sha256=MIdHZ4APNGD2L7O2ucPhNGGLYNtZed7mBytBt1BV2wQ,4468
 qumulo/rest/quota.py,sha256=YjcQ0PSc5QEytqzt6zm3Be3wicqmIYbr70DOnn-sv-0,3426
-qumulo/rest/replication.py,sha256=0uUsjjwIjUz16uvVAXOJuxScHCDSot1bWmjgLn0S7_M,10612
+qumulo/rest/replication.py,sha256=SycnRrOhTAHDjgBkFLsLe9SBW4UqTqpmdbTXDPIOd0w,11002
 qumulo/rest/roles.py,sha256=5XlJmpXLzOsvPLYs-G4MNmsiRHgug-6h9QIQkdgjQtQ,6628
 qumulo/rest/s3.py,sha256=NyM2GUN3o9qL-aoY0eKSnwvkiDpMF2iOjdgpsvdDY5o,9857
 qumulo/rest/saml.py,sha256=gSqoD_FO-Jy9mgVMNBCYBTGTYGzUbKnX6c3z5IIXRk0,2687
 qumulo/rest/shutdown.py,sha256=f1rkzEJR1Hjm7hfF46RlowHxWkUW1cgOBLD1O6-1Nyg,1944
 qumulo/rest/smb.py,sha256=lMQvZTCMh4tkI9iSQBmZboRCebQ2kRkqHmGMgpFRrk8,11128
-qumulo/rest/snapshot.py,sha256=JpG6UxoXcASzm9ikrbnBjVBKA_0GdV1tvXmvpWUTzqc,12813
+qumulo/rest/snapshot.py,sha256=HtViqFjSOmZS_c3UxsHmY2PHchp5bF5fd9QAGYJqwwE,12759
 qumulo/rest/support.py,sha256=-_y13LELb58WG23trCHB_zwuXwEDI_xqIZV9opfUmwc,3265
 qumulo/rest/time_config.py,sha256=Rg_XhzCjFwXTsa02ha8aEIMj9NFVCYYIaH8vC-lQEW0,1972
 qumulo/rest/tree_delete.py,sha256=t84-SU_E-SycSspgoIIO4UDKGySegDQyArAMWvav9P4,2706
 qumulo/rest/unconfigured_node_operations.py,sha256=lBaY05t5qLWrqBFpmL18a9mj12kd9TN_IMPQ6JRnWEE,1780
 qumulo/rest/upgrade.py,sha256=7jcUzT9tWxINn9B4RP4a1KuWB8DLY57RdE5uwWsUP60,1960
 qumulo/rest/upgrade_v2.py,sha256=P4LAIw378E-08SuXcpx0IlMsSMbOjqWY2zg55Zvlu6Q,2968
 qumulo/rest/upgrade_v3.py,sha256=0yqWSG05NZJhOOKwx5IJf4pwseM7V_Qj2E6xxmAtKfI,1234
 qumulo/rest/users.py,sha256=HW3SdpGLdo5DaWZCWTdLA4cgCwe8fBYk3tJwwuhKvlQ,4689
 qumulo/rest/version.py,sha256=0HOGMR9tQUMbXLyt94_cUn3s3ppwliRw9pN82YDJivI,1593
 qumulo/rest/web_ui.py,sha256=TnWXaZ0WDf3DAIo2ybj5kjQIVR0kvQFfbJepTf8_7H4,3679
-qumulo_api-6.1.0.1.dist-info/LICENSE,sha256=z8d0m5b2O9McPEK1xHG_dWgUBT6EfBDz6wA0F7xSPTA,11358
-qumulo_api-6.1.0.1.dist-info/METADATA,sha256=DgrCVxycSBAOYsQ4iLzNAujIjruxML5Uy_rQXqGZPjI,3778
-qumulo_api-6.1.0.1.dist-info/NOTICE,sha256=2OJiVEfAyPpI5sXj3vRc_xi4T27O9QtT7r1KVRjASXo,290
-qumulo_api-6.1.0.1.dist-info/WHEEL,sha256=OqRkF0eY5GHssMorFjlbTIq072vpHpF60fIQA6lS9xA,92
-qumulo_api-6.1.0.1.dist-info/entry_points.txt,sha256=Ygm2HVqVPjLgqJ48XZZSycDnmldDk_zXwCn0RVVQj44,68
-qumulo_api-6.1.0.1.dist-info/top_level.txt,sha256=ue_iyvfoYhuoCA8JzeMN3s2qu_G1MMtPwVzG6zsv_vE,7
-qumulo_api-6.1.0.1.dist-info/RECORD,,
+qumulo_api-6.1.1.dist-info/LICENSE,sha256=z8d0m5b2O9McPEK1xHG_dWgUBT6EfBDz6wA0F7xSPTA,11358
+qumulo_api-6.1.1.dist-info/METADATA,sha256=Pvg5gVNPu0--atH3KICx2z_WIEbroeV4rDJik780o7E,3776
+qumulo_api-6.1.1.dist-info/NOTICE,sha256=2OJiVEfAyPpI5sXj3vRc_xi4T27O9QtT7r1KVRjASXo,290
+qumulo_api-6.1.1.dist-info/WHEEL,sha256=OqRkF0eY5GHssMorFjlbTIq072vpHpF60fIQA6lS9xA,92
+qumulo_api-6.1.1.dist-info/entry_points.txt,sha256=Ygm2HVqVPjLgqJ48XZZSycDnmldDk_zXwCn0RVVQj44,68
+qumulo_api-6.1.1.dist-info/top_level.txt,sha256=ue_iyvfoYhuoCA8JzeMN3s2qu_G1MMtPwVzG6zsv_vE,7
+qumulo_api-6.1.1.dist-info/RECORD,,
```

