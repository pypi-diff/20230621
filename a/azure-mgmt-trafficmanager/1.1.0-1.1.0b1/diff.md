# Comparing `tmp/azure-mgmt-trafficmanager-1.1.0.zip` & `tmp/azure-mgmt-trafficmanager-1.1.0b1.zip`

## zipinfo {}

```diff
@@ -1,57 +1,57 @@
-Zip file size: 86805 bytes, number of entries: 55
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/azure_mgmt_trafficmanager.egg-info/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/azure/
--rw-rw-r--  2.0 unx      220 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/MANIFEST.in
--rw-rw-r--  2.0 unx     2195 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/README.md
--rw-rw-r--  2.0 unx     2843 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/setup.py
--rw-rw-r--  2.0 unx     5674 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/CHANGELOG.md
--rw-rw-r--  2.0 unx     1074 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/LICENSE
--rw-rw-r--  2.0 unx       38 b- defN 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/setup.cfg
--rw-rw-r--  2.0 unx      638 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/_meta.json
--rw-rw-r--  2.0 unx     8771 b- defN 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/PKG-INFO
--rw-rw-r--  2.0 unx      124 b- defN 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/azure_mgmt_trafficmanager.egg-info/requires.txt
--rw-rw-r--  2.0 unx        6 b- defN 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/azure_mgmt_trafficmanager.egg-info/top_level.txt
--rw-rw-r--  2.0 unx        1 b- defN 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/azure_mgmt_trafficmanager.egg-info/not-zip-safe
--rw-rw-r--  2.0 unx        1 b- defN 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/azure_mgmt_trafficmanager.egg-info/dependency_links.txt
--rw-rw-r--  2.0 unx     2052 b- defN 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/azure_mgmt_trafficmanager.egg-info/SOURCES.txt
--rw-rw-r--  2.0 unx     8771 b- defN 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/azure_mgmt_trafficmanager.egg-info/PKG-INFO
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/
--rw-rw-r--  2.0 unx       65 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/
--rw-rw-r--  2.0 unx       65 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/models/
--rw-rw-r--  2.0 unx      931 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/__init__.py
--rw-rw-r--  2.0 unx     1302 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_vendor.py
--rw-rw-r--  2.0 unx     1530 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_patch.py
--rw-rw-r--  2.0 unx     5308 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_traffic_manager_management_client.py
--rw-rw-r--  2.0 unx    78836 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_serialization.py
--rw-rw-r--  2.0 unx     3517 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_configuration.py
--rw-rw-r--  2.0 unx      486 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_version.py
--rw-rw-r--  2.0 unx       26 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/py.typed
--rw-rw-r--  2.0 unx     1210 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/__init__.py
--rw-rw-r--  2.0 unx    12115 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_traffic_manager_user_metrics_keys_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_patch.py
--rw-rw-r--  2.0 unx     7795 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_heat_map_operations.py
--rw-rw-r--  2.0 unx    31247 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_endpoints_operations.py
--rw-rw-r--  2.0 unx     5117 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_geographic_hierarchies_operations.py
--rw-rw-r--  2.0 unx    49345 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_profiles_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 02:45 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/
--rw-rw-r--  2.0 unx      878 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/__init__.py
--rw-rw-r--  2.0 unx     1530 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/_patch.py
--rw-rw-r--  2.0 unx     5460 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/_traffic_manager_management_client.py
--rw-rw-r--  2.0 unx     3565 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/_configuration.py
--rw-rw-r--  2.0 unx     1210 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/__init__.py
--rw-rw-r--  2.0 unx     8930 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_traffic_manager_user_metrics_keys_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     5848 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_heat_map_operations.py
--rw-rw-r--  2.0 unx    24208 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_endpoints_operations.py
--rw-rw-r--  2.0 unx     4367 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_geographic_hierarchies_operations.py
--rw-rw-r--  2.0 unx    39123 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_profiles_operations.py
--rw-rw-r--  2.0 unx     3231 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/models/_traffic_manager_management_client_enums.py
--rw-rw-r--  2.0 unx     3383 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/models/_patch.py
--rw-rw-r--  2.0 unx    54381 b- defN 23-Jun-21 02:44 azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/models/_models_py3.py
-55 files, 389439 bytes uncompressed, 74593 bytes compressed:  80.8%
+Zip file size: 86229 bytes, number of entries: 55
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/azure/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/azure_mgmt_trafficmanager.egg-info/
+-rw-rw-r--  2.0 unx      636 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/_meta.json
+-rw-rw-r--  2.0 unx     1074 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/LICENSE
+-rw-rw-r--  2.0 unx     1381 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/README.md
+-rw-rw-r--  2.0 unx     2835 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/setup.py
+-rw-rw-r--  2.0 unx     7781 b- defN 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/PKG-INFO
+-rw-rw-r--  2.0 unx     5496 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/CHANGELOG.md
+-rw-rw-r--  2.0 unx      220 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/MANIFEST.in
+-rw-rw-r--  2.0 unx       38 b- defN 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/setup.cfg
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/
+-rw-rw-r--  2.0 unx       65 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/
+-rw-rw-r--  2.0 unx       65 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/models/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/
+-rw-rw-r--  2.0 unx      488 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_version.py
+-rw-rw-r--  2.0 unx       26 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/py.typed
+-rw-rw-r--  2.0 unx     3790 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_configuration.py
+-rw-rw-r--  2.0 unx      931 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/__init__.py
+-rw-rw-r--  2.0 unx     1530 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_patch.py
+-rw-rw-r--  2.0 unx    77872 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_serialization.py
+-rw-rw-r--  2.0 unx     1169 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_vendor.py
+-rw-rw-r--  2.0 unx     5292 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_traffic_manager_management_client.py
+-rw-rw-r--  2.0 unx     3383 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/models/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/models/_patch.py
+-rw-rw-r--  2.0 unx    54039 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/models/_models_py3.py
+-rw-rw-r--  2.0 unx     3199 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/models/_traffic_manager_management_client_enums.py
+-rw-rw-r--  2.0 unx     7865 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_heat_map_operations.py
+-rw-rw-r--  2.0 unx    42897 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_profiles_operations.py
+-rw-rw-r--  2.0 unx     1210 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_patch.py
+-rw-rw-r--  2.0 unx    31721 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_endpoints_operations.py
+-rw-rw-r--  2.0 unx    12555 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_traffic_manager_user_metrics_keys_operations.py
+-rw-rw-r--  2.0 unx     5417 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_geographic_hierarchies_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/
+-rw-rw-r--  2.0 unx     3838 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/_configuration.py
+-rw-rw-r--  2.0 unx      878 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/__init__.py
+-rw-rw-r--  2.0 unx     1530 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/_patch.py
+-rw-rw-r--  2.0 unx     5439 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/_traffic_manager_management_client.py
+-rw-rw-r--  2.0 unx     5870 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_heat_map_operations.py
+-rw-rw-r--  2.0 unx    33603 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_profiles_operations.py
+-rw-rw-r--  2.0 unx     1210 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    24490 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_endpoints_operations.py
+-rw-rw-r--  2.0 unx     9226 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_traffic_manager_user_metrics_keys_operations.py
+-rw-rw-r--  2.0 unx     4619 b- defN 22-Nov-25 02:05 azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_geographic_hierarchies_operations.py
+-rw-rw-r--  2.0 unx     2052 b- defN 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/azure_mgmt_trafficmanager.egg-info/SOURCES.txt
+-rw-rw-r--  2.0 unx        1 b- defN 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/azure_mgmt_trafficmanager.egg-info/dependency_links.txt
+-rw-rw-r--  2.0 unx     7781 b- defN 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/azure_mgmt_trafficmanager.egg-info/PKG-INFO
+-rw-rw-r--  2.0 unx        1 b- defN 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/azure_mgmt_trafficmanager.egg-info/not-zip-safe
+-rw-rw-r--  2.0 unx      116 b- defN 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/azure_mgmt_trafficmanager.egg-info/requires.txt
+-rw-rw-r--  2.0 unx        6 b- defN 22-Nov-25 02:06 azure-mgmt-trafficmanager-1.1.0b1/azure_mgmt_trafficmanager.egg-info/top_level.txt
+55 files, 375657 bytes uncompressed, 73797 bytes compressed:  80.4%
```

## zipnote {}

```diff
@@ -1,166 +1,166 @@
-Filename: azure-mgmt-trafficmanager-1.1.0/
+Filename: azure-mgmt-trafficmanager-1.1.0b1/
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure_mgmt_trafficmanager.egg-info/
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure_mgmt_trafficmanager.egg-info/
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/MANIFEST.in
+Filename: azure-mgmt-trafficmanager-1.1.0b1/_meta.json
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/README.md
+Filename: azure-mgmt-trafficmanager-1.1.0b1/LICENSE
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/setup.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/README.md
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/CHANGELOG.md
+Filename: azure-mgmt-trafficmanager-1.1.0b1/setup.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/LICENSE
+Filename: azure-mgmt-trafficmanager-1.1.0b1/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/setup.cfg
+Filename: azure-mgmt-trafficmanager-1.1.0b1/CHANGELOG.md
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/_meta.json
+Filename: azure-mgmt-trafficmanager-1.1.0b1/MANIFEST.in
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/PKG-INFO
+Filename: azure-mgmt-trafficmanager-1.1.0b1/setup.cfg
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure_mgmt_trafficmanager.egg-info/requires.txt
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure_mgmt_trafficmanager.egg-info/top_level.txt
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/__init__.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure_mgmt_trafficmanager.egg-info/not-zip-safe
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure_mgmt_trafficmanager.egg-info/dependency_links.txt
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/__init__.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure_mgmt_trafficmanager.egg-info/SOURCES.txt
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/models/
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure_mgmt_trafficmanager.egg-info/PKG-INFO
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/__init__.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_version.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/py.typed
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/__init__.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/__init__.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_patch.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/models/
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_serialization.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/__init__.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_vendor.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_traffic_manager_management_client.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_patch.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_traffic_manager_management_client.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_serialization.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_configuration.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/models/_traffic_manager_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_version.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_heat_map_operations.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/py.typed
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_profiles_operations.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/__init__.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_traffic_manager_user_metrics_keys_operations.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_patch.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_endpoints_operations.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_heat_map_operations.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_traffic_manager_user_metrics_keys_operations.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_endpoints_operations.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_geographic_hierarchies_operations.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_geographic_hierarchies_operations.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_profiles_operations.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/__init__.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/_patch.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/_traffic_manager_management_client.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/_traffic_manager_management_client.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_heat_map_operations.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/_configuration.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_profiles_operations.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/__init__.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_traffic_manager_user_metrics_keys_operations.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_patch.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_endpoints_operations.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_heat_map_operations.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_traffic_manager_user_metrics_keys_operations.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_endpoints_operations.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_geographic_hierarchies_operations.py
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_geographic_hierarchies_operations.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure_mgmt_trafficmanager.egg-info/SOURCES.txt
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_profiles_operations.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure_mgmt_trafficmanager.egg-info/dependency_links.txt
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/models/_traffic_manager_management_client_enums.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure_mgmt_trafficmanager.egg-info/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/models/__init__.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure_mgmt_trafficmanager.egg-info/not-zip-safe
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/models/_patch.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure_mgmt_trafficmanager.egg-info/requires.txt
 Comment: 
 
-Filename: azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/models/_models_py3.py
+Filename: azure-mgmt-trafficmanager-1.1.0b1/azure_mgmt_trafficmanager.egg-info/top_level.txt
 Comment: 
 
 Zip file comment:
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/setup.py` & `azure-mgmt-trafficmanager-1.1.0b1/setup.py`

 * *Files 1% similar despite different names*

```diff
@@ -66,14 +66,14 @@
         'azure.mgmt',
     ]),
     include_package_data=True,
     package_data={
         'pytyped': ['py.typed'],
     },
     install_requires=[
-        "isodate<1.0.0,>=0.6.1",
+        "msrest>=0.7.1",
         "azure-common~=1.1",
         "azure-mgmt-core>=1.3.2,<2.0.0",
         "typing-extensions>=4.3.0; python_version<'3.8.0'",
     ],
     python_requires=">=3.7"
 )
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/CHANGELOG.md` & `azure-mgmt-trafficmanager-1.1.0b1/CHANGELOG.md`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,9 @@
 # Release History
 
-## 1.1.0 (2023-06-16)
-
-### Features Added
-
-  - Added operation ProfilesOperations.check_traffic_manager_name_availability_v2
-  - Model Endpoint has a new parameter always_serve
-
 ## 1.1.0b1 (2022-11-17)
 
 ### Features Added
 
   - Model Endpoint has a new parameter always_serve
 
 ## 1.0.0 (2022-01-19)
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/LICENSE` & `azure-mgmt-trafficmanager-1.1.0b1/LICENSE`

 * *Files identical despite different names*

## Comparing `azure-mgmt-trafficmanager-1.1.0/_meta.json` & `azure-mgmt-trafficmanager-1.1.0b1/_meta.json`

 * *Files 7% similar despite different names*

### Pretty-printed

 * *Similarity: 0.7777777777777777%*

 * *Differences: {"'autorest_command'": "'autorest specification/trafficmanager/resource-manager/readme.md "*

 * *                       '--generate-sample=True --include-x-ms-examples-original-file=True --python '*

 * *                       '--python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk '*

 * *                       '--use=@autorest/python@6.2.7 --use=@autorest/modelerfour@4.24.3 '*

 * *                       "--version=3.9.2 --version-tolerant=False'",*

 * * "'commit'": "'b32e1896f30e6ea155449cb49719a6286e32b961'",*

 * * "'use'": "{ […]*

```diff
@@ -1,11 +1,11 @@
 {
     "autorest": "3.9.2",
-    "autorest_command": "autorest specification/trafficmanager/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.4.12 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
-    "commit": "4f4073bdb028bc84bc3e6405c1cbaf8e89b83caf",
+    "autorest_command": "autorest specification/trafficmanager/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.2.7 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
+    "commit": "b32e1896f30e6ea155449cb49719a6286e32b961",
     "readme": "specification/trafficmanager/resource-manager/readme.md",
     "repository_url": "https://github.com/Azure/azure-rest-api-specs",
     "use": [
-        "@autorest/python@6.4.12",
+        "@autorest/python@6.2.7",
         "@autorest/modelerfour@4.24.3"
     ]
 }
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/PKG-INFO` & `azure-mgmt-trafficmanager-1.1.0b1/PKG-INFO`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-trafficmanager
-Version: 1.1.0
+Version: 1.1.0b1
 Summary: Microsoft Azure Traffic Manager Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
 Classifier: Development Status :: 4 - Beta
@@ -27,79 +27,36 @@
 This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
 
-## Getting started
+# Usage
 
-### Prerequisites
 
-- Python 3.7+ is required to use this package.
-- [Azure subscription](https://azure.microsoft.com/free/)
+To learn how to use this package, see the [quickstart guide](https://aka.ms/azsdk/python/mgmt)
+ 
+For docs and references, see [Python SDK References](https://docs.microsoft.com/python/api/overview/azure/)
+Code samples for this package can be found at [Traffic Manager Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com.
+Additional code samples for different Azure services are available at [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
 
-### Install the package
 
-```bash
-pip install azure-mgmt-trafficmanager
-pip install azure-identity
-```
-
-### Authentication
-
-By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
-
-- `AZURE_CLIENT_ID` for Azure client ID.
-- `AZURE_TENANT_ID` for Azure tenant ID.
-- `AZURE_CLIENT_SECRET` for Azure client secret.
-
-In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
-
-With above configuration, client can be authenticated by following code:
-
-```python
-from azure.identity import DefaultAzureCredential
-from azure.mgmt.trafficmanager import TrafficManagerManagementClient
-import os
-
-sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
-client = TrafficManagerManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
-```
-
-## Examples
-
-Code samples for this package can be found at:
-- [Search Traffic Manager Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
-- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
-
-
-## Troubleshooting
-
-## Next steps
-
-## Provide Feedback
+# Provide Feedback
 
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-trafficmanager%2FREADME.png)
 
 
 # Release History
 
-## 1.1.0 (2023-06-16)
-
-### Features Added
-
-  - Added operation ProfilesOperations.check_traffic_manager_name_availability_v2
-  - Model Endpoint has a new parameter always_serve
-
 ## 1.1.0b1 (2022-11-17)
 
 ### Features Added
 
   - Model Endpoint has a new parameter always_serve
 
 ## 1.0.0 (2022-01-19)
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure_mgmt_trafficmanager.egg-info/SOURCES.txt` & `azure-mgmt-trafficmanager-1.1.0b1/azure_mgmt_trafficmanager.egg-info/SOURCES.txt`

 * *Files identical despite different names*

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure_mgmt_trafficmanager.egg-info/PKG-INFO` & `azure-mgmt-trafficmanager-1.1.0b1/azure_mgmt_trafficmanager.egg-info/PKG-INFO`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-trafficmanager
-Version: 1.1.0
+Version: 1.1.0b1
 Summary: Microsoft Azure Traffic Manager Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
 Classifier: Development Status :: 4 - Beta
@@ -27,79 +27,36 @@
 This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
 
-## Getting started
+# Usage
 
-### Prerequisites
 
-- Python 3.7+ is required to use this package.
-- [Azure subscription](https://azure.microsoft.com/free/)
+To learn how to use this package, see the [quickstart guide](https://aka.ms/azsdk/python/mgmt)
+ 
+For docs and references, see [Python SDK References](https://docs.microsoft.com/python/api/overview/azure/)
+Code samples for this package can be found at [Traffic Manager Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com.
+Additional code samples for different Azure services are available at [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
 
-### Install the package
 
-```bash
-pip install azure-mgmt-trafficmanager
-pip install azure-identity
-```
-
-### Authentication
-
-By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
-
-- `AZURE_CLIENT_ID` for Azure client ID.
-- `AZURE_TENANT_ID` for Azure tenant ID.
-- `AZURE_CLIENT_SECRET` for Azure client secret.
-
-In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
-
-With above configuration, client can be authenticated by following code:
-
-```python
-from azure.identity import DefaultAzureCredential
-from azure.mgmt.trafficmanager import TrafficManagerManagementClient
-import os
-
-sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
-client = TrafficManagerManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
-```
-
-## Examples
-
-Code samples for this package can be found at:
-- [Search Traffic Manager Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
-- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
-
-
-## Troubleshooting
-
-## Next steps
-
-## Provide Feedback
+# Provide Feedback
 
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-trafficmanager%2FREADME.png)
 
 
 # Release History
 
-## 1.1.0 (2023-06-16)
-
-### Features Added
-
-  - Added operation ProfilesOperations.check_traffic_manager_name_availability_v2
-  - Model Endpoint has a new parameter always_serve
-
 ## 1.1.0b1 (2022-11-17)
 
 ### Features Added
 
   - Model Endpoint has a new parameter always_serve
 
 ## 1.0.0 (2022-01-19)
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/__init__.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_vendor.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_vendor.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,16 +1,14 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-from typing import List, cast
-
 from azure.core.pipeline.transport import HttpRequest
 
 
 def _convert_request(request, files=None):
     data = request.content if not files else None
     request = HttpRequest(method=request.method, url=request.url, headers=request.headers, data=data)
     if files:
@@ -20,11 +18,10 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            # Need the cast, as for some reasons "split" is typed as list[str | Any]
-            formatted_components = cast(List[str], template.split("/"))
+            formatted_components = template.split("/")
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_patch.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_traffic_manager_management_client.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_traffic_manager_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -45,30 +45,30 @@
      azure.mgmt.trafficmanager.operations.TrafficManagerUserMetricsKeysOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2022-04-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2022-04-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(
         self,
         credential: "TokenCredential",
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = TrafficManagerManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.endpoints = EndpointsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.profiles = ProfilesOperations(self._client, self._config, self._serialize, self._deserialize)
@@ -105,9 +105,9 @@
     def close(self) -> None:
         self._client.close()
 
     def __enter__(self) -> "TrafficManagerManagementClient":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details: Any) -> None:
+    def __exit__(self, *exc_details) -> None:
         self._client.__exit__(*exc_details)
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_serialization.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_serialization.py`

 * *Files 2% similar despite different names*

```diff
@@ -34,47 +34,30 @@
 import email
 from enum import Enum
 import json
 import logging
 import re
 import sys
 import codecs
-from typing import (
-    Dict,
-    Any,
-    cast,
-    Optional,
-    Union,
-    AnyStr,
-    IO,
-    Mapping,
-    Callable,
-    TypeVar,
-    MutableMapping,
-    Type,
-    List,
-    Mapping,
-)
+from typing import Optional, Union, AnyStr, IO, Mapping
 
 try:
     from urllib import quote  # type: ignore
 except ImportError:
     from urllib.parse import quote
 import xml.etree.ElementTree as ET
 
 import isodate  # type: ignore
 
+from typing import Dict, Any, cast
+
 from azure.core.exceptions import DeserializationError, SerializationError, raise_with_traceback
-from azure.core.serialization import NULL as AzureCoreNull
 
 _BOM = codecs.BOM_UTF8.decode(encoding="utf-8")
 
-ModelType = TypeVar("ModelType", bound="Model")
-JSON = MutableMapping[str, Any]
-
 
 class RawDeserializer:
 
     # Accept "text" because we're open minded people...
     JSON_REGEXP = re.compile(r"^(application|text)/([a-z+.]+\+)?json$")
 
     # Name used in context
@@ -290,43 +273,43 @@
     serialization and deserialization.
     """
 
     _subtype_map: Dict[str, Dict[str, Any]] = {}
     _attribute_map: Dict[str, Dict[str, Any]] = {}
     _validation: Dict[str, Dict[str, Any]] = {}
 
-    def __init__(self, **kwargs: Any) -> None:
-        self.additional_properties: Dict[str, Any] = {}
+    def __init__(self, **kwargs):
+        self.additional_properties = {}
         for k in kwargs:
             if k not in self._attribute_map:
                 _LOGGER.warning("%s is not a known attribute of class %s and will be ignored", k, self.__class__)
             elif k in self._validation and self._validation[k].get("readonly", False):
                 _LOGGER.warning("Readonly attribute %s will be ignored in class %s", k, self.__class__)
             else:
                 setattr(self, k, kwargs[k])
 
-    def __eq__(self, other: Any) -> bool:
+    def __eq__(self, other):
         """Compare objects by comparing all attributes."""
         if isinstance(other, self.__class__):
             return self.__dict__ == other.__dict__
         return False
 
-    def __ne__(self, other: Any) -> bool:
+    def __ne__(self, other):
         """Compare objects by comparing all attributes."""
         return not self.__eq__(other)
 
-    def __str__(self) -> str:
+    def __str__(self):
         return str(self.__dict__)
 
     @classmethod
-    def enable_additional_properties_sending(cls) -> None:
+    def enable_additional_properties_sending(cls):
         cls._attribute_map["additional_properties"] = {"key": "", "type": "{object}"}
 
     @classmethod
-    def is_xml_model(cls) -> bool:
+    def is_xml_model(cls):
         try:
             cls._xml_map  # type: ignore
         except AttributeError:
             return False
         return True
 
     @classmethod
@@ -335,35 +318,30 @@
         try:
             xml_map = cls._xml_map  # type: ignore
         except AttributeError:
             xml_map = {}
 
         return _create_xml_node(xml_map.get("name", cls.__name__), xml_map.get("prefix", None), xml_map.get("ns", None))
 
-    def serialize(self, keep_readonly: bool = False, **kwargs: Any) -> JSON:
+    def serialize(self, keep_readonly=False, **kwargs):
         """Return the JSON that would be sent to azure from this model.
 
         This is an alias to `as_dict(full_restapi_key_transformer, keep_readonly=False)`.
 
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param bool keep_readonly: If you want to serialize the readonly attributes
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
         return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)
 
-    def as_dict(
-        self,
-        keep_readonly: bool = True,
-        key_transformer: Callable[[str, Dict[str, Any], Any], Any] = attribute_transformer,
-        **kwargs: Any
-    ) -> JSON:
-        """Return a dict that can be serialized using json.dump.
+    def as_dict(self, keep_readonly=True, key_transformer=attribute_transformer, **kwargs):
+        """Return a dict that can be JSONify using json.dump.
 
         Advanced usage might optionally use a callback as parameter:
 
         .. code::python
 
             def my_key_transformer(key, attr_desc, value):
                 return key
@@ -402,46 +380,41 @@
                 raise ValueError("Not Autorest generated code")
         except Exception:
             # Assume it's not Autorest generated (tests?). Add ourselves as dependencies.
             client_models = {cls.__name__: cls}
         return client_models
 
     @classmethod
-    def deserialize(cls: Type[ModelType], data: Any, content_type: Optional[str] = None) -> ModelType:
+    def deserialize(cls, data, content_type=None):
         """Parse a str using the RestAPI syntax and return a model.
 
         :param str data: A str using RestAPI structure. JSON by default.
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
         return deserializer(cls.__name__, data, content_type=content_type)
 
     @classmethod
-    def from_dict(
-        cls: Type[ModelType],
-        data: Any,
-        key_extractors: Optional[Callable[[str, Dict[str, Any], Any], Any]] = None,
-        content_type: Optional[str] = None,
-    ) -> ModelType:
+    def from_dict(cls, data, key_extractors=None, content_type=None):
         """Parse a dict using given key extractor return a model.
 
         By default consider key
         extractors (rest_key_case_insensitive_extractor, attribute_key_case_insensitive_extractor
         and last_rest_key_case_insensitive_extractor)
 
         :param dict data: A dict using RestAPI structure
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
-        deserializer.key_extractors = (  # type: ignore
-            [  # type: ignore
+        deserializer.key_extractors = (
+            [
                 attribute_key_case_insensitive_extractor,
                 rest_key_case_insensitive_extractor,
                 last_rest_key_case_insensitive_extractor,
             ]
             if key_extractors is None
             else key_extractors
         )
@@ -541,15 +514,15 @@
         "min_items": lambda x, y: len(x) < y,
         "max_items": lambda x, y: len(x) > y,
         "pattern": lambda x, y: not re.match(y, x, re.UNICODE),
         "unique": lambda x, y: len(x) != len(set(x)),
         "multiple": lambda x, y: x % y != 0,
     }
 
-    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
+    def __init__(self, classes=None):
         self.serialize_type = {
             "iso-8601": Serializer.serialize_iso,
             "rfc-1123": Serializer.serialize_rfc,
             "unix-time": Serializer.serialize_unix,
             "duration": Serializer.serialize_duration,
             "date": Serializer.serialize_date,
             "time": Serializer.serialize_time,
@@ -557,15 +530,15 @@
             "long": Serializer.serialize_long,
             "bytearray": Serializer.serialize_bytearray,
             "base64": Serializer.serialize_base64,
             "object": self.serialize_object,
             "[]": self.serialize_iter,
             "{}": self.serialize_dict,
         }
-        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
+        self.dependencies = dict(classes) if classes else {}
         self.key_transformer = full_restapi_key_transformer
         self.client_side_validation = True
 
     def _serialize(self, target_obj, data_type=None, **kwargs):
         """Serialize data into a string according to type.
 
         :param target_obj: The data to be serialized.
@@ -625,15 +598,15 @@
                         xml_desc = attr_desc.get("xml", {})
                         xml_name = xml_desc.get("name", attr_desc["key"])
                         xml_prefix = xml_desc.get("prefix", None)
                         xml_ns = xml_desc.get("ns", None)
                         if xml_desc.get("attr", False):
                             if xml_ns:
                                 ET.register_namespace(xml_prefix, xml_ns)
-                                xml_name = "{{{}}}{}".format(xml_ns, xml_name)
+                                xml_name = "{}{}".format(xml_ns, xml_name)
                             serialized.set(xml_name, new_attr)  # type: ignore
                             continue
                         if xml_desc.get("text", False):
                             serialized.text = new_attr  # type: ignore
                             continue
                         if isinstance(new_attr, list):
                             serialized.extend(new_attr)  # type: ignore
@@ -649,15 +622,16 @@
                         else:  # That's a basic type
                             # Integrate namespace if necessary
                             local_node = _create_xml_node(xml_name, xml_prefix, xml_ns)
                             local_node.text = unicode_str(new_attr)
                             serialized.append(local_node)  # type: ignore
                     else:  # JSON
                         for k in reversed(keys):  # type: ignore
-                            new_attr = {k: new_attr}
+                            unflattened = {k: new_attr}
+                            new_attr = unflattened
 
                         _new_attr = new_attr
                         _serialized = serialized
                         for k in keys:  # type: ignore
                             if k not in _serialized:
                                 _serialized.update(_new_attr)  # type: ignore
                             _new_attr = _new_attr[k]  # type: ignore
@@ -678,16 +652,16 @@
         :param str data_type: The type to be serialized from.
         :rtype: dict
         :raises: SerializationError if serialization fails.
         :raises: ValueError if data is None
         """
 
         # Just in case this is a dict
-        internal_data_type_str = data_type.strip("[]{}")
-        internal_data_type = self.dependencies.get(internal_data_type_str, None)
+        internal_data_type = data_type.strip("[]{}")
+        internal_data_type = self.dependencies.get(internal_data_type, None)
         try:
             is_xml_model_serialization = kwargs["is_xml"]
         except KeyError:
             if internal_data_type and issubclass(internal_data_type, Model):
                 is_xml_model_serialization = kwargs.setdefault("is_xml", internal_data_type.is_xml_model())
             else:
                 is_xml_model_serialization = False
@@ -799,16 +773,14 @@
         :raises: ValueError if data is None
         :raises: SerializationError if serialization fails.
         """
         if data is None:
             raise ValueError("No value for given attribute")
 
         try:
-            if data is AzureCoreNull:
-                return None
             if data_type in self.basic_types.values():
                 return self.serialize_basic(data, data_type, **kwargs)
 
             elif data_type in self.serialize_type:
                 return self.serialize_type[data_type](data, **kwargs)
 
             # If dependencies is empty, try with current data class
@@ -1185,16 +1157,15 @@
 
 
 def rest_key_extractor(attr, attr_desc, data):
     key = attr_desc["key"]
     working_data = data
 
     while "." in key:
-        # Need the cast, as for some reasons "split" is typed as list[str | Any]
-        dict_keys = cast(List[str], _FLATTEN.split(key))
+        dict_keys = _FLATTEN.split(key)
         if len(dict_keys) == 1:
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = working_data.get(working_key, data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
@@ -1267,15 +1238,15 @@
     :rtype: tuple
     :returns: A tuple XML name + namespace dict
     """
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
     xml_name = internal_type_xml_map.get("name", internal_type.__name__)
     xml_ns = internal_type_xml_map.get("ns", None)
     if xml_ns:
-        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
+        xml_name = "{}{}".format(xml_ns, xml_name)
     return xml_name
 
 
 def xml_key_extractor(attr, attr_desc, data):
     if isinstance(data, dict):
         return None
 
@@ -1291,15 +1262,15 @@
     is_wrapped = xml_desc.get("wrapped", False)
     internal_type = attr_desc.get("internalType", None)
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
 
     # Integrate namespace if necessary
     xml_ns = xml_desc.get("ns", internal_type_xml_map.get("ns", None))
     if xml_ns:
-        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
+        xml_name = "{}{}".format(xml_ns, xml_name)
 
     # If it's an attribute, that's simple
     if xml_desc.get("attr", False):
         return data.get(xml_name)
 
     # If it's x-ms-text, that's simple too
     if xml_desc.get("text", False):
@@ -1357,15 +1328,15 @@
     :ivar list key_extractors: Ordered list of extractors to be used by this deserializer.
     """
 
     basic_types = {str: "str", int: "int", bool: "bool", float: "float"}
 
     valid_date = re.compile(r"\d{4}[-]\d{2}[-]\d{2}T\d{2}:\d{2}:\d{2}" r"\.?\d*Z?[-+]?[\d{2}]?:?[\d{2}]?")
 
-    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
+    def __init__(self, classes=None):
         self.deserialize_type = {
             "iso-8601": Deserializer.deserialize_iso,
             "rfc-1123": Deserializer.deserialize_rfc,
             "unix-time": Deserializer.deserialize_unix,
             "duration": Deserializer.deserialize_duration,
             "date": Deserializer.deserialize_date,
             "time": Deserializer.deserialize_time,
@@ -1377,15 +1348,15 @@
             "[]": self.deserialize_iter,
             "{}": self.deserialize_dict,
         }
         self.deserialize_expected_types = {
             "duration": (isodate.Duration, datetime.timedelta),
             "iso-8601": (datetime.datetime),
         }
-        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
+        self.dependencies = dict(classes) if classes else {}
         self.key_extractors = [rest_key_extractor, xml_key_extractor]
         # Additional properties only works if the "rest_key_extractor" is used to
         # extract the keys. Making it to work whatever the key extractor is too much
         # complicated, with no real scenario for now.
         # So adding a flag to disable additional properties detection. This flag should be
         # used if your expect the deserialization to NOT come from a JSON REST syntax.
         # Otherwise, result are unexpected
@@ -1496,40 +1467,40 @@
 
     def _classify_target(self, target, data):
         """Check to see whether the deserialization target object can
         be classified into a subclass.
         Once classification has been determined, initialize object.
 
         :param str target: The target object type to deserialize to.
-        :param str/dict data: The response data to deserialize.
+        :param str/dict data: The response data to deseralize.
         """
         if target is None:
             return None, None
 
         if isinstance(target, basestring):
             try:
                 target = self.dependencies[target]
             except KeyError:
                 return target, target
 
         try:
             target = target._classify(data, self.dependencies)
         except AttributeError:
             pass  # Target is not a Model, no classify
-        return target, target.__class__.__name__  # type: ignore
+        return target, target.__class__.__name__
 
     def failsafe_deserialize(self, target_obj, data, content_type=None):
         """Ignores any errors encountered in deserialization,
         and falls back to not deserializing the object. Recommended
         for use in error deserialization, as we want to return the
         HttpResponseError to users, and not have them deal with
         a deserialization error.
 
         :param str target_obj: The target object type to deserialize to.
-        :param str/dict data: The response data to deserialize.
+        :param str/dict data: The response data to deseralize.
         :param str content_type: Swagger "produces" if available.
         """
         try:
             return self(target_obj, data, content_type=content_type)
         except:
             _LOGGER.debug(
                 "Ran into a deserialization error. Ignoring since this is failsafe deserialization", exc_info=True
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/_configuration.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/_configuration.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class TrafficManagerManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for TrafficManagerManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-04-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2022-04-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(TrafficManagerManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2022-04-01")
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop("api_version", "2022-04-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/__init__.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_traffic_manager_user_metrics_keys_operations.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_traffic_manager_user_metrics_keys_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -23,26 +24,32 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-04-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Network/trafficManagerUserMetricsKeys/default",
     )  # pylint: disable=line-too-long
@@ -61,15 +68,17 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_or_update_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-04-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Network/trafficManagerUserMetricsKeys/default",
     )  # pylint: disable=line-too-long
@@ -88,15 +97,17 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-04-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Network/trafficManagerUserMetricsKeys/default",
     )  # pylint: disable=line-too-long
@@ -150,30 +161,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.UserMetricsModel] = kwargs.pop("cls", None)
 
         request = build_get_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -205,30 +217,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.UserMetricsModel] = kwargs.pop("cls", None)
 
         request = build_create_or_update_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -260,30 +273,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.DeleteOperationResult] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_patch.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_heat_map_operations.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_heat_map_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -48,15 +48,17 @@
     bot_right: Optional[List[float]] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
     heat_map_type: Literal["default"] = kwargs.pop("heat_map_type", "default")
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-04-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}/heatMaps/{heatMapType}",
     )  # pylint: disable=line-too-long
@@ -141,15 +143,17 @@
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         heat_map_type: Literal["default"] = kwargs.pop("heat_map_type", "default")
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.HeatMapModel] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             subscription_id=self._config.subscription_id,
             top_left=top_left,
@@ -159,17 +163,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_endpoints_operations.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_endpoints_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from io import IOBase
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,14 +24,18 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -42,15 +46,17 @@
     endpoint_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-04-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}/{endpointType}/{endpointName}",
@@ -85,15 +91,17 @@
     endpoint_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-04-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}/{endpointType}/{endpointName}",
     )  # pylint: disable=line-too-long
@@ -125,15 +133,17 @@
     endpoint_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-04-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}/{endpointType}/{endpointName}",
@@ -168,15 +178,17 @@
     endpoint_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-04-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}/{endpointType}/{endpointName}",
     )  # pylint: disable=line-too-long
@@ -311,15 +323,15 @@
         :type profile_name: str
         :param endpoint_type: The type of the Traffic Manager endpoint to be updated. Known values are:
          "AzureEndpoints", "ExternalEndpoints", and "NestedEndpoints". Required.
         :type endpoint_type: str or ~azure.mgmt.trafficmanager.models.EndpointType
         :param endpoint_name: The name of the Traffic Manager endpoint to be updated. Required.
         :type endpoint_name: str
         :param parameters: The Traffic Manager endpoint parameters supplied to the Update operation. Is
-         either a Endpoint type or a IO type. Required.
+         either a model type or a IO type. Required.
         :type parameters: ~azure.mgmt.trafficmanager.models.Endpoint or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Endpoint or the result of cls(response)
         :rtype: ~azure.mgmt.trafficmanager.models.Endpoint
@@ -332,22 +344,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Endpoint] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IOBase, bytes)):
+        if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Endpoint")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
@@ -361,17 +375,16 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -420,15 +433,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.Endpoint] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             endpoint_type=endpoint_type,
             endpoint_name=endpoint_name,
@@ -437,17 +452,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -557,15 +571,15 @@
         :param endpoint_type: The type of the Traffic Manager endpoint to be created or updated. Known
          values are: "AzureEndpoints", "ExternalEndpoints", and "NestedEndpoints". Required.
         :type endpoint_type: str or ~azure.mgmt.trafficmanager.models.EndpointType
         :param endpoint_name: The name of the Traffic Manager endpoint to be created or updated.
          Required.
         :type endpoint_name: str
         :param parameters: The Traffic Manager endpoint parameters supplied to the CreateOrUpdate
-         operation. Is either a Endpoint type or a IO type. Required.
+         operation. Is either a model type or a IO type. Required.
         :type parameters: ~azure.mgmt.trafficmanager.models.Endpoint or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Endpoint or the result of cls(response)
         :rtype: ~azure.mgmt.trafficmanager.models.Endpoint
@@ -578,22 +592,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Endpoint] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IOBase, bytes)):
+        if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Endpoint")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
@@ -607,17 +623,16 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -670,15 +685,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[Optional[_models.DeleteOperationResult]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             endpoint_type=endpoint_type,
             endpoint_name=endpoint_name,
@@ -687,17 +704,16 @@
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_geographic_hierarchies_operations.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_geographic_hierarchies_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -23,26 +24,32 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_default_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-04-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.Network/trafficManagerGeographicHierarchies/default")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -88,29 +95,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.TrafficManagerGeographicHierarchy] = kwargs.pop("cls", None)
 
         request = build_get_default_request(
             api_version=api_version,
             template_url=self.get_default.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/operations/_profiles_operations.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_profiles_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from io import IOBase
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,26 +26,32 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_check_traffic_manager_relative_dns_name_availability_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-04-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.Network/checkTrafficManagerNameAvailability")
 
     # Construct parameters
@@ -55,49 +61,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_check_traffic_manager_name_availability_v2_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/providers/Microsoft.Network/checkTrafficManagerNameAvailabilityV2",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
-
-
 def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-04-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles",
     )  # pylint: disable=line-too-long
@@ -119,15 +97,17 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-04-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Network/trafficmanagerprofiles"
     )
     path_format_arguments = {
@@ -145,15 +125,17 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(resource_group_name: str, profile_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-04-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}",
     )  # pylint: disable=line-too-long
@@ -178,15 +160,17 @@
 
 def build_create_or_update_request(
     resource_group_name: str, profile_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-04-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}",
@@ -214,15 +198,17 @@
 
 def build_delete_request(
     resource_group_name: str, profile_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-04-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}",
     )  # pylint: disable=line-too-long
@@ -247,15 +233,17 @@
 
 def build_update_request(
     resource_group_name: str, profile_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-04-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}",
@@ -344,16 +332,15 @@
     @distributed_trace
     def check_traffic_manager_relative_dns_name_availability(
         self, parameters: Union[_models.CheckTrafficManagerRelativeDnsNameAvailabilityParameters, IO], **kwargs: Any
     ) -> _models.TrafficManagerNameAvailability:
         """Checks the availability of a Traffic Manager Relative DNS name.
 
         :param parameters: The Traffic Manager name parameters supplied to the
-         CheckTrafficManagerNameAvailability operation. Is either a
-         CheckTrafficManagerRelativeDnsNameAvailabilityParameters type or a IO type. Required.
+         CheckTrafficManagerNameAvailability operation. Is either a model type or a IO type. Required.
         :type parameters:
          ~azure.mgmt.trafficmanager.models.CheckTrafficManagerRelativeDnsNameAvailabilityParameters or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -368,22 +355,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.TrafficManagerNameAvailability] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IOBase, bytes)):
+        if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "CheckTrafficManagerRelativeDnsNameAvailabilityParameters")
 
         request = build_check_traffic_manager_relative_dns_name_availability_request(
             api_version=api_version,
             content_type=content_type,
@@ -392,17 +381,16 @@
             template_url=self.check_traffic_manager_relative_dns_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -414,133 +402,14 @@
 
         return deserialized
 
     check_traffic_manager_relative_dns_name_availability.metadata = {
         "url": "/providers/Microsoft.Network/checkTrafficManagerNameAvailability"
     }
 
-    @overload
-    def check_traffic_manager_name_availability_v2(
-        self,
-        parameters: _models.CheckTrafficManagerRelativeDnsNameAvailabilityParameters,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> _models.TrafficManagerNameAvailability:
-        """Checks the availability of a Traffic Manager Relative DNS name.
-
-        :param parameters: The Traffic Manager name parameters supplied to the
-         CheckTrafficManagerNameAvailability operation. Required.
-        :type parameters:
-         ~azure.mgmt.trafficmanager.models.CheckTrafficManagerRelativeDnsNameAvailabilityParameters
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: TrafficManagerNameAvailability or the result of cls(response)
-        :rtype: ~azure.mgmt.trafficmanager.models.TrafficManagerNameAvailability
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    def check_traffic_manager_name_availability_v2(
-        self, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
-    ) -> _models.TrafficManagerNameAvailability:
-        """Checks the availability of a Traffic Manager Relative DNS name.
-
-        :param parameters: The Traffic Manager name parameters supplied to the
-         CheckTrafficManagerNameAvailability operation. Required.
-        :type parameters: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: TrafficManagerNameAvailability or the result of cls(response)
-        :rtype: ~azure.mgmt.trafficmanager.models.TrafficManagerNameAvailability
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @distributed_trace
-    def check_traffic_manager_name_availability_v2(
-        self, parameters: Union[_models.CheckTrafficManagerRelativeDnsNameAvailabilityParameters, IO], **kwargs: Any
-    ) -> _models.TrafficManagerNameAvailability:
-        """Checks the availability of a Traffic Manager Relative DNS name.
-
-        :param parameters: The Traffic Manager name parameters supplied to the
-         CheckTrafficManagerNameAvailability operation. Is either a
-         CheckTrafficManagerRelativeDnsNameAvailabilityParameters type or a IO type. Required.
-        :type parameters:
-         ~azure.mgmt.trafficmanager.models.CheckTrafficManagerRelativeDnsNameAvailabilityParameters or
-         IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: TrafficManagerNameAvailability or the result of cls(response)
-        :rtype: ~azure.mgmt.trafficmanager.models.TrafficManagerNameAvailability
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.TrafficManagerNameAvailability] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(parameters, (IOBase, bytes)):
-            _content = parameters
-        else:
-            _json = self._serialize.body(parameters, "CheckTrafficManagerRelativeDnsNameAvailabilityParameters")
-
-        request = build_check_traffic_manager_name_availability_v2_request(
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self.check_traffic_manager_name_availability_v2.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("TrafficManagerNameAvailability", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
-
-    check_traffic_manager_name_availability_v2.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Network/checkTrafficManagerNameAvailabilityV2"
-    }
-
     @distributed_trace
     def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.Profile"]:
         """Lists all Traffic Manager profiles within a resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
@@ -548,15 +417,17 @@
         :return: An iterator like instance of either Profile or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.trafficmanager.models.Profile]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.ProfileListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -601,17 +472,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -631,15 +501,17 @@
         :return: An iterator like instance of either Profile or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.trafficmanager.models.Profile]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.ProfileListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -683,17 +555,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -726,32 +597,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.Profile] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -833,15 +705,15 @@
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param profile_name: The name of the Traffic Manager profile. Required.
         :type profile_name: str
         :param parameters: The Traffic Manager profile parameters supplied to the CreateOrUpdate
-         operation. Is either a Profile type or a IO type. Required.
+         operation. Is either a model type or a IO type. Required.
         :type parameters: ~azure.mgmt.trafficmanager.models.Profile or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Profile or the result of cls(response)
         :rtype: ~azure.mgmt.trafficmanager.models.Profile
@@ -854,22 +726,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Profile] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IOBase, bytes)):
+        if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Profile")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
@@ -881,17 +755,16 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -934,32 +807,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[Optional[_models.DeleteOperationResult]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -1043,15 +917,15 @@
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param profile_name: The name of the Traffic Manager profile. Required.
         :type profile_name: str
         :param parameters: The Traffic Manager profile parameters supplied to the Update operation. Is
-         either a Profile type or a IO type. Required.
+         either a model type or a IO type. Required.
         :type parameters: ~azure.mgmt.trafficmanager.models.Profile or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Profile or the result of cls(response)
         :rtype: ~azure.mgmt.trafficmanager.models.Profile
@@ -1064,22 +938,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Profile] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IOBase, bytes)):
+        if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Profile")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
@@ -1091,17 +967,16 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/__init__.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/_patch.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/_traffic_manager_management_client.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/_traffic_manager_management_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -45,30 +45,30 @@
      azure.mgmt.trafficmanager.aio.operations.TrafficManagerUserMetricsKeysOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2022-04-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2022-04-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(
         self,
         credential: "AsyncTokenCredential",
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = TrafficManagerManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.endpoints = EndpointsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.profiles = ProfilesOperations(self._client, self._config, self._serialize, self._deserialize)
@@ -105,9 +105,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "TrafficManagerManagementClient":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details: Any) -> None:
+    async def __aexit__(self, *exc_details) -> None:
         await self._client.__aexit__(*exc_details)
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/_configuration.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/_configuration.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class TrafficManagerManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for TrafficManagerManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-04-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2022-04-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(TrafficManagerManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2022-04-01")
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop("api_version", "2022-04-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/__init__.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_traffic_manager_user_metrics_keys_operations.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_traffic_manager_user_metrics_keys_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -27,14 +28,18 @@
 from ..._vendor import _convert_request
 from ...operations._traffic_manager_user_metrics_keys_operations import (
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class TrafficManagerUserMetricsKeysOperations:
     """
     .. warning::
@@ -70,30 +75,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.UserMetricsModel] = kwargs.pop("cls", None)
 
         request = build_get_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -125,30 +131,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.UserMetricsModel] = kwargs.pop("cls", None)
 
         request = build_create_or_update_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -180,30 +187,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.DeleteOperationResult] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_patch.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_heat_map_operations.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_heat_map_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -93,15 +93,17 @@
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         heat_map_type: Literal["default"] = kwargs.pop("heat_map_type", "default")
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.HeatMapModel] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             subscription_id=self._config.subscription_id,
             top_left=top_left,
@@ -111,17 +113,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_endpoints_operations.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_endpoints_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from io import IOBase
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -29,14 +29,18 @@
 from ...operations._endpoints_operations import (
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_update_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class EndpointsOperations:
     """
     .. warning::
@@ -147,15 +151,15 @@
         :type profile_name: str
         :param endpoint_type: The type of the Traffic Manager endpoint to be updated. Known values are:
          "AzureEndpoints", "ExternalEndpoints", and "NestedEndpoints". Required.
         :type endpoint_type: str or ~azure.mgmt.trafficmanager.models.EndpointType
         :param endpoint_name: The name of the Traffic Manager endpoint to be updated. Required.
         :type endpoint_name: str
         :param parameters: The Traffic Manager endpoint parameters supplied to the Update operation. Is
-         either a Endpoint type or a IO type. Required.
+         either a model type or a IO type. Required.
         :type parameters: ~azure.mgmt.trafficmanager.models.Endpoint or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Endpoint or the result of cls(response)
         :rtype: ~azure.mgmt.trafficmanager.models.Endpoint
@@ -168,22 +172,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Endpoint] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IOBase, bytes)):
+        if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Endpoint")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
@@ -197,17 +203,16 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -256,15 +261,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.Endpoint] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             endpoint_type=endpoint_type,
             endpoint_name=endpoint_name,
@@ -273,17 +280,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -393,15 +399,15 @@
         :param endpoint_type: The type of the Traffic Manager endpoint to be created or updated. Known
          values are: "AzureEndpoints", "ExternalEndpoints", and "NestedEndpoints". Required.
         :type endpoint_type: str or ~azure.mgmt.trafficmanager.models.EndpointType
         :param endpoint_name: The name of the Traffic Manager endpoint to be created or updated.
          Required.
         :type endpoint_name: str
         :param parameters: The Traffic Manager endpoint parameters supplied to the CreateOrUpdate
-         operation. Is either a Endpoint type or a IO type. Required.
+         operation. Is either a model type or a IO type. Required.
         :type parameters: ~azure.mgmt.trafficmanager.models.Endpoint or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Endpoint or the result of cls(response)
         :rtype: ~azure.mgmt.trafficmanager.models.Endpoint
@@ -414,22 +420,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Endpoint] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IOBase, bytes)):
+        if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Endpoint")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
@@ -443,17 +451,16 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -506,15 +513,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[Optional[_models.DeleteOperationResult]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             endpoint_type=endpoint_type,
             endpoint_name=endpoint_name,
@@ -523,17 +532,16 @@
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_geographic_hierarchies_operations.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_geographic_hierarchies_operations.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -23,14 +24,18 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._geographic_hierarchies_operations import build_get_default_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class GeographicHierarchiesOperations:
     """
     .. warning::
@@ -66,29 +71,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.TrafficManagerGeographicHierarchy] = kwargs.pop("cls", None)
 
         request = build_get_default_request(
             api_version=api_version,
             template_url=self.get_default.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/aio/operations/_profiles_operations.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_profiles_operations.py`

 * *Files 13% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from io import IOBase
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,24 +26,27 @@
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._profiles_operations import (
-    build_check_traffic_manager_name_availability_v2_request,
     build_check_traffic_manager_relative_dns_name_availability_request,
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_list_by_resource_group_request,
     build_list_by_subscription_request,
     build_update_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ProfilesOperations:
     """
     .. warning::
@@ -107,16 +110,15 @@
     @distributed_trace_async
     async def check_traffic_manager_relative_dns_name_availability(
         self, parameters: Union[_models.CheckTrafficManagerRelativeDnsNameAvailabilityParameters, IO], **kwargs: Any
     ) -> _models.TrafficManagerNameAvailability:
         """Checks the availability of a Traffic Manager Relative DNS name.
 
         :param parameters: The Traffic Manager name parameters supplied to the
-         CheckTrafficManagerNameAvailability operation. Is either a
-         CheckTrafficManagerRelativeDnsNameAvailabilityParameters type or a IO type. Required.
+         CheckTrafficManagerNameAvailability operation. Is either a model type or a IO type. Required.
         :type parameters:
          ~azure.mgmt.trafficmanager.models.CheckTrafficManagerRelativeDnsNameAvailabilityParameters or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -131,22 +133,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.TrafficManagerNameAvailability] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IOBase, bytes)):
+        if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "CheckTrafficManagerRelativeDnsNameAvailabilityParameters")
 
         request = build_check_traffic_manager_relative_dns_name_availability_request(
             api_version=api_version,
             content_type=content_type,
@@ -155,17 +159,16 @@
             template_url=self.check_traffic_manager_relative_dns_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -177,133 +180,14 @@
 
         return deserialized
 
     check_traffic_manager_relative_dns_name_availability.metadata = {
         "url": "/providers/Microsoft.Network/checkTrafficManagerNameAvailability"
     }
 
-    @overload
-    async def check_traffic_manager_name_availability_v2(
-        self,
-        parameters: _models.CheckTrafficManagerRelativeDnsNameAvailabilityParameters,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> _models.TrafficManagerNameAvailability:
-        """Checks the availability of a Traffic Manager Relative DNS name.
-
-        :param parameters: The Traffic Manager name parameters supplied to the
-         CheckTrafficManagerNameAvailability operation. Required.
-        :type parameters:
-         ~azure.mgmt.trafficmanager.models.CheckTrafficManagerRelativeDnsNameAvailabilityParameters
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: TrafficManagerNameAvailability or the result of cls(response)
-        :rtype: ~azure.mgmt.trafficmanager.models.TrafficManagerNameAvailability
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    async def check_traffic_manager_name_availability_v2(
-        self, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
-    ) -> _models.TrafficManagerNameAvailability:
-        """Checks the availability of a Traffic Manager Relative DNS name.
-
-        :param parameters: The Traffic Manager name parameters supplied to the
-         CheckTrafficManagerNameAvailability operation. Required.
-        :type parameters: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: TrafficManagerNameAvailability or the result of cls(response)
-        :rtype: ~azure.mgmt.trafficmanager.models.TrafficManagerNameAvailability
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @distributed_trace_async
-    async def check_traffic_manager_name_availability_v2(
-        self, parameters: Union[_models.CheckTrafficManagerRelativeDnsNameAvailabilityParameters, IO], **kwargs: Any
-    ) -> _models.TrafficManagerNameAvailability:
-        """Checks the availability of a Traffic Manager Relative DNS name.
-
-        :param parameters: The Traffic Manager name parameters supplied to the
-         CheckTrafficManagerNameAvailability operation. Is either a
-         CheckTrafficManagerRelativeDnsNameAvailabilityParameters type or a IO type. Required.
-        :type parameters:
-         ~azure.mgmt.trafficmanager.models.CheckTrafficManagerRelativeDnsNameAvailabilityParameters or
-         IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: TrafficManagerNameAvailability or the result of cls(response)
-        :rtype: ~azure.mgmt.trafficmanager.models.TrafficManagerNameAvailability
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.TrafficManagerNameAvailability] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(parameters, (IOBase, bytes)):
-            _content = parameters
-        else:
-            _json = self._serialize.body(parameters, "CheckTrafficManagerRelativeDnsNameAvailabilityParameters")
-
-        request = build_check_traffic_manager_name_availability_v2_request(
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self.check_traffic_manager_name_availability_v2.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("TrafficManagerNameAvailability", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
-
-    check_traffic_manager_name_availability_v2.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Network/checkTrafficManagerNameAvailabilityV2"
-    }
-
     @distributed_trace
     def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.Profile"]:
         """Lists all Traffic Manager profiles within a resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
@@ -311,15 +195,17 @@
         :return: An iterator like instance of either Profile or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.trafficmanager.models.Profile]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.ProfileListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -364,17 +250,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -394,15 +279,17 @@
         :return: An iterator like instance of either Profile or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.trafficmanager.models.Profile]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.ProfileListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -446,17 +333,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -489,32 +375,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.Profile] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -596,15 +483,15 @@
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param profile_name: The name of the Traffic Manager profile. Required.
         :type profile_name: str
         :param parameters: The Traffic Manager profile parameters supplied to the CreateOrUpdate
-         operation. Is either a Profile type or a IO type. Required.
+         operation. Is either a model type or a IO type. Required.
         :type parameters: ~azure.mgmt.trafficmanager.models.Profile or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Profile or the result of cls(response)
         :rtype: ~azure.mgmt.trafficmanager.models.Profile
@@ -617,22 +504,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Profile] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IOBase, bytes)):
+        if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Profile")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
@@ -644,17 +533,16 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -697,32 +585,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[Optional[_models.DeleteOperationResult]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -806,15 +695,15 @@
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param profile_name: The name of the Traffic Manager profile. Required.
         :type profile_name: str
         :param parameters: The Traffic Manager profile parameters supplied to the Update operation. Is
-         either a Profile type or a IO type. Required.
+         either a model type or a IO type. Required.
         :type parameters: ~azure.mgmt.trafficmanager.models.Profile or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Profile or the result of cls(response)
         :rtype: ~azure.mgmt.trafficmanager.models.Profile
@@ -827,22 +716,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-04-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Profile] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IOBase, bytes)):
+        if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Profile")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
@@ -854,17 +745,16 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/models/_traffic_manager_management_client_enums.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/models/_traffic_manager_management_client_enums.py`

 * *Files 2% similar despite different names*

```diff
@@ -33,15 +33,14 @@
 
     CHECKING_ENDPOINT = "CheckingEndpoint"
     ONLINE = "Online"
     DEGRADED = "Degraded"
     DISABLED = "Disabled"
     INACTIVE = "Inactive"
     STOPPED = "Stopped"
-    UNMONITORED = "Unmonitored"
 
 
 class EndpointStatus(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The status of the endpoint. If the endpoint is Enabled, it is probed for endpoint health and is
     included in the traffic routing method.
     """
```

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/models/__init__.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/models/_patch.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-trafficmanager-1.1.0/azure/mgmt/trafficmanager/models/_models_py3.py` & `azure-mgmt-trafficmanager-1.1.0b1/azure/mgmt/trafficmanager/models/_models_py3.py`

 * *Files 5% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 import datetime
-from typing import Any, Dict, List, Optional, TYPE_CHECKING, Union
+from typing import Dict, List, Optional, TYPE_CHECKING, Union
 
 from .. import _serialization
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from .. import models as _models
 
@@ -27,15 +27,15 @@
     """
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, *, name: Optional[str] = None, type: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, name: Optional[str] = None, type: Optional[str] = None, **kwargs):
         """
         :keyword name: The name of the resource.
         :paramtype name: str
         :keyword type: The type of the resource.
         :paramtype type: str
         """
         super().__init__(**kwargs)
@@ -66,16 +66,16 @@
     def __init__(
         self,
         *,
         code: Optional[str] = None,
         message: Optional[str] = None,
         target: Optional[str] = None,
         details: Optional[List["_models.CloudErrorBody"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword code: Error code.
         :paramtype code: str
         :keyword message: Error message.
         :paramtype message: str
         :keyword target: Error target.
         :paramtype target: str
@@ -102,15 +102,15 @@
         "operation_result": {"readonly": True},
     }
 
     _attribute_map = {
         "operation_result": {"key": "boolean", "type": "bool"},
     }
 
-    def __init__(self, **kwargs: Any) -> None:
+    def __init__(self, **kwargs):
         """ """
         super().__init__(**kwargs)
         self.operation_result = None
 
 
 class DnsConfig(_serialization.Model):
     """Class containing DNS settings in a Traffic Manager profile.
@@ -136,15 +136,15 @@
 
     _attribute_map = {
         "relative_name": {"key": "relativeName", "type": "str"},
         "fqdn": {"key": "fqdn", "type": "str"},
         "ttl": {"key": "ttl", "type": "int"},
     }
 
-    def __init__(self, *, relative_name: Optional[str] = None, ttl: Optional[int] = None, **kwargs: Any) -> None:
+    def __init__(self, *, relative_name: Optional[str] = None, ttl: Optional[int] = None, **kwargs):
         """
         :keyword relative_name: The relative DNS name provided by this Traffic Manager profile. This
          value is combined with the DNS domain name used by Azure Traffic Manager to form the
          fully-qualified domain name (FQDN) of the profile.
         :paramtype relative_name: str
         :keyword ttl: The DNS Time-To-Live (TTL), in seconds. This informs the local DNS resolvers and
          DNS clients how long to cache DNS responses provided by this Traffic Manager profile.
@@ -176,16 +176,16 @@
 
     def __init__(
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         name: Optional[str] = None,
         type: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword id: Fully qualified resource Id for the resource. Ex -
          /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}.
         :paramtype id: str
         :keyword name: The name of the resource.
         :paramtype name: str
         :keyword type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
@@ -194,16 +194,15 @@
         super().__init__(**kwargs)
         self.id = id
         self.name = name
         self.type = type
 
 
 class ProxyResource(Resource):
-    """The resource model definition for a ARM proxy resource. It will have everything other than
-    required location and tags.
+    """The resource model definition for a ARM proxy resource. It will have everything other than required location and tags.
 
     :ivar id: Fully qualified resource Id for the resource. Ex -
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
@@ -218,16 +217,16 @@
 
     def __init__(
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         name: Optional[str] = None,
         type: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword id: Fully qualified resource Id for the resource. Ex -
          /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}.
         :paramtype id: str
         :keyword name: The name of the resource.
         :paramtype name: str
         :keyword type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
@@ -264,15 +263,15 @@
      parameter.  If specified, it must be specified on all endpoints, and no two endpoints can share
      the same priority value.
     :vartype priority: int
     :ivar endpoint_location: Specifies the location of the external or nested endpoints when using
      the 'Performance' traffic routing method.
     :vartype endpoint_location: str
     :ivar endpoint_monitor_status: The monitoring status of the endpoint. Known values are:
-     "CheckingEndpoint", "Online", "Degraded", "Disabled", "Inactive", "Stopped", and "Unmonitored".
+     "CheckingEndpoint", "Online", "Degraded", "Disabled", "Inactive", and "Stopped".
     :vartype endpoint_monitor_status: str or
      ~azure.mgmt.trafficmanager.models.EndpointMonitorStatus
     :ivar min_child_endpoints: The minimum number of endpoints that must be available in the child
      profile in order for the parent profile to be considered available. Only applicable to endpoint
      of type 'NestedEndpoints'.
     :vartype min_child_endpoints: int
     :ivar min_child_endpoints_i_pv4: The minimum number of IPv4 (DNS record type A) endpoints that
@@ -336,16 +335,16 @@
         min_child_endpoints: Optional[int] = None,
         min_child_endpoints_i_pv4: Optional[int] = None,
         min_child_endpoints_i_pv6: Optional[int] = None,
         geo_mapping: Optional[List[str]] = None,
         subnets: Optional[List["_models.EndpointPropertiesSubnetsItem"]] = None,
         custom_headers: Optional[List["_models.EndpointPropertiesCustomHeadersItem"]] = None,
         always_serve: Optional[Union[str, "_models.AlwaysServe"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword id: Fully qualified resource Id for the resource. Ex -
          /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}.
         :paramtype id: str
         :keyword name: The name of the resource.
         :paramtype name: str
         :keyword type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
@@ -368,15 +367,15 @@
          optional parameter.  If specified, it must be specified on all endpoints, and no two endpoints
          can share the same priority value.
         :paramtype priority: int
         :keyword endpoint_location: Specifies the location of the external or nested endpoints when
          using the 'Performance' traffic routing method.
         :paramtype endpoint_location: str
         :keyword endpoint_monitor_status: The monitoring status of the endpoint. Known values are:
-         "CheckingEndpoint", "Online", "Degraded", "Disabled", "Inactive", "Stopped", and "Unmonitored".
+         "CheckingEndpoint", "Online", "Degraded", "Disabled", "Inactive", and "Stopped".
         :paramtype endpoint_monitor_status: str or
          ~azure.mgmt.trafficmanager.models.EndpointMonitorStatus
         :keyword min_child_endpoints: The minimum number of endpoints that must be available in the
          child profile in order for the parent profile to be considered available. Only applicable to
          endpoint of type 'NestedEndpoints'.
         :paramtype min_child_endpoints: int
         :keyword min_child_endpoints_i_pv4: The minimum number of IPv4 (DNS record type A) endpoints
@@ -430,15 +429,15 @@
     """
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "value": {"key": "value", "type": "str"},
     }
 
-    def __init__(self, *, name: Optional[str] = None, value: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, name: Optional[str] = None, value: Optional[str] = None, **kwargs):
         """
         :keyword name: Header name.
         :paramtype name: str
         :keyword value: Header value.
         :paramtype value: str
         """
         super().__init__(**kwargs)
@@ -460,16 +459,16 @@
     _attribute_map = {
         "first": {"key": "first", "type": "str"},
         "last": {"key": "last", "type": "str"},
         "scope": {"key": "scope", "type": "int"},
     }
 
     def __init__(
-        self, *, first: Optional[str] = None, last: Optional[str] = None, scope: Optional[int] = None, **kwargs: Any
-    ) -> None:
+        self, *, first: Optional[str] = None, last: Optional[str] = None, scope: Optional[int] = None, **kwargs
+    ):
         """
         :keyword first: First address in the subnet.
         :paramtype first: str
         :keyword last: Last address in the subnet.
         :paramtype last: str
         :keyword scope: Block size (number of leading bits in the subnet mask).
         :paramtype scope: int
@@ -490,15 +489,15 @@
     """
 
     _attribute_map = {
         "resource_id": {"key": "resourceId", "type": "str"},
         "endpoint_id": {"key": "endpointId", "type": "int"},
     }
 
-    def __init__(self, *, resource_id: Optional[str] = None, endpoint_id: Optional[int] = None, **kwargs: Any) -> None:
+    def __init__(self, *, resource_id: Optional[str] = None, endpoint_id: Optional[int] = None, **kwargs):
         """
         :keyword resource_id: The ARM Resource ID of this Traffic Manager endpoint.
         :paramtype resource_id: str
         :keyword endpoint_id: A number uniquely identifying this endpoint in query experiences.
         :paramtype endpoint_id: int
         """
         super().__init__(**kwargs)
@@ -542,16 +541,16 @@
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         name: Optional[str] = None,
         type: Optional[str] = None,
         start_time: Optional[datetime.datetime] = None,
         end_time: Optional[datetime.datetime] = None,
         endpoints: Optional[List["_models.HeatMapEndpoint"]] = None,
         traffic_flows: Optional[List["_models.TrafficFlow"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword id: Fully qualified resource Id for the resource. Ex -
          /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}.
         :paramtype id: str
         :keyword name: The name of the resource.
         :paramtype name: str
         :keyword type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
@@ -626,16 +625,16 @@
         port: Optional[int] = None,
         path: Optional[str] = None,
         interval_in_seconds: Optional[int] = None,
         timeout_in_seconds: Optional[int] = None,
         tolerated_number_of_failures: Optional[int] = None,
         custom_headers: Optional[List["_models.MonitorConfigCustomHeadersItem"]] = None,
         expected_status_code_ranges: Optional[List["_models.MonitorConfigExpectedStatusCodeRangesItem"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword profile_monitor_status: The profile-level monitoring status of the Traffic Manager
          profile. Known values are: "CheckingEndpoints", "Online", "Degraded", "Disabled", and
          "Inactive".
         :paramtype profile_monitor_status: str or
          ~azure.mgmt.trafficmanager.models.ProfileMonitorStatus
         :keyword protocol: The protocol (HTTP, HTTPS or TCP) used to probe for endpoint health. Known
@@ -684,15 +683,15 @@
     """
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "value": {"key": "value", "type": "str"},
     }
 
-    def __init__(self, *, name: Optional[str] = None, value: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, name: Optional[str] = None, value: Optional[str] = None, **kwargs):
         """
         :keyword name: Header name.
         :paramtype name: str
         :keyword value: Header value.
         :paramtype value: str
         """
         super().__init__(**kwargs)
@@ -715,16 +714,16 @@
     }
 
     def __init__(
         self,
         *,
         min: Optional[int] = None,  # pylint: disable=redefined-builtin
         max: Optional[int] = None,  # pylint: disable=redefined-builtin
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword min: Min status code.
         :paramtype min: int
         :keyword max: Max status code.
         :paramtype max: int
         """
         super().__init__(**kwargs)
@@ -760,16 +759,16 @@
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         name: Optional[str] = None,
         type: Optional[str] = None,
         tags: Optional[Dict[str, str]] = None,
         location: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword id: Fully qualified resource Id for the resource. Ex -
          /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}.
         :paramtype id: str
         :keyword name: The name of the resource.
         :paramtype name: str
         :keyword type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
@@ -850,16 +849,16 @@
         traffic_routing_method: Optional[Union[str, "_models.TrafficRoutingMethod"]] = None,
         dns_config: Optional["_models.DnsConfig"] = None,
         monitor_config: Optional["_models.MonitorConfig"] = None,
         endpoints: Optional[List["_models.Endpoint"]] = None,
         traffic_view_enrollment_status: Optional[Union[str, "_models.TrafficViewEnrollmentStatus"]] = None,
         allowed_endpoint_record_types: Optional[List[Union[str, "_models.AllowedEndpointRecordType"]]] = None,
         max_return: Optional[int] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword id: Fully qualified resource Id for the resource. Ex -
          /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}.
         :paramtype id: str
         :keyword name: The name of the resource.
         :paramtype name: str
         :keyword type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
@@ -912,15 +911,15 @@
     :vartype value: list[~azure.mgmt.trafficmanager.models.Profile]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Profile]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.Profile"]] = None, **kwargs: Any) -> None:
+    def __init__(self, *, value: Optional[List["_models.Profile"]] = None, **kwargs):
         """
         :keyword value: Gets the list of Traffic manager profiles.
         :paramtype value: list[~azure.mgmt.trafficmanager.models.Profile]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -946,15 +945,15 @@
 
     _attribute_map = {
         "endpoint_id": {"key": "endpointId", "type": "int"},
         "query_count": {"key": "queryCount", "type": "int"},
         "latency": {"key": "latency", "type": "float"},
     }
 
-    def __init__(self, *, endpoint_id: int, query_count: int, latency: Optional[float] = None, **kwargs: Any) -> None:
+    def __init__(self, *, endpoint_id: int, query_count: int, latency: Optional[float] = None, **kwargs):
         """
         :keyword endpoint_id: The id of the endpoint from the 'endpoints' array which these queries
          were routed to. Required.
         :paramtype endpoint_id: int
         :keyword query_count: The number of queries originating from this location. Required.
         :paramtype query_count: int
         :keyword latency: The latency experienced by queries originating from this location.
@@ -963,16 +962,15 @@
         super().__init__(**kwargs)
         self.endpoint_id = endpoint_id
         self.query_count = query_count
         self.latency = latency
 
 
 class Region(_serialization.Model):
-    """Class representing a region in the Geographic hierarchy used with the Geographic traffic
-    routing method.
+    """Class representing a region in the Geographic hierarchy used with the Geographic traffic routing method.
 
     :ivar code: The code of the region.
     :vartype code: str
     :ivar name: The name of the region.
     :vartype name: str
     :ivar regions: The list of Regions grouped under this Region in the Geographic Hierarchy.
     :vartype regions: list[~azure.mgmt.trafficmanager.models.Region]
@@ -986,16 +984,16 @@
 
     def __init__(
         self,
         *,
         code: Optional[str] = None,
         name: Optional[str] = None,
         regions: Optional[List["_models.Region"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword code: The code of the region.
         :paramtype code: str
         :keyword name: The name of the region.
         :paramtype name: str
         :keyword regions: The list of Regions grouped under this Region in the Geographic Hierarchy.
         :paramtype regions: list[~azure.mgmt.trafficmanager.models.Region]
@@ -1029,16 +1027,16 @@
     def __init__(
         self,
         *,
         source_ip: Optional[str] = None,
         latitude: Optional[float] = None,
         longitude: Optional[float] = None,
         query_experiences: Optional[List["_models.QueryExperience"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword source_ip: The IP address that this query experience originated from.
         :paramtype source_ip: str
         :keyword latitude: The approximate latitude that these queries originated from.
         :paramtype latitude: float
         :keyword longitude: The approximate longitude that these queries originated from.
         :paramtype longitude: float
@@ -1077,16 +1075,16 @@
     def __init__(
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         name: Optional[str] = None,
         type: Optional[str] = None,
         geographic_hierarchy: Optional["_models.Region"] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword id: Fully qualified resource Id for the resource. Ex -
          /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}.
         :paramtype id: str
         :keyword name: The name of the resource.
         :paramtype name: str
         :keyword type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
@@ -1127,16 +1125,16 @@
         self,
         *,
         name: Optional[str] = None,
         type: Optional[str] = None,
         name_available: Optional[bool] = None,
         reason: Optional[str] = None,
         message: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword name: The relative name.
         :paramtype name: str
         :keyword type: Traffic Manager profile resource type.
         :paramtype type: str
         :keyword name_available: Describes whether the relative name is available or not.
         :paramtype name_available: bool
@@ -1178,16 +1176,16 @@
     def __init__(
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         name: Optional[str] = None,
         type: Optional[str] = None,
         key: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword id: Fully qualified resource Id for the resource. Ex -
          /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}.
         :paramtype id: str
         :keyword name: The name of the resource.
         :paramtype name: str
         :keyword type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
```

