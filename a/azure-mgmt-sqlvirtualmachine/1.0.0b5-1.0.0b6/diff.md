# Comparing `tmp/azure-mgmt-sqlvirtualmachine-1.0.0b5.zip` & `tmp/azure-mgmt-sqlvirtualmachine-1.0.0b6.zip`

## zipinfo {}

```diff
@@ -1,57 +1,57 @@
-Zip file size: 107987 bytes, number of entries: 55
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure_mgmt_sqlvirtualmachine.egg-info/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/
--rw-rw-r--  2.0 unx      642 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/_meta.json
--rw-rw-r--  2.0 unx       38 b- defN 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/setup.cfg
--rw-rw-r--  2.0 unx      223 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/MANIFEST.in
--rw-rw-r--  2.0 unx     6317 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/CHANGELOG.md
--rw-rw-r--  2.0 unx     8620 b- defN 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/PKG-INFO
--rw-rw-r--  2.0 unx     2842 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/setup.py
--rw-rw-r--  2.0 unx     1392 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/README.md
--rw-rw-r--  2.0 unx     1074 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/LICENSE
--rw-rw-r--  2.0 unx      116 b- defN 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure_mgmt_sqlvirtualmachine.egg-info/requires.txt
--rw-rw-r--  2.0 unx        1 b- defN 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure_mgmt_sqlvirtualmachine.egg-info/not-zip-safe
--rw-rw-r--  2.0 unx     8620 b- defN 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure_mgmt_sqlvirtualmachine.egg-info/PKG-INFO
--rw-rw-r--  2.0 unx        1 b- defN 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure_mgmt_sqlvirtualmachine.egg-info/dependency_links.txt
--rw-rw-r--  2.0 unx        6 b- defN 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure_mgmt_sqlvirtualmachine.egg-info/top_level.txt
--rw-rw-r--  2.0 unx     2222 b- defN 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure_mgmt_sqlvirtualmachine.egg-info/SOURCES.txt
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/
--rw-rw-r--  2.0 unx       65 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/
--rw-rw-r--  2.0 unx       65 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/models/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/
--rw-rw-r--  2.0 unx     1169 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_vendor.py
--rw-rw-r--  2.0 unx     1530 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_patch.py
--rw-rw-r--  2.0 unx      488 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_version.py
--rw-rw-r--  2.0 unx      941 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/__init__.py
--rw-rw-r--  2.0 unx    77872 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_serialization.py
--rw-rw-r--  2.0 unx     3822 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_configuration.py
--rw-rw-r--  2.0 unx       26 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/py.typed
--rw-rw-r--  2.0 unx     6016 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_sql_virtual_machine_management_client.py
--rw-rw-r--  2.0 unx     5638 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/models/_sql_virtual_machine_management_client_enums.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/models/_patch.py
--rw-rw-r--  2.0 unx     6667 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/models/__init__.py
--rw-rw-r--  2.0 unx   101282 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/models/_models_py3.py
--rw-rw-r--  2.0 unx    51338 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machine_groups_operations.py
--rw-rw-r--  2.0 unx    72390 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machines_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_patch.py
--rw-rw-r--  2.0 unx     6829 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_operations.py
--rw-rw-r--  2.0 unx     1279 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/__init__.py
--rw-rw-r--  2.0 unx    37021 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_availability_group_listeners_operations.py
--rw-rw-r--  2.0 unx    15921 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machine_troubleshoot_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jan-17 07:37 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/
--rw-rw-r--  2.0 unx     1530 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/_patch.py
--rw-rw-r--  2.0 unx      888 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/__init__.py
--rw-rw-r--  2.0 unx     3870 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/_configuration.py
--rw-rw-r--  2.0 unx     6163 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/_sql_virtual_machine_management_client.py
--rw-rw-r--  2.0 unx    43244 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machine_groups_operations.py
--rw-rw-r--  2.0 unx    59299 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machines_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     6072 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_operations.py
--rw-rw-r--  2.0 unx     1279 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    30307 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_availability_group_listeners_operations.py
--rw-rw-r--  2.0 unx    14238 b- defN 23-Jan-17 07:36 azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machine_troubleshoot_operations.py
-55 files, 591385 bytes uncompressed, 94849 bytes compressed:  84.0%
+Zip file size: 108509 bytes, number of entries: 55
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure_mgmt_sqlvirtualmachine.egg-info/
+-rw-rw-r--  2.0 unx     1074 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/LICENSE
+-rw-rw-r--  2.0 unx     6382 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/CHANGELOG.md
+-rw-rw-r--  2.0 unx     2218 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/README.md
+-rw-rw-r--  2.0 unx       38 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/setup.cfg
+-rw-rw-r--  2.0 unx     9511 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/PKG-INFO
+-rw-rw-r--  2.0 unx      672 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/_meta.json
+-rw-rw-r--  2.0 unx     2862 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/setup.py
+-rw-rw-r--  2.0 unx      223 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/MANIFEST.in
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/
+-rw-rw-r--  2.0 unx     1530 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_patch.py
+-rw-rw-r--  2.0 unx      488 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_version.py
+-rw-rw-r--  2.0 unx       26 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/py.typed
+-rw-rw-r--  2.0 unx    78836 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_serialization.py
+-rw-rw-r--  2.0 unx     6040 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_sql_virtual_machine_management_client.py
+-rw-rw-r--  2.0 unx     3565 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_configuration.py
+-rw-rw-r--  2.0 unx      941 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/__init__.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_vendor.py
+-rw-rw-r--  2.0 unx   101946 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/models/_patch.py
+-rw-rw-r--  2.0 unx     6667 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/models/__init__.py
+-rw-rw-r--  2.0 unx     5638 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/models/_sql_virtual_machine_management_client_enums.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/
+-rw-rw-r--  2.0 unx     1530 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/_patch.py
+-rw-rw-r--  2.0 unx     6192 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/_sql_virtual_machine_management_client.py
+-rw-rw-r--  2.0 unx     3613 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/_configuration.py
+-rw-rw-r--  2.0 unx      888 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/__init__.py
+-rw-rw-r--  2.0 unx     5824 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    13979 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machine_troubleshoot_operations.py
+-rw-rw-r--  2.0 unx    29943 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_availability_group_listeners_operations.py
+-rw-rw-r--  2.0 unx    42816 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machine_groups_operations.py
+-rw-rw-r--  2.0 unx    58721 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machines_operations.py
+-rw-rw-r--  2.0 unx     1279 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     6541 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_patch.py
+-rw-rw-r--  2.0 unx    15622 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machine_troubleshoot_operations.py
+-rw-rw-r--  2.0 unx    36497 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_availability_group_listeners_operations.py
+-rw-rw-r--  2.0 unx    50670 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machine_groups_operations.py
+-rw-rw-r--  2.0 unx    71452 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machines_operations.py
+-rw-rw-r--  2.0 unx     1279 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/__init__.py
+-rw-rw-r--  2.0 unx        1 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure_mgmt_sqlvirtualmachine.egg-info/not-zip-safe
+-rw-rw-r--  2.0 unx     9511 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure_mgmt_sqlvirtualmachine.egg-info/PKG-INFO
+-rw-rw-r--  2.0 unx      124 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure_mgmt_sqlvirtualmachine.egg-info/requires.txt
+-rw-rw-r--  2.0 unx        1 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure_mgmt_sqlvirtualmachine.egg-info/dependency_links.txt
+-rw-rw-r--  2.0 unx        6 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure_mgmt_sqlvirtualmachine.egg-info/top_level.txt
+-rw-rw-r--  2.0 unx     2222 b- defN 23-Jun-21 03:29 azure-mgmt-sqlvirtualmachine-1.0.0b6/azure_mgmt_sqlvirtualmachine.egg-info/SOURCES.txt
+55 files, 590822 bytes uncompressed, 95371 bytes compressed:  83.9%
```

## zipnote {}

```diff
@@ -1,166 +1,166 @@
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure_mgmt_sqlvirtualmachine.egg-info/
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure_mgmt_sqlvirtualmachine.egg-info/
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/_meta.json
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/LICENSE
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/setup.cfg
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/CHANGELOG.md
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/MANIFEST.in
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/README.md
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/CHANGELOG.md
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/setup.cfg
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/PKG-INFO
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/setup.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/_meta.json
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/README.md
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/setup.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/LICENSE
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/MANIFEST.in
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure_mgmt_sqlvirtualmachine.egg-info/requires.txt
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure_mgmt_sqlvirtualmachine.egg-info/not-zip-safe
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/__init__.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure_mgmt_sqlvirtualmachine.egg-info/PKG-INFO
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure_mgmt_sqlvirtualmachine.egg-info/dependency_links.txt
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/__init__.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure_mgmt_sqlvirtualmachine.egg-info/top_level.txt
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/models/
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure_mgmt_sqlvirtualmachine.egg-info/SOURCES.txt
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/__init__.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_patch.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_version.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/__init__.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/py.typed
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/models/
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_serialization.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_sql_virtual_machine_management_client.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_vendor.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/__init__.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_patch.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_version.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/__init__.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_serialization.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_configuration.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/models/_sql_virtual_machine_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/py.typed
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_sql_virtual_machine_management_client.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/models/_sql_virtual_machine_management_client_enums.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/_sql_virtual_machine_management_client.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/models/_patch.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/models/__init__.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/models/_models_py3.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machine_groups_operations.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machines_operations.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machine_troubleshoot_operations.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_patch.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_availability_group_listeners_operations.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_operations.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machine_groups_operations.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/__init__.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machines_operations.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_availability_group_listeners_operations.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machine_troubleshoot_operations.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/_patch.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machine_troubleshoot_operations.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/__init__.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_availability_group_listeners_operations.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/_configuration.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machine_groups_operations.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/_sql_virtual_machine_management_client.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machines_operations.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machine_groups_operations.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machines_operations.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure_mgmt_sqlvirtualmachine.egg-info/not-zip-safe
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_patch.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure_mgmt_sqlvirtualmachine.egg-info/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_operations.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure_mgmt_sqlvirtualmachine.egg-info/requires.txt
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/__init__.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure_mgmt_sqlvirtualmachine.egg-info/dependency_links.txt
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_availability_group_listeners_operations.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure_mgmt_sqlvirtualmachine.egg-info/top_level.txt
 Comment: 
 
-Filename: azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machine_troubleshoot_operations.py
+Filename: azure-mgmt-sqlvirtualmachine-1.0.0b6/azure_mgmt_sqlvirtualmachine.egg-info/SOURCES.txt
 Comment: 
 
 Zip file comment:
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/_meta.json` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/_meta.json`

 * *Files 19% similar despite different names*

### Pretty-printed

 * *Similarity: 0.7777777777777777%*

 * *Differences: {"'autorest_command'": "'autorest specification/sqlvirtualmachine/resource-manager/readme.md "*

 * *                       '--generate-sample=True --include-x-ms-examples-original-file=True --python '*

 * *                       '--python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk '*

 * *                       '--tag=package-preview-2022-08 --use=@autorest/python@6.6.0 '*

 * *                       '--use=@autorest/modelerfour@4.24.3 --version=3.9.2 '*

 * *                       "--version-tolerant=False'",*

 * * "'commit'": [â€¦]*

```diff
@@ -1,11 +1,11 @@
 {
     "autorest": "3.9.2",
-    "autorest_command": "autorest specification/sqlvirtualmachine/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.2.7 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
-    "commit": "020f48c422ec455cdee9f6516f2d0172d13e77a3",
+    "autorest_command": "autorest specification/sqlvirtualmachine/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --tag=package-preview-2022-08 --use=@autorest/python@6.6.0 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
+    "commit": "e5d8bf380ef60a6a283ba81fd0ce4bc0e49e6680",
     "readme": "specification/sqlvirtualmachine/resource-manager/readme.md",
     "repository_url": "https://github.com/Azure/azure-rest-api-specs",
     "use": [
-        "@autorest/python@6.2.7",
+        "@autorest/python@6.6.0",
         "@autorest/modelerfour@4.24.3"
     ]
 }
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/CHANGELOG.md` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/CHANGELOG.md`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,15 @@
 # Release History
 
+## 1.0.0b6 (2023-06-16)
+
+### Other Changes
+
+  - Regular release
+
 ## 1.0.0b5 (2023-01-17)
 
 ### Features Added
 
   - Added operation group SqlVirtualMachineTroubleshootOperations
   - Model ServerConfigurationsManagementSettings has a new parameter azure_ad_authentication_settings
   - Model SqlVirtualMachine has a new parameter troubleshooting_status
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/PKG-INFO` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/PKG-INFO`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-sqlvirtualmachine
-Version: 1.0.0b5
+Version: 1.0.0b6
 Summary: Microsoft Azure Sql Virtual Machine Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
 Classifier: Development Status :: 4 - Beta
@@ -27,36 +27,78 @@
 This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
 
-# Usage
+## Getting started
 
+### Prerequisites
 
-To learn how to use this package, see the [quickstart guide](https://aka.ms/azsdk/python/mgmt)
- 
-For docs and references, see [Python SDK References](https://docs.microsoft.com/python/api/overview/azure/)
-Code samples for this package can be found at [Sql Virtual Machine Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com.
-Additional code samples for different Azure services are available at [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+- Python 3.7+ is required to use this package.
+- [Azure subscription](https://azure.microsoft.com/free/)
 
+### Install the package
 
-# Provide Feedback
+```bash
+pip install azure-mgmt-sqlvirtualmachine
+pip install azure-identity
+```
+
+### Authentication
+
+By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
+
+- `AZURE_CLIENT_ID` for Azure client ID.
+- `AZURE_TENANT_ID` for Azure tenant ID.
+- `AZURE_CLIENT_SECRET` for Azure client secret.
+
+In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
+
+With above configuration, client can be authenticated by following code:
+
+```python
+from azure.identity import DefaultAzureCredential
+from azure.mgmt.sqlvirtualmachine import SqlVirtualMachineManagementClient
+import os
+
+sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
+client = SqlVirtualMachineManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
+```
+
+## Examples
+
+Code samples for this package can be found at:
+- [Search Sql Virtual Machine Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+
+
+## Troubleshooting
+
+## Next steps
+
+## Provide Feedback
 
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-sqlvirtualmachine%2FREADME.png)
 
 
 # Release History
 
+## 1.0.0b6 (2023-06-16)
+
+### Other Changes
+
+  - Regular release
+
 ## 1.0.0b5 (2023-01-17)
 
 ### Features Added
 
   - Added operation group SqlVirtualMachineTroubleshootOperations
   - Model ServerConfigurationsManagementSettings has a new parameter azure_ad_authentication_settings
   - Model SqlVirtualMachine has a new parameter troubleshooting_status
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/setup.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/setup.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,79 +1,83 @@
 #!/usr/bin/env python
 
-#-------------------------------------------------------------------------
+# -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
-#--------------------------------------------------------------------------
+# --------------------------------------------------------------------------
 
 import re
 import os.path
 from io import open
 from setuptools import find_packages, setup
 
 # Change the PACKAGE_NAME only to change folder and different name
 PACKAGE_NAME = "azure-mgmt-sqlvirtualmachine"
 PACKAGE_PPRINT_NAME = "Sql Virtual Machine Management"
 
 # a-b-c => a/b/c
-package_folder_path = PACKAGE_NAME.replace('-', '/')
+package_folder_path = PACKAGE_NAME.replace("-", "/")
 # a-b-c => a.b.c
-namespace_name = PACKAGE_NAME.replace('-', '.')
+namespace_name = PACKAGE_NAME.replace("-", ".")
 
 # Version extraction inspired from 'requests'
-with open(os.path.join(package_folder_path, 'version.py')
-          if os.path.exists(os.path.join(package_folder_path, 'version.py'))
-          else os.path.join(package_folder_path, '_version.py'), 'r') as fd:
-    version = re.search(r'^VERSION\s*=\s*[\'"]([^\'"]*)[\'"]',
-                        fd.read(), re.MULTILINE).group(1)
+with open(
+    os.path.join(package_folder_path, "version.py")
+    if os.path.exists(os.path.join(package_folder_path, "version.py"))
+    else os.path.join(package_folder_path, "_version.py"),
+    "r",
+) as fd:
+    version = re.search(r'^VERSION\s*=\s*[\'"]([^\'"]*)[\'"]', fd.read(), re.MULTILINE).group(1)
 
 if not version:
-    raise RuntimeError('Cannot find version information')
+    raise RuntimeError("Cannot find version information")
 
-with open('README.md', encoding='utf-8') as f:
+with open("README.md", encoding="utf-8") as f:
     readme = f.read()
-with open('CHANGELOG.md', encoding='utf-8') as f:
+with open("CHANGELOG.md", encoding="utf-8") as f:
     changelog = f.read()
 
 setup(
     name=PACKAGE_NAME,
     version=version,
-    description='Microsoft Azure {} Client Library for Python'.format(PACKAGE_PPRINT_NAME),
-    long_description=readme + '\n\n' + changelog,
-    long_description_content_type='text/markdown',
-    license='MIT License',
-    author='Microsoft Corporation',
-    author_email='azpysdkhelp@microsoft.com',
-    url='https://github.com/Azure/azure-sdk-for-python',
+    description="Microsoft Azure {} Client Library for Python".format(PACKAGE_PPRINT_NAME),
+    long_description=readme + "\n\n" + changelog,
+    long_description_content_type="text/markdown",
+    license="MIT License",
+    author="Microsoft Corporation",
+    author_email="azpysdkhelp@microsoft.com",
+    url="https://github.com/Azure/azure-sdk-for-python",
     keywords="azure, azure sdk",  # update with search keywords relevant to the azure service / product
     classifiers=[
-        'Development Status :: 4 - Beta',
-        'Programming Language :: Python',
-        'Programming Language :: Python :: 3 :: Only',
-        'Programming Language :: Python :: 3',
-        'Programming Language :: Python :: 3.7',
-        'Programming Language :: Python :: 3.8',
-        'Programming Language :: Python :: 3.9',
-        'Programming Language :: Python :: 3.10',
-        'Programming Language :: Python :: 3.11',
-        'License :: OSI Approved :: MIT License',
+        "Development Status :: 4 - Beta",
+        "Programming Language :: Python",
+        "Programming Language :: Python :: 3 :: Only",
+        "Programming Language :: Python :: 3",
+        "Programming Language :: Python :: 3.7",
+        "Programming Language :: Python :: 3.8",
+        "Programming Language :: Python :: 3.9",
+        "Programming Language :: Python :: 3.10",
+        "Programming Language :: Python :: 3.11",
+        "License :: OSI Approved :: MIT License",
     ],
     zip_safe=False,
-    packages=find_packages(exclude=[
-        'tests',
-        # Exclude packages that will be covered by PEP420 or nspkg
-        'azure',
-        'azure.mgmt',
-    ]),
+    packages=find_packages(
+        exclude=[
+            "tests",
+            # Exclude packages that will be covered by PEP420 or nspkg
+            "azure",
+            "azure.mgmt",
+        ]
+    ),
     include_package_data=True,
     package_data={
-        'pytyped': ['py.typed'],
+        "pytyped": ["py.typed"],
     },
     install_requires=[
-        "msrest>=0.7.1",
+        "isodate<1.0.0,>=0.6.1",
         "azure-common~=1.1",
         "azure-mgmt-core>=1.3.2,<2.0.0",
         "typing-extensions>=4.3.0; python_version<'3.8.0'",
     ],
-    python_requires=">=3.7"
+    python_requires=">=3.7",
 )
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/README.md` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/README.md`

 * *Files 25% similar despite different names*

```diff
@@ -4,25 +4,61 @@
 This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
 
-# Usage
+## Getting started
 
+### Prerequisites
 
-To learn how to use this package, see the [quickstart guide](https://aka.ms/azsdk/python/mgmt)
- 
-For docs and references, see [Python SDK References](https://docs.microsoft.com/python/api/overview/azure/)
-Code samples for this package can be found at [Sql Virtual Machine Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com.
-Additional code samples for different Azure services are available at [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+- Python 3.7+ is required to use this package.
+- [Azure subscription](https://azure.microsoft.com/free/)
 
+### Install the package
 
-# Provide Feedback
+```bash
+pip install azure-mgmt-sqlvirtualmachine
+pip install azure-identity
+```
+
+### Authentication
+
+By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
+
+- `AZURE_CLIENT_ID` for Azure client ID.
+- `AZURE_TENANT_ID` for Azure tenant ID.
+- `AZURE_CLIENT_SECRET` for Azure client secret.
+
+In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
+
+With above configuration, client can be authenticated by following code:
+
+```python
+from azure.identity import DefaultAzureCredential
+from azure.mgmt.sqlvirtualmachine import SqlVirtualMachineManagementClient
+import os
+
+sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
+client = SqlVirtualMachineManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
+```
+
+## Examples
+
+Code samples for this package can be found at:
+- [Search Sql Virtual Machine Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+
+
+## Troubleshooting
+
+## Next steps
+
+## Provide Feedback
 
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-sqlvirtualmachine%2FREADME.png)
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/LICENSE` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/LICENSE`

 * *Files identical despite different names*

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure_mgmt_sqlvirtualmachine.egg-info/PKG-INFO` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure_mgmt_sqlvirtualmachine.egg-info/PKG-INFO`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-sqlvirtualmachine
-Version: 1.0.0b5
+Version: 1.0.0b6
 Summary: Microsoft Azure Sql Virtual Machine Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
 Classifier: Development Status :: 4 - Beta
@@ -27,36 +27,78 @@
 This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
 
-# Usage
+## Getting started
 
+### Prerequisites
 
-To learn how to use this package, see the [quickstart guide](https://aka.ms/azsdk/python/mgmt)
- 
-For docs and references, see [Python SDK References](https://docs.microsoft.com/python/api/overview/azure/)
-Code samples for this package can be found at [Sql Virtual Machine Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com.
-Additional code samples for different Azure services are available at [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+- Python 3.7+ is required to use this package.
+- [Azure subscription](https://azure.microsoft.com/free/)
 
+### Install the package
 
-# Provide Feedback
+```bash
+pip install azure-mgmt-sqlvirtualmachine
+pip install azure-identity
+```
+
+### Authentication
+
+By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
+
+- `AZURE_CLIENT_ID` for Azure client ID.
+- `AZURE_TENANT_ID` for Azure tenant ID.
+- `AZURE_CLIENT_SECRET` for Azure client secret.
+
+In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
+
+With above configuration, client can be authenticated by following code:
+
+```python
+from azure.identity import DefaultAzureCredential
+from azure.mgmt.sqlvirtualmachine import SqlVirtualMachineManagementClient
+import os
+
+sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
+client = SqlVirtualMachineManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
+```
+
+## Examples
+
+Code samples for this package can be found at:
+- [Search Sql Virtual Machine Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+
+
+## Troubleshooting
+
+## Next steps
+
+## Provide Feedback
 
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-sqlvirtualmachine%2FREADME.png)
 
 
 # Release History
 
+## 1.0.0b6 (2023-06-16)
+
+### Other Changes
+
+  - Regular release
+
 ## 1.0.0b5 (2023-01-17)
 
 ### Features Added
 
   - Added operation group SqlVirtualMachineTroubleshootOperations
   - Model ServerConfigurationsManagementSettings has a new parameter azure_ad_authentication_settings
   - Model SqlVirtualMachine has a new parameter troubleshooting_status
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure_mgmt_sqlvirtualmachine.egg-info/SOURCES.txt` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure_mgmt_sqlvirtualmachine.egg-info/SOURCES.txt`

 * *Files identical despite different names*

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_vendor.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_vendor.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,16 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+from typing import List, cast
+
 from azure.core.pipeline.transport import HttpRequest
 
 
 def _convert_request(request, files=None):
     data = request.content if not files else None
     request = HttpRequest(method=request.method, url=request.url, headers=request.headers, data=data)
     if files:
@@ -18,10 +20,11 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            formatted_components = template.split("/")
+            # Need the cast, as for some reasons "split" is typed as list[str | Any]
+            formatted_components = cast(List[str], template.split("/"))
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_patch.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/__init__.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_serialization.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_serialization.py`

 * *Files 2% similar despite different names*

```diff
@@ -34,30 +34,47 @@
 import email
 from enum import Enum
 import json
 import logging
 import re
 import sys
 import codecs
-from typing import Optional, Union, AnyStr, IO, Mapping
+from typing import (
+    Dict,
+    Any,
+    cast,
+    Optional,
+    Union,
+    AnyStr,
+    IO,
+    Mapping,
+    Callable,
+    TypeVar,
+    MutableMapping,
+    Type,
+    List,
+    Mapping,
+)
 
 try:
     from urllib import quote  # type: ignore
 except ImportError:
     from urllib.parse import quote
 import xml.etree.ElementTree as ET
 
 import isodate  # type: ignore
 
-from typing import Dict, Any, cast
-
 from azure.core.exceptions import DeserializationError, SerializationError, raise_with_traceback
+from azure.core.serialization import NULL as AzureCoreNull
 
 _BOM = codecs.BOM_UTF8.decode(encoding="utf-8")
 
+ModelType = TypeVar("ModelType", bound="Model")
+JSON = MutableMapping[str, Any]
+
 
 class RawDeserializer:
 
     # Accept "text" because we're open minded people...
     JSON_REGEXP = re.compile(r"^(application|text)/([a-z+.]+\+)?json$")
 
     # Name used in context
@@ -273,43 +290,43 @@
     serialization and deserialization.
     """
 
     _subtype_map: Dict[str, Dict[str, Any]] = {}
     _attribute_map: Dict[str, Dict[str, Any]] = {}
     _validation: Dict[str, Dict[str, Any]] = {}
 
-    def __init__(self, **kwargs):
-        self.additional_properties = {}
+    def __init__(self, **kwargs: Any) -> None:
+        self.additional_properties: Dict[str, Any] = {}
         for k in kwargs:
             if k not in self._attribute_map:
                 _LOGGER.warning("%s is not a known attribute of class %s and will be ignored", k, self.__class__)
             elif k in self._validation and self._validation[k].get("readonly", False):
                 _LOGGER.warning("Readonly attribute %s will be ignored in class %s", k, self.__class__)
             else:
                 setattr(self, k, kwargs[k])
 
-    def __eq__(self, other):
+    def __eq__(self, other: Any) -> bool:
         """Compare objects by comparing all attributes."""
         if isinstance(other, self.__class__):
             return self.__dict__ == other.__dict__
         return False
 
-    def __ne__(self, other):
+    def __ne__(self, other: Any) -> bool:
         """Compare objects by comparing all attributes."""
         return not self.__eq__(other)
 
-    def __str__(self):
+    def __str__(self) -> str:
         return str(self.__dict__)
 
     @classmethod
-    def enable_additional_properties_sending(cls):
+    def enable_additional_properties_sending(cls) -> None:
         cls._attribute_map["additional_properties"] = {"key": "", "type": "{object}"}
 
     @classmethod
-    def is_xml_model(cls):
+    def is_xml_model(cls) -> bool:
         try:
             cls._xml_map  # type: ignore
         except AttributeError:
             return False
         return True
 
     @classmethod
@@ -318,30 +335,35 @@
         try:
             xml_map = cls._xml_map  # type: ignore
         except AttributeError:
             xml_map = {}
 
         return _create_xml_node(xml_map.get("name", cls.__name__), xml_map.get("prefix", None), xml_map.get("ns", None))
 
-    def serialize(self, keep_readonly=False, **kwargs):
+    def serialize(self, keep_readonly: bool = False, **kwargs: Any) -> JSON:
         """Return the JSON that would be sent to azure from this model.
 
         This is an alias to `as_dict(full_restapi_key_transformer, keep_readonly=False)`.
 
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param bool keep_readonly: If you want to serialize the readonly attributes
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
         return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)
 
-    def as_dict(self, keep_readonly=True, key_transformer=attribute_transformer, **kwargs):
-        """Return a dict that can be JSONify using json.dump.
+    def as_dict(
+        self,
+        keep_readonly: bool = True,
+        key_transformer: Callable[[str, Dict[str, Any], Any], Any] = attribute_transformer,
+        **kwargs: Any
+    ) -> JSON:
+        """Return a dict that can be serialized using json.dump.
 
         Advanced usage might optionally use a callback as parameter:
 
         .. code::python
 
             def my_key_transformer(key, attr_desc, value):
                 return key
@@ -380,41 +402,46 @@
                 raise ValueError("Not Autorest generated code")
         except Exception:
             # Assume it's not Autorest generated (tests?). Add ourselves as dependencies.
             client_models = {cls.__name__: cls}
         return client_models
 
     @classmethod
-    def deserialize(cls, data, content_type=None):
+    def deserialize(cls: Type[ModelType], data: Any, content_type: Optional[str] = None) -> ModelType:
         """Parse a str using the RestAPI syntax and return a model.
 
         :param str data: A str using RestAPI structure. JSON by default.
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
         return deserializer(cls.__name__, data, content_type=content_type)
 
     @classmethod
-    def from_dict(cls, data, key_extractors=None, content_type=None):
+    def from_dict(
+        cls: Type[ModelType],
+        data: Any,
+        key_extractors: Optional[Callable[[str, Dict[str, Any], Any], Any]] = None,
+        content_type: Optional[str] = None,
+    ) -> ModelType:
         """Parse a dict using given key extractor return a model.
 
         By default consider key
         extractors (rest_key_case_insensitive_extractor, attribute_key_case_insensitive_extractor
         and last_rest_key_case_insensitive_extractor)
 
         :param dict data: A dict using RestAPI structure
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
-        deserializer.key_extractors = (
-            [
+        deserializer.key_extractors = (  # type: ignore
+            [  # type: ignore
                 attribute_key_case_insensitive_extractor,
                 rest_key_case_insensitive_extractor,
                 last_rest_key_case_insensitive_extractor,
             ]
             if key_extractors is None
             else key_extractors
         )
@@ -514,15 +541,15 @@
         "min_items": lambda x, y: len(x) < y,
         "max_items": lambda x, y: len(x) > y,
         "pattern": lambda x, y: not re.match(y, x, re.UNICODE),
         "unique": lambda x, y: len(x) != len(set(x)),
         "multiple": lambda x, y: x % y != 0,
     }
 
-    def __init__(self, classes=None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
         self.serialize_type = {
             "iso-8601": Serializer.serialize_iso,
             "rfc-1123": Serializer.serialize_rfc,
             "unix-time": Serializer.serialize_unix,
             "duration": Serializer.serialize_duration,
             "date": Serializer.serialize_date,
             "time": Serializer.serialize_time,
@@ -530,15 +557,15 @@
             "long": Serializer.serialize_long,
             "bytearray": Serializer.serialize_bytearray,
             "base64": Serializer.serialize_base64,
             "object": self.serialize_object,
             "[]": self.serialize_iter,
             "{}": self.serialize_dict,
         }
-        self.dependencies = dict(classes) if classes else {}
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
         self.key_transformer = full_restapi_key_transformer
         self.client_side_validation = True
 
     def _serialize(self, target_obj, data_type=None, **kwargs):
         """Serialize data into a string according to type.
 
         :param target_obj: The data to be serialized.
@@ -598,15 +625,15 @@
                         xml_desc = attr_desc.get("xml", {})
                         xml_name = xml_desc.get("name", attr_desc["key"])
                         xml_prefix = xml_desc.get("prefix", None)
                         xml_ns = xml_desc.get("ns", None)
                         if xml_desc.get("attr", False):
                             if xml_ns:
                                 ET.register_namespace(xml_prefix, xml_ns)
-                                xml_name = "{}{}".format(xml_ns, xml_name)
+                                xml_name = "{{{}}}{}".format(xml_ns, xml_name)
                             serialized.set(xml_name, new_attr)  # type: ignore
                             continue
                         if xml_desc.get("text", False):
                             serialized.text = new_attr  # type: ignore
                             continue
                         if isinstance(new_attr, list):
                             serialized.extend(new_attr)  # type: ignore
@@ -622,16 +649,15 @@
                         else:  # That's a basic type
                             # Integrate namespace if necessary
                             local_node = _create_xml_node(xml_name, xml_prefix, xml_ns)
                             local_node.text = unicode_str(new_attr)
                             serialized.append(local_node)  # type: ignore
                     else:  # JSON
                         for k in reversed(keys):  # type: ignore
-                            unflattened = {k: new_attr}
-                            new_attr = unflattened
+                            new_attr = {k: new_attr}
 
                         _new_attr = new_attr
                         _serialized = serialized
                         for k in keys:  # type: ignore
                             if k not in _serialized:
                                 _serialized.update(_new_attr)  # type: ignore
                             _new_attr = _new_attr[k]  # type: ignore
@@ -652,16 +678,16 @@
         :param str data_type: The type to be serialized from.
         :rtype: dict
         :raises: SerializationError if serialization fails.
         :raises: ValueError if data is None
         """
 
         # Just in case this is a dict
-        internal_data_type = data_type.strip("[]{}")
-        internal_data_type = self.dependencies.get(internal_data_type, None)
+        internal_data_type_str = data_type.strip("[]{}")
+        internal_data_type = self.dependencies.get(internal_data_type_str, None)
         try:
             is_xml_model_serialization = kwargs["is_xml"]
         except KeyError:
             if internal_data_type and issubclass(internal_data_type, Model):
                 is_xml_model_serialization = kwargs.setdefault("is_xml", internal_data_type.is_xml_model())
             else:
                 is_xml_model_serialization = False
@@ -773,14 +799,16 @@
         :raises: ValueError if data is None
         :raises: SerializationError if serialization fails.
         """
         if data is None:
             raise ValueError("No value for given attribute")
 
         try:
+            if data is AzureCoreNull:
+                return None
             if data_type in self.basic_types.values():
                 return self.serialize_basic(data, data_type, **kwargs)
 
             elif data_type in self.serialize_type:
                 return self.serialize_type[data_type](data, **kwargs)
 
             # If dependencies is empty, try with current data class
@@ -1157,15 +1185,16 @@
 
 
 def rest_key_extractor(attr, attr_desc, data):
     key = attr_desc["key"]
     working_data = data
 
     while "." in key:
-        dict_keys = _FLATTEN.split(key)
+        # Need the cast, as for some reasons "split" is typed as list[str | Any]
+        dict_keys = cast(List[str], _FLATTEN.split(key))
         if len(dict_keys) == 1:
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = working_data.get(working_key, data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
@@ -1238,15 +1267,15 @@
     :rtype: tuple
     :returns: A tuple XML name + namespace dict
     """
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
     xml_name = internal_type_xml_map.get("name", internal_type.__name__)
     xml_ns = internal_type_xml_map.get("ns", None)
     if xml_ns:
-        xml_name = "{}{}".format(xml_ns, xml_name)
+        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
     return xml_name
 
 
 def xml_key_extractor(attr, attr_desc, data):
     if isinstance(data, dict):
         return None
 
@@ -1262,15 +1291,15 @@
     is_wrapped = xml_desc.get("wrapped", False)
     internal_type = attr_desc.get("internalType", None)
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
 
     # Integrate namespace if necessary
     xml_ns = xml_desc.get("ns", internal_type_xml_map.get("ns", None))
     if xml_ns:
-        xml_name = "{}{}".format(xml_ns, xml_name)
+        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
 
     # If it's an attribute, that's simple
     if xml_desc.get("attr", False):
         return data.get(xml_name)
 
     # If it's x-ms-text, that's simple too
     if xml_desc.get("text", False):
@@ -1328,15 +1357,15 @@
     :ivar list key_extractors: Ordered list of extractors to be used by this deserializer.
     """
 
     basic_types = {str: "str", int: "int", bool: "bool", float: "float"}
 
     valid_date = re.compile(r"\d{4}[-]\d{2}[-]\d{2}T\d{2}:\d{2}:\d{2}" r"\.?\d*Z?[-+]?[\d{2}]?:?[\d{2}]?")
 
-    def __init__(self, classes=None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
         self.deserialize_type = {
             "iso-8601": Deserializer.deserialize_iso,
             "rfc-1123": Deserializer.deserialize_rfc,
             "unix-time": Deserializer.deserialize_unix,
             "duration": Deserializer.deserialize_duration,
             "date": Deserializer.deserialize_date,
             "time": Deserializer.deserialize_time,
@@ -1348,15 +1377,15 @@
             "[]": self.deserialize_iter,
             "{}": self.deserialize_dict,
         }
         self.deserialize_expected_types = {
             "duration": (isodate.Duration, datetime.timedelta),
             "iso-8601": (datetime.datetime),
         }
-        self.dependencies = dict(classes) if classes else {}
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
         self.key_extractors = [rest_key_extractor, xml_key_extractor]
         # Additional properties only works if the "rest_key_extractor" is used to
         # extract the keys. Making it to work whatever the key extractor is too much
         # complicated, with no real scenario for now.
         # So adding a flag to disable additional properties detection. This flag should be
         # used if your expect the deserialization to NOT come from a JSON REST syntax.
         # Otherwise, result are unexpected
@@ -1467,40 +1496,40 @@
 
     def _classify_target(self, target, data):
         """Check to see whether the deserialization target object can
         be classified into a subclass.
         Once classification has been determined, initialize object.
 
         :param str target: The target object type to deserialize to.
-        :param str/dict data: The response data to deseralize.
+        :param str/dict data: The response data to deserialize.
         """
         if target is None:
             return None, None
 
         if isinstance(target, basestring):
             try:
                 target = self.dependencies[target]
             except KeyError:
                 return target, target
 
         try:
             target = target._classify(data, self.dependencies)
         except AttributeError:
             pass  # Target is not a Model, no classify
-        return target, target.__class__.__name__
+        return target, target.__class__.__name__  # type: ignore
 
     def failsafe_deserialize(self, target_obj, data, content_type=None):
         """Ignores any errors encountered in deserialization,
         and falls back to not deserializing the object. Recommended
         for use in error deserialization, as we want to return the
         HttpResponseError to users, and not have them deal with
         a deserialization error.
 
         :param str target_obj: The target object type to deserialize to.
-        :param str/dict data: The response data to deseralize.
+        :param str/dict data: The response data to deserialize.
         :param str content_type: Swagger "produces" if available.
         """
         try:
             return self(target_obj, data, content_type=content_type)
         except:
             _LOGGER.debug(
                 "Ran into a deserialization error. Ignoring since this is failsafe deserialization", exc_info=True
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_configuration.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/_configuration.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,51 +2,45 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
+from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
-from ._version import VERSION
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from .._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
 class SqlVirtualMachineManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for SqlVirtualMachineManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: Subscription ID that identifies an Azure subscription. Required.
     :type subscription_id: str
     :keyword api_version: Api Version. Default value is "2022-08-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(SqlVirtualMachineManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop("api_version", "2022-08-01-preview")
+        api_version: str = kwargs.pop("api_version", "2022-08-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -58,15 +52,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = ARMChallengeAuthenticationPolicy(
+            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/_sql_virtual_machine_management_client.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_sql_virtual_machine_management_client.py`

 * *Files 0% similar despite different names*

```diff
@@ -67,15 +67,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = SqlVirtualMachineManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.availability_group_listeners = AvailabilityGroupListenersOperations(
             self._client, self._config, self._serialize, self._deserialize
@@ -116,9 +116,9 @@
     def close(self) -> None:
         self._client.close()
 
     def __enter__(self) -> "SqlVirtualMachineManagementClient":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details) -> None:
+    def __exit__(self, *exc_details: Any) -> None:
         self._client.__exit__(*exc_details)
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/models/_sql_virtual_machine_management_client_enums.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/models/_sql_virtual_machine_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/models/_patch.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/models/__init__.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/models/_models_py3.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/models/_models_py3.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 import datetime
-from typing import Dict, List, Optional, TYPE_CHECKING, Union
+from typing import Any, Dict, List, Optional, TYPE_CHECKING, Union
 
 from .. import _serialization
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from .. import models as _models
 
@@ -25,15 +25,15 @@
     :vartype client_id: str
     """
 
     _attribute_map = {
         "client_id": {"key": "clientId", "type": "str"},
     }
 
-    def __init__(self, *, client_id: Optional[str] = None, **kwargs):
+    def __init__(self, *, client_id: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword client_id: The client Id of the Managed Identity to query Microsoft Graph API. An
          empty string must be used for the system assigned Managed Identity.
         :paramtype client_id: str
         """
         super().__init__(**kwargs)
         self.client_id = client_id
@@ -46,15 +46,15 @@
     :vartype is_r_services_enabled: bool
     """
 
     _attribute_map = {
         "is_r_services_enabled": {"key": "isRServicesEnabled", "type": "bool"},
     }
 
-    def __init__(self, *, is_r_services_enabled: Optional[bool] = None, **kwargs):
+    def __init__(self, *, is_r_services_enabled: Optional[bool] = None, **kwargs: Any) -> None:
         """
         :keyword is_r_services_enabled: Enable or disable R services (SQL 2016 onwards).
         :paramtype is_r_services_enabled: bool
         """
         super().__init__(**kwargs)
         self.is_r_services_enabled = is_r_services_enabled
 
@@ -66,15 +66,15 @@
     :vartype replicas: list[~azure.mgmt.sqlvirtualmachine.models.AgReplica]
     """
 
     _attribute_map = {
         "replicas": {"key": "replicas", "type": "[AgReplica]"},
     }
 
-    def __init__(self, *, replicas: Optional[List["_models.AgReplica"]] = None, **kwargs):
+    def __init__(self, *, replicas: Optional[List["_models.AgReplica"]] = None, **kwargs: Any) -> None:
         """
         :keyword replicas: Replica configurations.
         :paramtype replicas: list[~azure.mgmt.sqlvirtualmachine.models.AgReplica]
         """
         super().__init__(**kwargs)
         self.replicas = replicas
 
@@ -109,16 +109,16 @@
         self,
         *,
         sql_virtual_machine_instance_id: Optional[str] = None,
         role: Optional[Union[str, "_models.Role"]] = None,
         commit: Optional[Union[str, "_models.Commit"]] = None,
         failover: Optional[Union[str, "_models.Failover"]] = None,
         readable_secondary: Optional[Union[str, "_models.ReadableSecondary"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword sql_virtual_machine_instance_id: Sql VirtualMachine Instance Id.
         :paramtype sql_virtual_machine_instance_id: str
         :keyword role: Replica Role in availability group. Known values are: "PRIMARY" and "SECONDARY".
         :paramtype role: str or ~azure.mgmt.sqlvirtualmachine.models.Role
         :keyword commit: Replica commit mode in availability group. Known values are:
          "SYNCHRONOUS_COMMIT" and "ASYNCHRONOUS_COMMIT".
@@ -157,16 +157,16 @@
 
     def __init__(
         self,
         *,
         enable: Optional[bool] = None,
         run_immediately: Optional[bool] = None,
         schedule: Optional["_models.Schedule"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enable: Enable or disable SQL best practices Assessment feature on SQL virtual
          machine.
         :paramtype enable: bool
         :keyword run_immediately: Run SQL best practices Assessment immediately on SQL virtual machine.
         :paramtype run_immediately: bool
         :keyword schedule: Schedule for SQL best practices Assessment.
@@ -245,16 +245,16 @@
         backup_system_dbs: Optional[bool] = None,
         backup_schedule_type: Optional[Union[str, "_models.BackupScheduleType"]] = None,
         full_backup_frequency: Optional[Union[str, "_models.FullBackupFrequencyType"]] = None,
         days_of_week: Optional[List[Union[str, "_models.AutoBackupDaysOfWeek"]]] = None,
         full_backup_start_time: Optional[int] = None,
         full_backup_window_hours: Optional[int] = None,
         log_backup_frequency: Optional[int] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enable: Enable or disable autobackup on SQL virtual machine.
         :paramtype enable: bool
         :keyword enable_encryption: Enable or disable encryption for backup on SQL virtual machine.
         :paramtype enable_encryption: bool
         :keyword retention_period: Retention period of backup: 1-90 days.
         :paramtype retention_period: int
@@ -329,16 +329,16 @@
     def __init__(
         self,
         *,
         enable: Optional[bool] = None,
         day_of_week: Optional[Union[str, "_models.DayOfWeek"]] = None,
         maintenance_window_starting_hour: Optional[int] = None,
         maintenance_window_duration: Optional[int] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enable: Enable or disable autopatching on SQL virtual machine.
         :paramtype enable: bool
         :keyword day_of_week: Day of week to apply the patch on. Known values are: "Everyday",
          "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
         :paramtype day_of_week: str or ~azure.mgmt.sqlvirtualmachine.models.DayOfWeek
         :keyword maintenance_window_starting_hour: Hour of the day when patching is initiated. Local VM
@@ -375,15 +375,15 @@
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.name = None
         self.type = None
 
 
@@ -408,15 +408,15 @@
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
 
 
 class AvailabilityGroupListener(ProxyResource):  # pylint: disable=too-many-instance-attributes
     """A SQL Server availability group listener.
 
@@ -490,16 +490,16 @@
         *,
         availability_group_name: Optional[str] = None,
         load_balancer_configurations: Optional[List["_models.LoadBalancerConfiguration"]] = None,
         multi_subnet_ip_configurations: Optional[List["_models.MultiSubnetIpConfiguration"]] = None,
         create_default_availability_group_if_not_exist: Optional[bool] = None,
         port: Optional[int] = None,
         availability_group_configuration: Optional["_models.AgConfiguration"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword availability_group_name: Name of the availability group.
         :paramtype availability_group_name: str
         :keyword load_balancer_configurations: List of load balancer configurations for an availability
          group listener.
         :paramtype load_balancer_configurations:
          list[~azure.mgmt.sqlvirtualmachine.models.LoadBalancerConfiguration]
@@ -544,15 +544,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[AvailabilityGroupListener]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class ErrorAdditionalInfo(_serialization.Model):
@@ -572,15 +572,15 @@
     }
 
     _attribute_map = {
         "type": {"key": "type", "type": "str"},
         "info": {"key": "info", "type": "object"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.type = None
         self.info = None
 
 
 class ErrorDetail(_serialization.Model):
@@ -612,36 +612,37 @@
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
         "target": {"key": "target", "type": "str"},
         "details": {"key": "details", "type": "[ErrorDetail]"},
         "additional_info": {"key": "additionalInfo", "type": "[ErrorAdditionalInfo]"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.code = None
         self.message = None
         self.target = None
         self.details = None
         self.additional_info = None
 
 
 class ErrorResponse(_serialization.Model):
-    """Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData error response format.).
+    """Common error response for all Azure Resource Manager APIs to return error details for failed
+    operations. (This also follows the OData error response format.).
 
     :ivar error: The error object.
     :vartype error: ~azure.mgmt.sqlvirtualmachine.models.ErrorDetail
     """
 
     _attribute_map = {
         "error": {"key": "error", "type": "ErrorDetail"},
     }
 
-    def __init__(self, *, error: Optional["_models.ErrorDetail"] = None, **kwargs):
+    def __init__(self, *, error: Optional["_models.ErrorDetail"] = None, **kwargs: Any) -> None:
         """
         :keyword error: The error object.
         :paramtype error: ~azure.mgmt.sqlvirtualmachine.models.ErrorDetail
         """
         super().__init__(**kwargs)
         self.error = error
 
@@ -673,16 +674,16 @@
         self,
         *,
         enable: Optional[bool] = None,
         credential_name: Optional[str] = None,
         azure_key_vault_url: Optional[str] = None,
         service_principal_name: Optional[str] = None,
         service_principal_secret: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enable: Enable or disable key vault credential setting.
         :paramtype enable: bool
         :keyword credential_name: Credential name.
         :paramtype credential_name: str
         :keyword azure_key_vault_url: Azure Key Vault url.
         :paramtype azure_key_vault_url: str
@@ -727,16 +728,16 @@
         self,
         *,
         private_ip_address: Optional["_models.PrivateIPAddress"] = None,
         public_ip_address_resource_id: Optional[str] = None,
         load_balancer_resource_id: Optional[str] = None,
         probe_port: Optional[int] = None,
         sql_virtual_machine_instances: Optional[List[str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword private_ip_address: Private IP address.
         :paramtype private_ip_address: ~azure.mgmt.sqlvirtualmachine.models.PrivateIPAddress
         :keyword public_ip_address_resource_id: Resource id of the public IP.
         :paramtype public_ip_address_resource_id: str
         :keyword load_balancer_resource_id: Resource id of the load balancer.
         :paramtype load_balancer_resource_id: str
@@ -772,15 +773,17 @@
     }
 
     _attribute_map = {
         "private_ip_address": {"key": "privateIpAddress", "type": "PrivateIPAddress"},
         "sql_virtual_machine_instance": {"key": "sqlVirtualMachineInstance", "type": "str"},
     }
 
-    def __init__(self, *, private_ip_address: "_models.PrivateIPAddress", sql_virtual_machine_instance: str, **kwargs):
+    def __init__(
+        self, *, private_ip_address: "_models.PrivateIPAddress", sql_virtual_machine_instance: str, **kwargs: Any
+    ) -> None:
         """
         :keyword private_ip_address: Private IP address. Required.
         :paramtype private_ip_address: ~azure.mgmt.sqlvirtualmachine.models.PrivateIPAddress
         :keyword sql_virtual_machine_instance: SQL virtual machine instance resource id that are
          enrolled into the availability group listener. Required.
         :paramtype sql_virtual_machine_instance: str
         """
@@ -814,15 +817,15 @@
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "display": {"key": "display", "type": "OperationDisplay"},
         "origin": {"key": "origin", "type": "str"},
         "properties": {"key": "properties", "type": "{object}"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.name = None
         self.display = None
         self.origin = None
         self.properties = None
 
@@ -853,15 +856,15 @@
     _attribute_map = {
         "provider": {"key": "provider", "type": "str"},
         "resource": {"key": "resource", "type": "str"},
         "operation": {"key": "operation", "type": "str"},
         "description": {"key": "description", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.provider = None
         self.resource = None
         self.operation = None
         self.description = None
 
@@ -883,15 +886,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Operation]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class PrivateIPAddress(_serialization.Model):
@@ -904,15 +907,17 @@
     """
 
     _attribute_map = {
         "ip_address": {"key": "ipAddress", "type": "str"},
         "subnet_resource_id": {"key": "subnetResourceId", "type": "str"},
     }
 
-    def __init__(self, *, ip_address: Optional[str] = None, subnet_resource_id: Optional[str] = None, **kwargs):
+    def __init__(
+        self, *, ip_address: Optional[str] = None, subnet_resource_id: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword ip_address: Private IP address bound to the availability group listener.
         :paramtype ip_address: str
         :keyword subnet_resource_id: Subnet used to include private IP.
         :paramtype subnet_resource_id: str
         """
         super().__init__(**kwargs)
@@ -942,15 +947,15 @@
 
     _attribute_map = {
         "principal_id": {"key": "principalId", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "tenant_id": {"key": "tenantId", "type": "str"},
     }
 
-    def __init__(self, *, type: Optional[Union[str, "_models.IdentityType"]] = None, **kwargs):
+    def __init__(self, *, type: Optional[Union[str, "_models.IdentityType"]] = None, **kwargs: Any) -> None:
         """
         :keyword type: The identity type. Set this to 'SystemAssigned' in order to automatically create
          and assign an Azure Active Directory principal for the resource. Known values are: "None" and
          "SystemAssigned".
         :paramtype type: str or ~azure.mgmt.sqlvirtualmachine.models.IdentityType
         """
         super().__init__(**kwargs)
@@ -989,16 +994,16 @@
         self,
         *,
         enable: Optional[bool] = None,
         weekly_interval: Optional[int] = None,
         monthly_occurrence: Optional[int] = None,
         day_of_week: Optional[Union[str, "_models.AssessmentDayOfWeek"]] = None,
         start_time: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enable: Enable or disable assessment schedule on SQL virtual machine.
         :paramtype enable: bool
         :keyword weekly_interval: Number of weeks to schedule between 2 assessment runs. Takes value
          from 1-6.
         :paramtype weekly_interval: int
         :keyword monthly_occurrence: Occurrence of the DayOfWeek day within a month to schedule
@@ -1066,16 +1071,16 @@
         *,
         sql_connectivity_update_settings: Optional["_models.SqlConnectivityUpdateSettings"] = None,
         sql_workload_type_update_settings: Optional["_models.SqlWorkloadTypeUpdateSettings"] = None,
         sql_storage_update_settings: Optional["_models.SqlStorageUpdateSettings"] = None,
         additional_features_server_configurations: Optional["_models.AdditionalFeaturesServerConfigurations"] = None,
         sql_instance_settings: Optional["_models.SQLInstanceSettings"] = None,
         azure_ad_authentication_settings: Optional["_models.AADAuthenticationSettings"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword sql_connectivity_update_settings: SQL connectivity type settings.
         :paramtype sql_connectivity_update_settings:
          ~azure.mgmt.sqlvirtualmachine.models.SqlConnectivityUpdateSettings
         :keyword sql_workload_type_update_settings: SQL workload type settings.
         :paramtype sql_workload_type_update_settings:
          ~azure.mgmt.sqlvirtualmachine.models.SqlWorkloadTypeUpdateSettings
@@ -1124,16 +1129,16 @@
     def __init__(
         self,
         *,
         connectivity_type: Optional[Union[str, "_models.ConnectivityType"]] = None,
         port: Optional[int] = None,
         sql_auth_update_user_name: Optional[str] = None,
         sql_auth_update_password: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword connectivity_type: SQL Server connectivity option. Known values are: "LOCAL",
          "PRIVATE", and "PUBLIC".
         :paramtype connectivity_type: str or ~azure.mgmt.sqlvirtualmachine.models.ConnectivityType
         :keyword port: SQL Server port.
         :paramtype port: int
         :keyword sql_auth_update_user_name: SQL Server sysadmin login to create.
@@ -1183,16 +1188,16 @@
         collation: Optional[str] = None,
         max_dop: Optional[int] = None,
         is_optimize_for_ad_hoc_workloads_enabled: Optional[bool] = None,
         min_server_memory_mb: Optional[int] = None,
         max_server_memory_mb: Optional[int] = None,
         is_lpim_enabled: Optional[bool] = None,
         is_ifi_enabled: Optional[bool] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword collation: SQL Server Collation.
         :paramtype collation: str
         :keyword max_dop: SQL Server MAXDOP.
         :paramtype max_dop: int
         :keyword is_optimize_for_ad_hoc_workloads_enabled: SQL Server Optimize for Adhoc workloads.
         :paramtype is_optimize_for_ad_hoc_workloads_enabled: bool
@@ -1225,15 +1230,17 @@
     """
 
     _attribute_map = {
         "luns": {"key": "luns", "type": "[int]"},
         "default_file_path": {"key": "defaultFilePath", "type": "str"},
     }
 
-    def __init__(self, *, luns: Optional[List[int]] = None, default_file_path: Optional[str] = None, **kwargs):
+    def __init__(
+        self, *, luns: Optional[List[int]] = None, default_file_path: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword luns: Logical Unit Numbers for the disks.
         :paramtype luns: list[int]
         :keyword default_file_path: SQL Server default file path.
         :paramtype default_file_path: str
         """
         super().__init__(**kwargs)
@@ -1262,16 +1269,16 @@
 
     def __init__(
         self,
         *,
         disk_count: Optional[int] = None,
         starting_device_id: Optional[int] = None,
         disk_configuration_type: Optional[Union[str, "_models.DiskConfigurationType"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword disk_count: Virtual machine disk count.
         :paramtype disk_count: int
         :keyword starting_device_id: Device id of the first disk to be updated.
         :paramtype starting_device_id: int
         :keyword disk_configuration_type: Disk configuration to apply to SQL Server. Known values are:
          "NEW", "EXTEND", and "ADD".
@@ -1327,16 +1334,16 @@
         log_file_size: Optional[int] = None,
         log_growth: Optional[int] = None,
         data_file_count: Optional[int] = None,
         persist_folder: Optional[bool] = None,
         persist_folder_path: Optional[str] = None,
         luns: Optional[List[int]] = None,
         default_file_path: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword data_file_size: SQL Server tempdb data file size.
         :paramtype data_file_size: int
         :keyword data_growth: SQL Server tempdb data file autoGrowth size.
         :paramtype data_growth: int
         :keyword log_file_size: SQL Server tempdb log file size.
         :paramtype log_file_size: int
@@ -1395,15 +1402,15 @@
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "location": {"key": "location", "type": "str"},
         "tags": {"key": "tags", "type": "{str}"},
     }
 
-    def __init__(self, *, location: str, tags: Optional[Dict[str, str]] = None, **kwargs):
+    def __init__(self, *, location: str, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
         """
         :keyword location: Resource location. Required.
         :paramtype location: str
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         """
         super().__init__(**kwargs)
@@ -1548,16 +1555,16 @@
         auto_patching_settings: Optional["_models.AutoPatchingSettings"] = None,
         auto_backup_settings: Optional["_models.AutoBackupSettings"] = None,
         key_vault_credential_settings: Optional["_models.KeyVaultCredentialSettings"] = None,
         server_configurations_management_settings: Optional["_models.ServerConfigurationsManagementSettings"] = None,
         storage_configuration_settings: Optional["_models.StorageConfigurationSettings"] = None,
         assessment_settings: Optional["_models.AssessmentSettings"] = None,
         enable_automatic_upgrade: bool = False,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword location: Resource location. Required.
         :paramtype location: str
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword identity: Azure Active Directory identity of the server.
         :paramtype identity: ~azure.mgmt.sqlvirtualmachine.models.ResourceIdentity
@@ -1700,16 +1707,16 @@
         self,
         *,
         location: str,
         tags: Optional[Dict[str, str]] = None,
         sql_image_offer: Optional[str] = None,
         sql_image_sku: Optional[Union[str, "_models.SqlVmGroupImageSku"]] = None,
         wsfc_domain_profile: Optional["_models.WsfcDomainProfile"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword location: Resource location. Required.
         :paramtype location: str
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword sql_image_offer: SQL image offer. Examples may include SQL2016-WS2016, SQL2017-WS2016.
         :paramtype sql_image_offer: str
@@ -1746,15 +1753,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[SqlVirtualMachineGroup]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class SqlVirtualMachineGroupUpdate(_serialization.Model):
@@ -1764,15 +1771,15 @@
     :vartype tags: dict[str, str]
     """
 
     _attribute_map = {
         "tags": {"key": "tags", "type": "{str}"},
     }
 
-    def __init__(self, *, tags: Optional[Dict[str, str]] = None, **kwargs):
+    def __init__(self, *, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         """
         super().__init__(**kwargs)
         self.tags = tags
 
@@ -1794,15 +1801,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[SqlVirtualMachine]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class SqlVirtualMachineUpdate(_serialization.Model):
@@ -1812,15 +1819,15 @@
     :vartype tags: dict[str, str]
     """
 
     _attribute_map = {
         "tags": {"key": "tags", "type": "{str}"},
     }
 
-    def __init__(self, *, tags: Optional[Dict[str, str]] = None, **kwargs):
+    def __init__(self, *, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         """
         super().__init__(**kwargs)
         self.tags = tags
 
@@ -1858,16 +1865,16 @@
     def __init__(
         self,
         *,
         start_time_utc: Optional[datetime.datetime] = None,
         end_time_utc: Optional[datetime.datetime] = None,
         troubleshooting_scenario: Optional[Union[str, "_models.TroubleshootingScenario"]] = None,
         properties: Optional["_models.TroubleshootingAdditionalProperties"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword start_time_utc: Start time in UTC timezone.
         :paramtype start_time_utc: ~datetime.datetime
         :keyword end_time_utc: End time in UTC timezone.
         :paramtype end_time_utc: ~datetime.datetime
         :keyword troubleshooting_scenario: SQL VM troubleshooting scenario. "UnhealthyReplica"
         :paramtype troubleshooting_scenario: str or
@@ -1891,15 +1898,17 @@
     :vartype sql_workload_type: str or ~azure.mgmt.sqlvirtualmachine.models.SqlWorkloadType
     """
 
     _attribute_map = {
         "sql_workload_type": {"key": "sqlWorkloadType", "type": "str"},
     }
 
-    def __init__(self, *, sql_workload_type: Optional[Union[str, "_models.SqlWorkloadType"]] = None, **kwargs):
+    def __init__(
+        self, *, sql_workload_type: Optional[Union[str, "_models.SqlWorkloadType"]] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword sql_workload_type: SQL Server workload type. Known values are: "GENERAL", "OLTP", and
          "DW".
         :paramtype sql_workload_type: str or ~azure.mgmt.sqlvirtualmachine.models.SqlWorkloadType
         """
         super().__init__(**kwargs)
         self.sql_workload_type = sql_workload_type
@@ -1939,16 +1948,16 @@
         *,
         sql_data_settings: Optional["_models.SQLStorageSettings"] = None,
         sql_log_settings: Optional["_models.SQLStorageSettings"] = None,
         sql_temp_db_settings: Optional["_models.SQLTempDbSettings"] = None,
         sql_system_db_on_data_disk: Optional[bool] = None,
         disk_configuration_type: Optional[Union[str, "_models.DiskConfigurationType"]] = None,
         storage_workload_type: Optional[Union[str, "_models.StorageWorkloadType"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword sql_data_settings: SQL Server Data Storage Settings.
         :paramtype sql_data_settings: ~azure.mgmt.sqlvirtualmachine.models.SQLStorageSettings
         :keyword sql_log_settings: SQL Server Log Storage Settings.
         :paramtype sql_log_settings: ~azure.mgmt.sqlvirtualmachine.models.SQLStorageSettings
         :keyword sql_temp_db_settings: SQL Server TempDb Storage Settings.
         :paramtype sql_temp_db_settings: ~azure.mgmt.sqlvirtualmachine.models.SQLTempDbSettings
@@ -2005,16 +2014,16 @@
         *,
         created_by: Optional[str] = None,
         created_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
         created_at: Optional[datetime.datetime] = None,
         last_modified_by: Optional[str] = None,
         last_modified_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
         last_modified_at: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword created_by: The identity that created the resource.
         :paramtype created_by: str
         :keyword created_by_type: The type of identity that created the resource. Known values are:
          "User", "Application", "ManagedIdentity", and "Key".
         :paramtype created_by_type: str or ~azure.mgmt.sqlvirtualmachine.models.CreatedByType
         :keyword created_at: The timestamp of resource creation (UTC).
@@ -2043,15 +2052,17 @@
     :vartype unhealthy_replica_info: ~azure.mgmt.sqlvirtualmachine.models.UnhealthyReplicaInfo
     """
 
     _attribute_map = {
         "unhealthy_replica_info": {"key": "unhealthyReplicaInfo", "type": "UnhealthyReplicaInfo"},
     }
 
-    def __init__(self, *, unhealthy_replica_info: Optional["_models.UnhealthyReplicaInfo"] = None, **kwargs):
+    def __init__(
+        self, *, unhealthy_replica_info: Optional["_models.UnhealthyReplicaInfo"] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword unhealthy_replica_info: The unhealthy replica information.
         :paramtype unhealthy_replica_info: ~azure.mgmt.sqlvirtualmachine.models.UnhealthyReplicaInfo
         """
         super().__init__(**kwargs)
         self.unhealthy_replica_info = unhealthy_replica_info
 
@@ -2090,15 +2101,15 @@
         "last_trigger_time_utc": {"key": "lastTriggerTimeUtc", "type": "iso-8601"},
         "start_time_utc": {"key": "startTimeUtc", "type": "iso-8601"},
         "end_time_utc": {"key": "endTimeUtc", "type": "iso-8601"},
         "troubleshooting_scenario": {"key": "troubleshootingScenario", "type": "str"},
         "properties": {"key": "properties", "type": "TroubleshootingAdditionalProperties"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.root_cause = None
         self.last_trigger_time_utc = None
         self.start_time_utc = None
         self.end_time_utc = None
         self.troubleshooting_scenario = None
@@ -2112,15 +2123,15 @@
     :vartype availability_group_name: str
     """
 
     _attribute_map = {
         "availability_group_name": {"key": "availabilityGroupName", "type": "str"},
     }
 
-    def __init__(self, *, availability_group_name: Optional[str] = None, **kwargs):
+    def __init__(self, *, availability_group_name: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword availability_group_name: The name of the availability group.
         :paramtype availability_group_name: str
         """
         super().__init__(**kwargs)
         self.availability_group_name = availability_group_name
 
@@ -2144,16 +2155,16 @@
 
     def __init__(
         self,
         *,
         cluster_bootstrap_account_password: Optional[str] = None,
         cluster_operator_account_password: Optional[str] = None,
         sql_service_account_password: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword cluster_bootstrap_account_password: Cluster bootstrap account password.
         :paramtype cluster_bootstrap_account_password: str
         :keyword cluster_operator_account_password: Cluster operator account password.
         :paramtype cluster_operator_account_password: str
         :keyword sql_service_account_password: SQL service account password.
         :paramtype sql_service_account_password: str
@@ -2211,16 +2222,16 @@
         cluster_bootstrap_account: Optional[str] = None,
         cluster_operator_account: Optional[str] = None,
         sql_service_account: Optional[str] = None,
         file_share_witness_path: Optional[str] = None,
         storage_account_url: Optional[str] = None,
         storage_account_primary_key: Optional[str] = None,
         cluster_subnet_type: Optional[Union[str, "_models.ClusterSubnetType"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword domain_fqdn: Fully qualified name of the domain.
         :paramtype domain_fqdn: str
         :keyword ou_path: Organizational Unit path in which the nodes and cluster will be present.
         :paramtype ou_path: str
         :keyword cluster_bootstrap_account: Account name used for creating cluster (at minimum needs
          permissions to 'Create Computer Objects' in domain).
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machine_groups_operations.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machine_groups_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,34 +28,28 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(
     resource_group_name: str, sql_virtual_machine_group_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachineGroups/{sqlVirtualMachineGroupName}",
     )  # pylint: disable=line-too-long
@@ -80,17 +74,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, sql_virtual_machine_group_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachineGroups/{sqlVirtualMachineGroupName}",
@@ -118,17 +110,15 @@
 
 def build_delete_request(
     resource_group_name: str, sql_virtual_machine_group_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachineGroups/{sqlVirtualMachineGroupName}",
     )  # pylint: disable=line-too-long
@@ -153,17 +143,15 @@
 
 def build_update_request(
     resource_group_name: str, sql_virtual_machine_group_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachineGroups/{sqlVirtualMachineGroupName}",
@@ -189,17 +177,15 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachineGroups",
     )  # pylint: disable=line-too-long
@@ -219,17 +205,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachineGroups"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
@@ -289,33 +273,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SqlVirtualMachineGroup] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_group_name=sql_virtual_machine_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -346,24 +329,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVirtualMachineGroup] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "SqlVirtualMachineGroup")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_group_name=sql_virtual_machine_group_name,
@@ -375,16 +356,17 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -490,16 +472,16 @@
         """Creates or updates a SQL virtual machine group.
 
         :param resource_group_name: Name of the resource group that contains the resource. You can
          obtain this value from the Azure Resource Manager API or the portal. Required.
         :type resource_group_name: str
         :param sql_virtual_machine_group_name: Name of the SQL virtual machine group. Required.
         :type sql_virtual_machine_group_name: str
-        :param parameters: The SQL virtual machine group. Is either a model type or a IO type.
-         Required.
+        :param parameters: The SQL virtual machine group. Is either a SqlVirtualMachineGroup type or a
+         IO type. Required.
         :type parameters: ~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachineGroup or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -513,17 +495,15 @@
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachineGroup]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVirtualMachineGroup] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -576,33 +556,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_group_name=sql_virtual_machine_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -641,17 +620,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -703,24 +680,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVirtualMachineGroup] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "SqlVirtualMachineGroupUpdate")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_group_name=sql_virtual_machine_group_name,
@@ -732,16 +707,17 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -843,16 +819,16 @@
         """Updates SQL virtual machine group tags.
 
         :param resource_group_name: Name of the resource group that contains the resource. You can
          obtain this value from the Azure Resource Manager API or the portal. Required.
         :type resource_group_name: str
         :param sql_virtual_machine_group_name: Name of the SQL virtual machine group. Required.
         :type sql_virtual_machine_group_name: str
-        :param parameters: The SQL virtual machine group. Is either a model type or a IO type.
-         Required.
+        :param parameters: The SQL virtual machine group. Is either a SqlVirtualMachineGroupUpdate type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachineGroupUpdate or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -866,17 +842,15 @@
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachineGroup]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVirtualMachineGroup] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -934,17 +908,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachineGroup]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SqlVirtualMachineGroupListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -989,16 +961,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -1021,17 +994,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachineGroup]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SqlVirtualMachineGroupListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1075,16 +1046,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machines_operations.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machines_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,34 +28,28 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_by_sql_vm_group_request(
     resource_group_name: str, sql_virtual_machine_group_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachineGroups/{sqlVirtualMachineGroupName}/sqlVirtualMachines",
     )  # pylint: disable=line-too-long
@@ -78,17 +72,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachines"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
@@ -113,17 +105,15 @@
     *,
     expand: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachines/{sqlVirtualMachineName}",
     )  # pylint: disable=line-too-long
@@ -155,17 +145,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, sql_virtual_machine_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachines/{sqlVirtualMachineName}",
@@ -198,17 +186,15 @@
 
 def build_delete_request(
     resource_group_name: str, sql_virtual_machine_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachines/{sqlVirtualMachineName}",
     )  # pylint: disable=line-too-long
@@ -238,17 +224,15 @@
 
 def build_update_request(
     resource_group_name: str, sql_virtual_machine_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachines/{sqlVirtualMachineName}",
@@ -279,17 +263,15 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachines",
     )  # pylint: disable=line-too-long
@@ -311,17 +293,15 @@
 
 def build_start_assessment_request(
     resource_group_name: str, sql_virtual_machine_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachines/{sqlVirtualMachineName}/startAssessment",
     )  # pylint: disable=line-too-long
@@ -351,17 +331,15 @@
 
 def build_redeploy_request(
     resource_group_name: str, sql_virtual_machine_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachines/{sqlVirtualMachineName}/redeploy",
     )  # pylint: disable=line-too-long
@@ -423,17 +401,15 @@
         :return: An iterator like instance of either SqlVirtualMachine or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachine]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SqlVirtualMachineListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -479,16 +455,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -509,17 +486,15 @@
         :return: An iterator like instance of either SqlVirtualMachine or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachine]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SqlVirtualMachineListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -563,16 +538,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -608,17 +584,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SqlVirtualMachine] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_name=sql_virtual_machine_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -626,16 +600,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -666,24 +641,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVirtualMachine] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "SqlVirtualMachine")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_name=sql_virtual_machine_name,
@@ -695,16 +668,17 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -808,15 +782,16 @@
         """Creates or updates a SQL virtual machine.
 
         :param resource_group_name: Name of the resource group that contains the resource. You can
          obtain this value from the Azure Resource Manager API or the portal. Required.
         :type resource_group_name: str
         :param sql_virtual_machine_name: Name of the SQL virtual machine. Required.
         :type sql_virtual_machine_name: str
-        :param parameters: The SQL virtual machine. Is either a model type or a IO type. Required.
+        :param parameters: The SQL virtual machine. Is either a SqlVirtualMachine type or a IO type.
+         Required.
         :type parameters: ~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachine or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -829,17 +804,15 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachine]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVirtualMachine] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -892,33 +865,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_name=sql_virtual_machine_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -955,17 +927,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1017,24 +987,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVirtualMachine] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "SqlVirtualMachineUpdate")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_name=sql_virtual_machine_name,
@@ -1046,16 +1014,17 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1155,15 +1124,16 @@
         """Updates a SQL virtual machine.
 
         :param resource_group_name: Name of the resource group that contains the resource. You can
          obtain this value from the Azure Resource Manager API or the portal. Required.
         :type resource_group_name: str
         :param sql_virtual_machine_name: Name of the SQL virtual machine. Required.
         :type sql_virtual_machine_name: str
-        :param parameters: The SQL virtual machine. Is either a model type or a IO type. Required.
+        :param parameters: The SQL virtual machine. Is either a SqlVirtualMachineUpdate type or a IO
+         type. Required.
         :type parameters: ~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachineUpdate or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -1176,17 +1146,15 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachine]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVirtualMachine] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1240,17 +1208,15 @@
         :return: An iterator like instance of either SqlVirtualMachine or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachine]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SqlVirtualMachineListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1295,16 +1261,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -1327,33 +1294,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_start_assessment_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_name=sql_virtual_machine_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._start_assessment_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1392,17 +1358,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._start_assessment_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1450,33 +1414,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_redeploy_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_name=sql_virtual_machine_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._redeploy_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1513,17 +1476,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._redeploy_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_patch.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_operations.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.SqlVirtualMachine/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -89,17 +82,15 @@
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.sqlvirtualmachine.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -142,16 +133,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/__init__.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_availability_group_listeners_operations.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_availability_group_listeners_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,18 +28,14 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -51,17 +47,15 @@
     *,
     expand: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachineGroups/{sqlVirtualMachineGroupName}/availabilityGroupListeners/{availabilityGroupListenerName}",
     )  # pylint: disable=line-too-long
@@ -95,17 +89,15 @@
     availability_group_listener_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachineGroups/{sqlVirtualMachineGroupName}/availabilityGroupListeners/{availabilityGroupListenerName}",
@@ -140,17 +132,15 @@
     availability_group_listener_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachineGroups/{sqlVirtualMachineGroupName}/availabilityGroupListeners/{availabilityGroupListenerName}",
     )  # pylint: disable=line-too-long
@@ -178,17 +168,15 @@
 
 def build_list_by_group_request(
     resource_group_name: str, sql_virtual_machine_group_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachineGroups/{sqlVirtualMachineGroupName}/availabilityGroupListeners",
     )  # pylint: disable=line-too-long
@@ -262,17 +250,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AvailabilityGroupListener] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_group_name=sql_virtual_machine_group_name,
             availability_group_listener_name=availability_group_listener_name,
             subscription_id=self._config.subscription_id,
@@ -281,16 +267,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -322,24 +309,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailabilityGroupListener] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "AvailabilityGroupListener")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_group_name=sql_virtual_machine_group_name,
@@ -352,16 +337,17 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -476,16 +462,16 @@
         :param resource_group_name: Name of the resource group that contains the resource. You can
          obtain this value from the Azure Resource Manager API or the portal. Required.
         :type resource_group_name: str
         :param sql_virtual_machine_group_name: Name of the SQL virtual machine group. Required.
         :type sql_virtual_machine_group_name: str
         :param availability_group_listener_name: Name of the availability group listener. Required.
         :type availability_group_listener_name: str
-        :param parameters: The availability group listener. Is either a model type or a IO type.
-         Required.
+        :param parameters: The availability group listener. Is either a AvailabilityGroupListener type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.sqlvirtualmachine.models.AvailabilityGroupListener or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -499,17 +485,15 @@
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.sqlvirtualmachine.models.AvailabilityGroupListener]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailabilityGroupListener] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -567,17 +551,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_group_name=sql_virtual_machine_group_name,
             availability_group_listener_name=availability_group_listener_name,
             subscription_id=self._config.subscription_id,
@@ -585,16 +567,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -639,17 +622,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -705,17 +686,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.sqlvirtualmachine.models.AvailabilityGroupListener]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AvailabilityGroupListenerListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -761,16 +740,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machine_troubleshoot_operations.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_sql_virtual_machine_troubleshoot_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,34 +26,28 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_troubleshoot_request(
     resource_group_name: str, sql_virtual_machine_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachines/{sqlVirtualMachineName}/troubleshoot",
@@ -117,24 +111,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.SqlVmTroubleshooting]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "SqlVmTroubleshooting")
 
         request = build_troubleshoot_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_name=sql_virtual_machine_name,
@@ -146,16 +138,17 @@
             template_url=self._troubleshoot_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -263,16 +256,16 @@
         """Starts SQL virtual machine troubleshooting.
 
         :param resource_group_name: Name of the resource group that contains the resource. You can
          obtain this value from the Azure Resource Manager API or the portal. Required.
         :type resource_group_name: str
         :param sql_virtual_machine_name: Name of the SQL virtual machine. Required.
         :type sql_virtual_machine_name: str
-        :param parameters: The SQL virtual machine troubleshooting entity. Is either a model type or a
-         IO type. Required.
+        :param parameters: The SQL virtual machine troubleshooting entity. Is either a
+         SqlVmTroubleshooting type or a IO type. Required.
         :type parameters: ~azure.mgmt.sqlvirtualmachine.models.SqlVmTroubleshooting or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -286,17 +279,15 @@
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.sqlvirtualmachine.models.SqlVmTroubleshooting]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVmTroubleshooting] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._troubleshoot_initial(
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/_patch.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/__init__.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/_configuration.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/_configuration.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,51 +2,45 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
+from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
-from .._version import VERSION
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from ._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.credentials import TokenCredential
 
 
 class SqlVirtualMachineManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for SqlVirtualMachineManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
+    :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: Subscription ID that identifies an Azure subscription. Required.
     :type subscription_id: str
     :keyword api_version: Api Version. Default value is "2022-08-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(SqlVirtualMachineManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop("api_version", "2022-08-01-preview")
+        api_version: str = kwargs.pop("api_version", "2022-08-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -58,15 +52,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
+            self.authentication_policy = ARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/_sql_virtual_machine_management_client.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/_sql_virtual_machine_management_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -67,15 +67,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = SqlVirtualMachineManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.availability_group_listeners = AvailabilityGroupListenersOperations(
             self._client, self._config, self._serialize, self._deserialize
@@ -116,9 +116,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "SqlVirtualMachineManagementClient":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details) -> None:
+    async def __aexit__(self, *exc_details: Any) -> None:
         await self._client.__aexit__(*exc_details)
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machine_groups_operations.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machine_groups_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -36,18 +36,14 @@
     build_delete_request,
     build_get_request,
     build_list_by_resource_group_request,
     build_list_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class SqlVirtualMachineGroupsOperations:
     """
     .. warning::
@@ -90,33 +86,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SqlVirtualMachineGroup] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_group_name=sql_virtual_machine_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -147,24 +142,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVirtualMachineGroup] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "SqlVirtualMachineGroup")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_group_name=sql_virtual_machine_group_name,
@@ -176,16 +169,17 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -291,16 +285,16 @@
         """Creates or updates a SQL virtual machine group.
 
         :param resource_group_name: Name of the resource group that contains the resource. You can
          obtain this value from the Azure Resource Manager API or the portal. Required.
         :type resource_group_name: str
         :param sql_virtual_machine_group_name: Name of the SQL virtual machine group. Required.
         :type sql_virtual_machine_group_name: str
-        :param parameters: The SQL virtual machine group. Is either a model type or a IO type.
-         Required.
+        :param parameters: The SQL virtual machine group. Is either a SqlVirtualMachineGroup type or a
+         IO type. Required.
         :type parameters: ~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachineGroup or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -314,17 +308,15 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachineGroup]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVirtualMachineGroup] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -378,33 +370,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_group_name=sql_virtual_machine_group_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -443,17 +434,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -505,24 +494,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVirtualMachineGroup] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "SqlVirtualMachineGroupUpdate")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_group_name=sql_virtual_machine_group_name,
@@ -534,16 +521,17 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -645,16 +633,16 @@
         """Updates SQL virtual machine group tags.
 
         :param resource_group_name: Name of the resource group that contains the resource. You can
          obtain this value from the Azure Resource Manager API or the portal. Required.
         :type resource_group_name: str
         :param sql_virtual_machine_group_name: Name of the SQL virtual machine group. Required.
         :type sql_virtual_machine_group_name: str
-        :param parameters: The SQL virtual machine group. Is either a model type or a IO type.
-         Required.
+        :param parameters: The SQL virtual machine group. Is either a SqlVirtualMachineGroupUpdate type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachineGroupUpdate or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -668,17 +656,15 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachineGroup]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVirtualMachineGroup] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -737,17 +723,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachineGroup]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SqlVirtualMachineGroupListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -792,16 +776,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -824,17 +809,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachineGroup]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SqlVirtualMachineGroupListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -878,16 +861,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machines_operations.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machines_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -39,18 +39,14 @@
     build_list_by_sql_vm_group_request,
     build_list_request,
     build_redeploy_request,
     build_start_assessment_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class SqlVirtualMachinesOperations:
     """
     .. warning::
@@ -86,17 +82,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachine]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SqlVirtualMachineListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -142,16 +136,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -173,17 +168,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachine]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SqlVirtualMachineListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -227,16 +220,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -272,17 +266,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SqlVirtualMachine] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_name=sql_virtual_machine_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -290,16 +282,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -330,24 +323,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVirtualMachine] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "SqlVirtualMachine")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_name=sql_virtual_machine_name,
@@ -359,16 +350,17 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -474,15 +466,16 @@
         """Creates or updates a SQL virtual machine.
 
         :param resource_group_name: Name of the resource group that contains the resource. You can
          obtain this value from the Azure Resource Manager API or the portal. Required.
         :type resource_group_name: str
         :param sql_virtual_machine_name: Name of the SQL virtual machine. Required.
         :type sql_virtual_machine_name: str
-        :param parameters: The SQL virtual machine. Is either a model type or a IO type. Required.
+        :param parameters: The SQL virtual machine. Is either a SqlVirtualMachine type or a IO type.
+         Required.
         :type parameters: ~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachine or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -496,17 +489,15 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachine]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVirtualMachine] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -560,33 +551,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_name=sql_virtual_machine_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -625,17 +615,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -687,24 +675,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVirtualMachine] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "SqlVirtualMachineUpdate")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_name=sql_virtual_machine_name,
@@ -716,16 +702,17 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -827,15 +814,16 @@
         """Updates a SQL virtual machine.
 
         :param resource_group_name: Name of the resource group that contains the resource. You can
          obtain this value from the Azure Resource Manager API or the portal. Required.
         :type resource_group_name: str
         :param sql_virtual_machine_name: Name of the SQL virtual machine. Required.
         :type sql_virtual_machine_name: str
-        :param parameters: The SQL virtual machine. Is either a model type or a IO type. Required.
+        :param parameters: The SQL virtual machine. Is either a SqlVirtualMachineUpdate type or a IO
+         type. Required.
         :type parameters: ~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachineUpdate or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -849,17 +837,15 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachine]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVirtualMachine] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -917,17 +903,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.sqlvirtualmachine.models.SqlVirtualMachine]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SqlVirtualMachineListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -972,16 +956,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -1004,33 +989,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_start_assessment_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_name=sql_virtual_machine_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._start_assessment_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1069,17 +1053,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._start_assessment_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1127,33 +1109,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_redeploy_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_name=sql_virtual_machine_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._redeploy_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1192,17 +1173,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._redeploy_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_patch.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_operations.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
@@ -65,17 +60,15 @@
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.sqlvirtualmachine.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -118,16 +111,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/__init__.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_availability_group_listeners_operations.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_availability_group_listeners_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -34,18 +34,14 @@
 from ...operations._availability_group_listeners_operations import (
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_list_by_group_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AvailabilityGroupListenersOperations:
     """
     .. warning::
@@ -97,17 +93,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AvailabilityGroupListener] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_group_name=sql_virtual_machine_group_name,
             availability_group_listener_name=availability_group_listener_name,
             subscription_id=self._config.subscription_id,
@@ -116,16 +110,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -157,24 +152,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailabilityGroupListener] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "AvailabilityGroupListener")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_group_name=sql_virtual_machine_group_name,
@@ -187,16 +180,17 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -311,16 +305,16 @@
         :param resource_group_name: Name of the resource group that contains the resource. You can
          obtain this value from the Azure Resource Manager API or the portal. Required.
         :type resource_group_name: str
         :param sql_virtual_machine_group_name: Name of the SQL virtual machine group. Required.
         :type sql_virtual_machine_group_name: str
         :param availability_group_listener_name: Name of the availability group listener. Required.
         :type availability_group_listener_name: str
-        :param parameters: The availability group listener. Is either a model type or a IO type.
-         Required.
+        :param parameters: The availability group listener. Is either a AvailabilityGroupListener type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.sqlvirtualmachine.models.AvailabilityGroupListener or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -334,17 +328,15 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.sqlvirtualmachine.models.AvailabilityGroupListener]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailabilityGroupListener] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -403,17 +395,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_group_name=sql_virtual_machine_group_name,
             availability_group_listener_name=availability_group_listener_name,
             subscription_id=self._config.subscription_id,
@@ -421,16 +411,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -475,17 +466,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -541,17 +530,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.sqlvirtualmachine.models.AvailabilityGroupListener]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AvailabilityGroupListenerListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -597,16 +584,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-sqlvirtualmachine-1.0.0b5/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machine_troubleshoot_operations.py` & `azure-mgmt-sqlvirtualmachine-1.0.0b6/azure/mgmt/sqlvirtualmachine/aio/operations/_sql_virtual_machine_troubleshoot_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,18 +26,14 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._sql_virtual_machine_troubleshoot_operations import build_troubleshoot_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class SqlVirtualMachineTroubleshootOperations:
     """
     .. warning::
@@ -71,24 +67,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.SqlVmTroubleshooting]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "SqlVmTroubleshooting")
 
         request = build_troubleshoot_request(
             resource_group_name=resource_group_name,
             sql_virtual_machine_name=sql_virtual_machine_name,
@@ -100,16 +94,17 @@
             template_url=self._troubleshoot_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -217,16 +212,16 @@
         """Starts SQL virtual machine troubleshooting.
 
         :param resource_group_name: Name of the resource group that contains the resource. You can
          obtain this value from the Azure Resource Manager API or the portal. Required.
         :type resource_group_name: str
         :param sql_virtual_machine_name: Name of the SQL virtual machine. Required.
         :type sql_virtual_machine_name: str
-        :param parameters: The SQL virtual machine troubleshooting entity. Is either a model type or a
-         IO type. Required.
+        :param parameters: The SQL virtual machine troubleshooting entity. Is either a
+         SqlVmTroubleshooting type or a IO type. Required.
         :type parameters: ~azure.mgmt.sqlvirtualmachine.models.SqlVmTroubleshooting or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -240,17 +235,15 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.sqlvirtualmachine.models.SqlVmTroubleshooting]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.SqlVmTroubleshooting] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._troubleshoot_initial(
```

